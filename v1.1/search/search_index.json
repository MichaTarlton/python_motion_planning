{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p><code>Motion planning</code> plans the state sequence of the robot without conflict between the start and goal. </p> <p><code>Motion planning</code> mainly includes <code>Path planning</code> and <code>Trajectory planning</code>.</p> <ul> <li><code>Path Planning</code>: It's based on path constraints (such as obstacles), planning the optimal path sequence for the robot to travel without conflict between the start and goal.</li> <li><code>Trajectory planning</code>: It plans the motion state to approach the global path based on kinematics, dynamics constraints and path sequence.</li> </ul> <p>This repository provides the implementations of common <code>Motion planning</code> algorithms. Your stars and forks are welcome. Maintaining this repository requires a huge amount of work. Therefore, you are also welcome to contribute to this repository by opening issues, submitting pull requests or joining our development team.</p> <p>The theory analysis can be found at motion-planning.</p> <p>We also provide ROS C++ version and Matlab version.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#overview","title":"Overview","text":"<p>The file structure is shown below</p> Text Only<pre><code>python_motion_planning\n\u251c\u2500assets\n\u251c\u2500docs\n\u251c\u2500examples\n\u2514\u2500python_motion_planning\n    \u251c\u2500global_planner\n    |   \u251c\u2500graph_search\n    |   \u251c\u2500sample_search\n    |   \u2514\u2500evolutionary_search\n    \u251c\u2500local_planner\n    \u251c\u2500curve_generation\n    \u2514\u2500utils\n        \u251c\u2500agent\n        \u251c\u2500environment\n        \u251c\u2500helper\n        \u251c\u2500planner\n        \u2514\u2500plot\n</code></pre> <ul> <li>The global planning algorithm implementation is in the folder <code>global_planner</code> with <code>graph_search</code>, <code>sample_search</code> and <code>evolutionary search</code>.</li> <li>The local planning algorithm implementation is in the folder <code>local_planner</code>.</li> <li>The curve generation algorithm implementation is in the folder <code>curve_generation</code>.</li> </ul>"},{"location":"index.html#install","title":"Install","text":"<p>(Optional) The code was tested in python=3.10. We recommend using <code>conda</code> to install the dependencies.</p> Bash<pre><code>conda create -n pmp python=3.10\nconda activate pmp\n</code></pre> <p>To install the repository, please run the following command in shell.</p> Bash<pre><code>pip install python-motion-planning\n</code></pre>"},{"location":"index.html#run","title":"Run","text":"<p>Below are some simple examples.</p> <ol> <li> <p>Run planning and animation separately Python<pre><code>import python_motion_planning as pmp\nplanner = pmp.AStar(start=(5, 5), goal=(45, 25), env=pmp.Grid(51, 31))\ncost, path, expand = planner.plan()\nplanner.plot.animation(path, str(planner), cost, expand)  # animation\n</code></pre></p> </li> <li> <p>Run planning and animation in one step Python<pre><code>import python_motion_planning as pmp\nplanner = pmp.AStar(start=(5, 5), goal=(45, 25), env=pmp.Grid(51, 31))\nplanner.run()       # run both planning and animation\n</code></pre></p> </li> <li> <p>Create planner in factory mode Python<pre><code>import python_motion_planning as pmp\nsearch_factory = pmp.SearchFactory()\nplanner = search_factory(\"a_star\", start=(5, 5), goal=(45, 25), env=pmp.Grid(51, 31))\nplanner.run()       # run both planning and animation\n</code></pre></p> </li> </ol> <p>More examples can be found in the folder <code>examples</code> in the repository.</p>"},{"location":"index.html#documentation","title":"Documentation","text":"<p>For more details, you can refer to online documentation.</p> <p>The documentation is auto-generated using mkdocs. To do this, enter the root directory and run</p> Bash<pre><code>python generate_mkdocs.py\nmkdocs serve\n</code></pre> <p>Then open the browser and go to http://127.0.0.1:8000. That is the generated documentation.</p>"},{"location":"index.html#version","title":"Version","text":""},{"location":"index.html#global-planner","title":"Global Planner","text":"Planner Version Animation GBFS Dijkstra A* JPS D* LPA* D* Lite Theta* Lazy Theta* S-Theta* Anya Voronoi RRT RRT* Informed RRT RRT-Connect ACO GA PSO"},{"location":"index.html#local-planner","title":"Local Planner","text":"Planner Version Animation PID APF DWA RPP LQR TEB MPC MPPI Lattice DQN DDPG"},{"location":"index.html#curve-generation","title":"Curve Generation","text":"Planner Version Animation Polynomia Bezier Cubic Spline BSpline Dubins Reeds-Shepp Fem-Pos Smoother"},{"location":"index.html#papers","title":"Papers","text":""},{"location":"index.html#global-planning","title":"Global Planning","text":"<ul> <li>A*:  A Formal Basis for the heuristic Determination of Minimum Cost Paths</li> <li>JPS: Online Graph Pruning for Pathfinding On Grid Maps</li> <li>Lifelong Planning A*:  Lifelong Planning A*</li> <li>D*:  Optimal and Efficient Path Planning for Partially-Known Environments</li> <li>D* Lite:  D* Lite</li> <li>Theta*:  Theta*: Any-Angle Path Planning on Grids</li> <li>Lazy Theta*:  Lazy Theta*: Any-Angle Path Planning and Path Length Analysis in 3D</li> <li>S-Theta*:  S-Theta*: low steering path-planning algorithm</li> <li>Anya:  Optimal Any-Angle Pathfinding In Practice</li> <li>RRT:  Rapidly-Exploring Random Trees: A New Tool for Path Planning</li> <li>RRT-Connect:  RRT-Connect: An Efficient Approach to Single-Query Path Planning</li> <li>RRT*:  Sampling-based algorithms for optimal motion planning</li> <li>Informed RRT*:  Optimal Sampling-based Path Planning Focused via Direct Sampling of an Admissible Ellipsoidal heuristic</li> <li>ACO:  Ant Colony Optimization: A New Meta-Heuristic</li> </ul>"},{"location":"index.html#local-planning","title":"Local Planning","text":"<ul> <li>DWA:  The Dynamic Window Approach to Collision Avoidance</li> <li>APF:  Real-time obstacle avoidance for manipulators and mobile robots</li> <li>RPP:  Regulated Pure Pursuit for Robot Path Tracking</li> <li>DDPG:  Continuous control with deep reinforcement learning</li> </ul>"},{"location":"index.html#curve-generation_1","title":"Curve Generation","text":"<ul> <li>Dubins:  On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents</li> </ul>"},{"location":"index.html#acknowledgment","title":"Acknowledgment","text":"<ul> <li>Our visualization and animation framework of Python Version refers to https://github.com/zhm-real/PathPlanning. Thanks sincerely.</li> </ul>"},{"location":"curve_generation/bezier_curve/Bezier.html","title":"Bezier","text":""},{"location":"curve_generation/bezier_curve/Bezier.html#src.python_motion_planning.curve_generation.bezier_curve.Bezier","title":"<code>src.python_motion_planning.curve_generation.bezier_curve.Bezier</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Bezier curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>offset</code> <code>float</code> <p>The offset of control points</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Bezier\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Bezier(step, offset)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\bezier_curve.py</code> Python<pre><code>class Bezier(Curve):\n\t\"\"\"\n\tClass for Bezier curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\toffset (float): The offset of control points\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import Bezier\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = Bezier(step, offset)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, step: float, offset: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.offset = offset\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Bezier Curve\"\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Bezier Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tx_list (list): x of the trajectory\n\t\t\ty_list (list): y of the trajectory\n\t\t\tyaw_list (list): yaw of the trajectory\n\t\t\"\"\"\n\t\tsx, sy, _ = start_pose\n\t\tgx, gy, _ = goal_pose\n\t\tn_points = int(np.hypot(sx - gx, sy - gy) / self.step)\n\t\tcontrol_points = self.getControlPoints(start_pose, goal_pose)\n\n\t\treturn [self.bezier(t, control_points) for t in np.linspace(0, 1, n_points)], \\\n\t\t\t   control_points\n\n\tdef bezier(self, t: float, control_points: list) -&gt;np.ndarray:\n\t\t\"\"\"\n\t\tCalculate the Bezier curve point.\n\n\t\tParameters:\n\t\t\tt (float): scale factor\n\t\t\tcontrol_points (list[tuple]): control points\n\n\t\tReturns:\n\t\t\tpoint (np.array): point in Bezier curve with t\n\t\t\"\"\"\n\t\tn = len(control_points) - 1\n\t\tcontrol_points = np.array(control_points)\n\t\treturn np.sum([comb(n, i) * t ** i * (1 - t) ** (n - i) *\n\t\t\tcontrol_points[i] for i in range(n + 1)], axis=0)\n\n\tdef getControlPoints(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tCalculate control points heuristically.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tcontrol_points (list[tuple]): Control points\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\tdist = np.hypot(sx - gx, sy - gy) / self.offset\n\t\treturn [(sx, sy),\n\t\t\t\t(sx + dist * np.cos(syaw), sy + dist * np.sin(syaw)),\n\t\t\t\t(gx - dist * np.cos(gyaw), gy - dist * np.sin(gyaw)),\n\t\t\t\t(gx, gy)]\n\n\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n        \"\"\"\n\t\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t\timport matplotlib.pyplot as plt\n\n\t\t# generation\n\t\tpath_x, path_y = [], []\n\t\tpath_control_x, path_control_y = [], []\n\t\tfor i in range(len(points) - 1):\n\t\t\tpath, control_points = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\t\tfor pt in path:\n\t\t\t\tpath_x.append(pt[0])\n\t\t\t\tpath_y.append(pt[1])\n\n\t\t\tpath_control_x.append(points[i][0])\n\t\t\tpath_control_y.append(points[i][1])\n\n\t\t\tfor pt in control_points:\n\t\t\t\tpath_control_x.append(pt[0])\n\t\t\t\tpath_control_y.append(pt[1])\n\n\t\t# animation\n\t\tplt.figure(\"curve generation\")\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\tplt.plot(path_control_x, path_control_y, '--o', c='#dddddd', label=\"Control Points\")\n\t\tfor x, y, theta in points:\n\t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t\tplt.axis(\"equal\")\n\t\tplt.legend()\n\t\tplt.title(str(self))\n\t\tplt.show()\n</code></pre>"},{"location":"curve_generation/bezier_curve/Bezier.html#src.python_motion_planning.curve_generation.bezier_curve.Bezier.bezier","title":"<code>bezier(t, control_points)</code>","text":"<p>Calculate the Bezier curve point.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>scale factor</p> required <code>control_points</code> <code>list[tuple]</code> <p>control points</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>array</code> <p>point in Bezier curve with t</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bezier_curve.py</code> Python<pre><code>def bezier(self, t: float, control_points: list) -&gt;np.ndarray:\n\t\"\"\"\n\tCalculate the Bezier curve point.\n\n\tParameters:\n\t\tt (float): scale factor\n\t\tcontrol_points (list[tuple]): control points\n\n\tReturns:\n\t\tpoint (np.array): point in Bezier curve with t\n\t\"\"\"\n\tn = len(control_points) - 1\n\tcontrol_points = np.array(control_points)\n\treturn np.sum([comb(n, i) * t ** i * (1 - t) ** (n - i) *\n\t\tcontrol_points[i] for i in range(n + 1)], axis=0)\n</code></pre>"},{"location":"curve_generation/bezier_curve/Bezier.html#src.python_motion_planning.curve_generation.bezier_curve.Bezier.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Bezier Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>x_list</code> <code>list</code> <p>x of the trajectory</p> <code>y_list</code> <code>list</code> <p>y of the trajectory</p> <code>yaw_list</code> <code>list</code> <p>yaw of the trajectory</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bezier_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Bezier Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tx_list (list): x of the trajectory\n\t\ty_list (list): y of the trajectory\n\t\tyaw_list (list): yaw of the trajectory\n\t\"\"\"\n\tsx, sy, _ = start_pose\n\tgx, gy, _ = goal_pose\n\tn_points = int(np.hypot(sx - gx, sy - gy) / self.step)\n\tcontrol_points = self.getControlPoints(start_pose, goal_pose)\n\n\treturn [self.bezier(t, control_points) for t in np.linspace(0, 1, n_points)], \\\n\t\t   control_points\n</code></pre>"},{"location":"curve_generation/bezier_curve/Bezier.html#src.python_motion_planning.curve_generation.bezier_curve.Bezier.getControlPoints","title":"<code>getControlPoints(start_pose, goal_pose)</code>","text":"<p>Calculate control points heuristically.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>control_points</code> <code>list[tuple]</code> <p>Control points</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bezier_curve.py</code> Python<pre><code>def getControlPoints(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tCalculate control points heuristically.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tcontrol_points (list[tuple]): Control points\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\tdist = np.hypot(sx - gx, sy - gy) / self.offset\n\treturn [(sx, sy),\n\t\t\t(sx + dist * np.cos(syaw), sy + dist * np.sin(syaw)),\n\t\t\t(gx - dist * np.cos(gyaw), gy - dist * np.sin(gyaw)),\n\t\t\t(gx, gy)]\n</code></pre>"},{"location":"curve_generation/bezier_curve/Bezier.html#src.python_motion_planning.curve_generation.bezier_curve.Bezier.run","title":"<code>run(points)</code>","text":"<p>Running both generation and animation.</p> Text Only<pre><code>    Parameters:\n            points (list[tuple]): path points\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\bezier_curve.py</code> Python<pre><code>\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n        \"\"\"\n\t\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t\timport matplotlib.pyplot as plt\n\n\t\t# generation\n\t\tpath_x, path_y = [], []\n\t\tpath_control_x, path_control_y = [], []\n\t\tfor i in range(len(points) - 1):\n\t\t\tpath, control_points = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\t\tfor pt in path:\n\t\t\t\tpath_x.append(pt[0])\n\t\t\t\tpath_y.append(pt[1])\n\n\t\t\tpath_control_x.append(points[i][0])\n\t\t\tpath_control_y.append(points[i][1])\n\n\t\t\tfor pt in control_points:\n\t\t\t\tpath_control_x.append(pt[0])\n\t\t\t\tpath_control_y.append(pt[1])\n\n\t\t# animation\n\t\tplt.figure(\"curve generation\")\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\tplt.plot(path_control_x, path_control_y, '--o', c='#dddddd', label=\"Control Points\")\n\t\tfor x, y, theta in points:\n\t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t\tplt.axis(\"equal\")\n\t\tplt.legend()\n\t\tplt.title(str(self))\n\t\tplt.show()\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html","title":"BSpline","text":""},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline","title":"<code>src.python_motion_planning.curve_generation.bspline_curve.BSpline</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for B-Spline curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>k</code> <code>int</code> <p>Degree of curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import BSpline\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = BSpline(step, k)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>class BSpline(Curve):\n    \"\"\"\n    Class for B-Spline curve generation.\n\n    Parameters:\n        step (float): Simulation or interpolation size\n        k (int): Degree of curve\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.curve_generation import BSpline\n        &gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n        &gt;&gt;&gt; generator = BSpline(step, k)\n        &gt;&gt;&gt; generator.run(points)\n    \"\"\"\n    def __init__(self, step: float, k: int, param_mode: str=\"centripetal\", \n                 spline_mode: str=\"interpolation\") -&gt; None:\n        super().__init__(step)\n        self.k = k\n\n        assert param_mode == \"centripetal\" or param_mode == \"chord_length\" \\\n               or param_mode == \"uniform_spaced\", \"Parameter selection mode error!\"\n        self.param_mode = param_mode\n\n        assert spline_mode == \"interpolation\" or spline_mode == \"approximation\", \\\n               \"Spline mode selection error!\"\n        self.spline_mode = spline_mode\n\n    def __str__(self) -&gt; str:\n        return \"B-Spline Curve\"\n\n    def baseFunction(self, i: int, k: int, t: float, knot: list):\n        \"\"\"\n        Calculate base function using Cox-deBoor function.\n\n        Parameters:\n            i (int): The index of base function\n            k (int): The degree of curve\n            t (float): parameter\n            knot (list[float]): knot vector\n\n        Returns:\n            Nik_t (float): The value of base function Nik(t)\n        \"\"\"\n        Nik_t = 0\n        if k == 0:\n            Nik_t = 1.0 if t &gt;= knot[i] and t &lt; knot[i + 1] else 0.0\n        else:\n            length1 = knot[i + k] - knot[i]\n            length2 = knot[i + k + 1] - knot[i + 1]\n            if not length1 and not length2:\n                Nik_t = 0\n            elif not length1:\n                Nik_t = (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n            elif not length2:\n                Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot)\n            else:\n                Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot) + \\\n                        (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n        return Nik_t\n\n    def paramSelection(self, points: list):\n        \"\"\"\n        Calculate parameters using the `uniform spaced` or `chrod length`\n        or `centripetal` method.\n\n        Parameters:\n            points (list[tuple]): path points\n\n\t\tReturns:\n\t\t    Parameters (list[float]): The parameters of given points\n        \"\"\"\n        n = len(points)\n        x_list = [pt[0] for pt in points]\n        y_list = [pt[1] for pt in points]\n        dx, dy = np.diff(x_list), np.diff(y_list)\n\n        if self.param_mode == \"uniform_spaced\":\n            return np.linspace(0, 1, n).tolist()\n\n        elif self.param_mode == \"chord_length\":\n            parameters = np.zeros(n)\n            s = np.cumsum([math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)])\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n        elif self.param_mode == \"centripetal\":\n            alpha = 0.5\n            s = np.cumsum([math.pow(math.hypot(idx, idy), alpha) for (idx, idy) in zip(dx, dy)])\n            parameters = np.zeros(n)\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n    def knotGeneration(self, param: list, n: int):\n        \"\"\"\n        Generate knot vector.\n\n        Parameters:\n            param (list[float]): The parameters of given points\n            n (int): The number of data points\n\n\t\tReturns:\n\t\t    knot (list[float]): The knot vector\n        \"\"\"\n        m = n + self.k + 1\n        knot = np.zeros(m)\n        for i in range(self.k + 1):\n            knot[i] = 0\n        for i in range(n, m):\n            knot[i] = 1\n        for i in range(self.k + 1, n):\n            for j in range(i - self.k, i):\n                knot[i] = knot[i] + param[j]\n            knot[i] = knot[i] / self.k\n        return knot.tolist()\n\n    def interpolation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn and a degree k,\n        find a B-spline curve of degree k defined by N control points\n        that passes all data points in the given order.\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n        Returns:\n            control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        N = np.zeros((n, n))\n\n        for i in range(n):\n            for j in range(n):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N[n-1][n-1] = 1\n        N_inv = np.linalg.inv(N)\n\n        D = np.array(points)\n\n        return N_inv @ D\n\n    def approximation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn, a degree k,\n        and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve\n        of degree k defined by H control points that satisfies the\n        following conditions:\n            1. this curve contains the first and last data points;\n            2. this curve approximates the data polygon in the sense\n            of least square\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n\t\tReturns:\n\t\t    control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        D = np.array(points)\n\n        # heuristically setting the number of control points\n        h = n - 1\n\n        N = np.zeros((n, h))\n        for i in range(n):\n            for j in range(h):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N_ = N[1 : n - 1, 1 : h - 1]\n\n        qk = np.zeros((n - 2, 2))\n        for i in range(1, n - 1):\n            qk[i - 1] = D[i, :] - N[i][0] * D[0, :] - N[i][h - 1] * D[-1, :]\n        Q = N_.T @ qk\n\n        P = np.linalg.inv(N_.T @ N_) @ Q\n        P = np.insert(P, 0, D[0, :], axis=0)\n        P = np.insert(P, len(P), D[-1, :], axis=0)\n\n        return P\n\n    def generation(self, t, k, knot, control_pts):\n        \"\"\"\n        Generate the B-spline curve.\n\n        Parameters:\n            t (np.ndarray): The parameter values\n            k (int): The degree of the B-spline curve\n            knot (list[float]): The knot vector\n            control_pts (np.ndarray): The control points\n\n        Returns:\n            curve (np.ndarray): The B-spline curve\n        \"\"\"\n        N = np.zeros((len(t), len(control_pts)))\n\n        for i in range(len(t)):\n            for j in range(len(control_pts)):\n                N[i][j] = self.baseFunction(j, k, t[i], knot)\n        N[len(t) - 1][len(control_pts) - 1] = 1\n\n        return N @ control_pts\n\n    def run(self, points: list, display: bool = True):\n        \"\"\"\n        Running both generation and animation.\n\n        Parameters:\n            points (list[tuple]): path points\n        \"\"\"\n        assert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n        import matplotlib.pyplot as plt\n\n        if len(points[0]) &gt; 2:\n            points = [(points[i][0], points[i][1]) for i in range(len(points))]\n\n        t = np.linspace(0, 1, int(1 / self.step))\n        params = self.paramSelection(points)\n        knot = self.knotGeneration(params, len(points))\n\n        if self.spline_mode == \"interpolation\":\n            control_pts = self.interpolation(points, params, knot)\n        elif self.spline_mode == \"approximation\":\n            control_pts = self.approximation(points, params, knot)\n            h = len(control_pts)\n            new_points = [(control_pts[i][0], control_pts[i][1])\n                for i in range(h)]\n            params = self.paramSelection(new_points)\n            knot = self.knotGeneration(params, h)\n        else:\n            raise NotImplementedError\n\n        control_x = control_pts[:, 0].tolist()\n        control_y = control_pts[:, 1].tolist()\n\n        path = self.generation(t, self.k, knot, control_pts)\n        path_x = path[:, 0].tolist()\n        path_y = path[:, 1].tolist()\n\n        if display:\n            # animation\n            plt.figure(\"curve generation\")\n\n            # static\n            plt.figure(\"curve generation\")\n            plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n            plt.plot(control_x, control_y, '--o', c='#dddddd', label=\"Control Points\")\n            for x, y in points:\n                plt.plot(x, y, \"xr\", linewidth=2)\n            plt.axis(\"equal\")\n            plt.legend()\n            plt.title(str(self))\n\n            plt.show()\n\n        return [(ix, iy) for (ix, iy) in zip(path_x, path_y)]\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.approximation","title":"<code>approximation(points, param, knot)</code>","text":"<p>Given a set of N data points, D0, D1, ..., Dn, a degree k, and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve of degree k defined by H control points that satisfies the following conditions:     1. this curve contains the first and last data points;     2. this curve approximates the data polygon in the sense     of least square</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> <p>Returns:     control_points (np.ndarray): The control points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>    def approximation(self, points: list, param: list, knot: list):\n        \"\"\"\n        Given a set of N data points, D0, D1, ..., Dn, a degree k,\n        and a number H, where N &gt; H &gt; k &gt;= 1, find a B-spline curve\n        of degree k defined by H control points that satisfies the\n        following conditions:\n            1. this curve contains the first and last data points;\n            2. this curve approximates the data polygon in the sense\n            of least square\n\n        Parameters:\n            points (list[tuple]): path points\n            param (list[float]): The parameters of given points\n            knot (list[float]): The knot vector\n\n\t\tReturns:\n\t\t    control_points (np.ndarray): The control points\n        \"\"\"\n        n = len(points)\n        D = np.array(points)\n\n        # heuristically setting the number of control points\n        h = n - 1\n\n        N = np.zeros((n, h))\n        for i in range(n):\n            for j in range(h):\n                N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n        N_ = N[1 : n - 1, 1 : h - 1]\n\n        qk = np.zeros((n - 2, 2))\n        for i in range(1, n - 1):\n            qk[i - 1] = D[i, :] - N[i][0] * D[0, :] - N[i][h - 1] * D[-1, :]\n        Q = N_.T @ qk\n\n        P = np.linalg.inv(N_.T @ N_) @ Q\n        P = np.insert(P, 0, D[0, :], axis=0)\n        P = np.insert(P, len(P), D[-1, :], axis=0)\n\n        return P\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.baseFunction","title":"<code>baseFunction(i, k, t, knot)</code>","text":"<p>Calculate base function using Cox-deBoor function.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>The index of base function</p> required <code>k</code> <code>int</code> <p>The degree of curve</p> required <code>t</code> <code>float</code> <p>parameter</p> required <code>knot</code> <code>list[float]</code> <p>knot vector</p> required <p>Returns:</p> Name Type Description <code>Nik_t</code> <code>float</code> <p>The value of base function Nik(t)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>def baseFunction(self, i: int, k: int, t: float, knot: list):\n    \"\"\"\n    Calculate base function using Cox-deBoor function.\n\n    Parameters:\n        i (int): The index of base function\n        k (int): The degree of curve\n        t (float): parameter\n        knot (list[float]): knot vector\n\n    Returns:\n        Nik_t (float): The value of base function Nik(t)\n    \"\"\"\n    Nik_t = 0\n    if k == 0:\n        Nik_t = 1.0 if t &gt;= knot[i] and t &lt; knot[i + 1] else 0.0\n    else:\n        length1 = knot[i + k] - knot[i]\n        length2 = knot[i + k + 1] - knot[i + 1]\n        if not length1 and not length2:\n            Nik_t = 0\n        elif not length1:\n            Nik_t = (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n        elif not length2:\n            Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot)\n        else:\n            Nik_t = (t - knot[i]) / length1 * self.baseFunction(i, k - 1, t, knot) + \\\n                    (knot[i + k + 1] - t) / length2 * self.baseFunction(i + 1, k - 1, t, knot)\n    return Nik_t\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.generation","title":"<code>generation(t, k, knot, control_pts)</code>","text":"<p>Generate the B-spline curve.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>The parameter values</p> required <code>k</code> <code>int</code> <p>The degree of the B-spline curve</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> required <code>control_pts</code> <code>ndarray</code> <p>The control points</p> required <p>Returns:</p> Name Type Description <code>curve</code> <code>ndarray</code> <p>The B-spline curve</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>def generation(self, t, k, knot, control_pts):\n    \"\"\"\n    Generate the B-spline curve.\n\n    Parameters:\n        t (np.ndarray): The parameter values\n        k (int): The degree of the B-spline curve\n        knot (list[float]): The knot vector\n        control_pts (np.ndarray): The control points\n\n    Returns:\n        curve (np.ndarray): The B-spline curve\n    \"\"\"\n    N = np.zeros((len(t), len(control_pts)))\n\n    for i in range(len(t)):\n        for j in range(len(control_pts)):\n            N[i][j] = self.baseFunction(j, k, t[i], knot)\n    N[len(t) - 1][len(control_pts) - 1] = 1\n\n    return N @ control_pts\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.interpolation","title":"<code>interpolation(points, param, knot)</code>","text":"<p>Given a set of N data points, D0, D1, ..., Dn and a degree k, find a B-spline curve of degree k defined by N control points that passes all data points in the given order.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>knot</code> <code>list[float]</code> <p>The knot vector</p> required <p>Returns:</p> Name Type Description <code>control_points</code> <code>ndarray</code> <p>The control points</p> Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>def interpolation(self, points: list, param: list, knot: list):\n    \"\"\"\n    Given a set of N data points, D0, D1, ..., Dn and a degree k,\n    find a B-spline curve of degree k defined by N control points\n    that passes all data points in the given order.\n\n    Parameters:\n        points (list[tuple]): path points\n        param (list[float]): The parameters of given points\n        knot (list[float]): The knot vector\n\n    Returns:\n        control_points (np.ndarray): The control points\n    \"\"\"\n    n = len(points)\n    N = np.zeros((n, n))\n\n    for i in range(n):\n        for j in range(n):\n            N[i][j] = self.baseFunction(j, self.k, param[i], knot)\n    N[n-1][n-1] = 1\n    N_inv = np.linalg.inv(N)\n\n    D = np.array(points)\n\n    return N_inv @ D\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.knotGeneration","title":"<code>knotGeneration(param, n)</code>","text":"<p>Generate knot vector.</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>list[float]</code> <p>The parameters of given points</p> required <code>n</code> <code>int</code> <p>The number of data points</p> <p>Returns:     knot (list[float]): The knot vector</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>    def knotGeneration(self, param: list, n: int):\n        \"\"\"\n        Generate knot vector.\n\n        Parameters:\n            param (list[float]): The parameters of given points\n            n (int): The number of data points\n\n\t\tReturns:\n\t\t    knot (list[float]): The knot vector\n        \"\"\"\n        m = n + self.k + 1\n        knot = np.zeros(m)\n        for i in range(self.k + 1):\n            knot[i] = 0\n        for i in range(n, m):\n            knot[i] = 1\n        for i in range(self.k + 1, n):\n            for j in range(i - self.k, i):\n                knot[i] = knot[i] + param[j]\n            knot[i] = knot[i] / self.k\n        return knot.tolist()\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.paramSelection","title":"<code>paramSelection(points)</code>","text":"<p>Calculate parameters using the <code>uniform spaced</code> or <code>chrod length</code> or <code>centripetal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> <p>Returns:     Parameters (list[float]): The parameters of given points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>    def paramSelection(self, points: list):\n        \"\"\"\n        Calculate parameters using the `uniform spaced` or `chrod length`\n        or `centripetal` method.\n\n        Parameters:\n            points (list[tuple]): path points\n\n\t\tReturns:\n\t\t    Parameters (list[float]): The parameters of given points\n        \"\"\"\n        n = len(points)\n        x_list = [pt[0] for pt in points]\n        y_list = [pt[1] for pt in points]\n        dx, dy = np.diff(x_list), np.diff(y_list)\n\n        if self.param_mode == \"uniform_spaced\":\n            return np.linspace(0, 1, n).tolist()\n\n        elif self.param_mode == \"chord_length\":\n            parameters = np.zeros(n)\n            s = np.cumsum([math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)])\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n\n        elif self.param_mode == \"centripetal\":\n            alpha = 0.5\n            s = np.cumsum([math.pow(math.hypot(idx, idy), alpha) for (idx, idy) in zip(dx, dy)])\n            parameters = np.zeros(n)\n            for i in range(1, n):\n                parameters[i] = s[i - 1] / s[-1]\n            return parameters.tolist()\n</code></pre>"},{"location":"curve_generation/bspline_curve/BSpline.html#src.python_motion_planning.curve_generation.bspline_curve.BSpline.run","title":"<code>run(points, display=True)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\bspline_curve.py</code> Python<pre><code>def run(self, points: list, display: bool = True):\n    \"\"\"\n    Running both generation and animation.\n\n    Parameters:\n        points (list[tuple]): path points\n    \"\"\"\n    assert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n    import matplotlib.pyplot as plt\n\n    if len(points[0]) &gt; 2:\n        points = [(points[i][0], points[i][1]) for i in range(len(points))]\n\n    t = np.linspace(0, 1, int(1 / self.step))\n    params = self.paramSelection(points)\n    knot = self.knotGeneration(params, len(points))\n\n    if self.spline_mode == \"interpolation\":\n        control_pts = self.interpolation(points, params, knot)\n    elif self.spline_mode == \"approximation\":\n        control_pts = self.approximation(points, params, knot)\n        h = len(control_pts)\n        new_points = [(control_pts[i][0], control_pts[i][1])\n            for i in range(h)]\n        params = self.paramSelection(new_points)\n        knot = self.knotGeneration(params, h)\n    else:\n        raise NotImplementedError\n\n    control_x = control_pts[:, 0].tolist()\n    control_y = control_pts[:, 1].tolist()\n\n    path = self.generation(t, self.k, knot, control_pts)\n    path_x = path[:, 0].tolist()\n    path_y = path[:, 1].tolist()\n\n    if display:\n        # animation\n        plt.figure(\"curve generation\")\n\n        # static\n        plt.figure(\"curve generation\")\n        plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n        plt.plot(control_x, control_y, '--o', c='#dddddd', label=\"Control Points\")\n        for x, y in points:\n            plt.plot(x, y, \"xr\", linewidth=2)\n        plt.axis(\"equal\")\n        plt.legend()\n        plt.title(str(self))\n\n        plt.show()\n\n    return [(ix, iy) for (ix, iy) in zip(path_x, path_y)]\n</code></pre>"},{"location":"curve_generation/cubic_spline/CubicSpline.html","title":"CubicSpline","text":""},{"location":"curve_generation/cubic_spline/CubicSpline.html#src.python_motion_planning.curve_generation.cubic_spline.CubicSpline","title":"<code>src.python_motion_planning.curve_generation.cubic_spline.CubicSpline</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for cubic spline generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import CubicSpline\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = CubicSpline(step)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\cubic_spline.py</code> Python<pre><code>class CubicSpline(Curve):\n\t\"\"\"\n\tClass for cubic spline generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import CubicSpline\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = CubicSpline(step)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, step: float) -&gt; None:\n\t\tsuper().__init__(step)\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Cubic Spline\"\n\n\tdef spline(self, x_list: list, y_list: list, t: list):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tx_list (list[tuple]): path points x-direction\n\t\t\ty_list (list[tuple]): path points y-direction\n\t\t\tt (list): parameter\n\n\t\tReturns:\n\t\t\tp (list): The (x, y) of curve with given t\n\t\t\tdp (list): The derivative (dx, dy) of curve with given t\n\t\t\"\"\"\n\t\t# cubic polynomial functions\n\t\ta, b, c, d = y_list, [], [], []\n\t\th = np.diff(x_list)\n\t\tnum = len(x_list)\n\n\t\t# calculate coefficient matrix\n\t\tA = np.zeros((num, num))\n\t\tfor i in range(1, num - 1):\n\t\t\tA[i, i - 1] = h[i - 1]\n\t\t\tA[i, i] = 2.0 * (h[i - 1] + h[i])\n\t\t\tA[i, i + 1] = h[i]\n\t\tA[0, 0] = 1.0\n\t\tA[num - 1, num - 1] = 1.0\n\n\t\tB = np.zeros(num)\n\t\tfor i in range(1, num - 1):\n\t\t\tB[i] = 3.0 * (a[i + 1] - a[i]) / h[i] - \\\n\t\t\t\t\t3.0 * (a[i] - a[i - 1]) / h[i - 1]\n\n\t\tc = np.linalg.solve(A, B)\n\t\tfor i in range(num - 1):\n\t\t\td.append((c[i + 1] - c[i]) / (3.0 * h[i]))\n\t\t\tb.append((a[i + 1] - a[i]) / h[i] - h[i] * (c[i + 1] + 2.0 * c[i]) / 3.0)\n\n\t\t# calculate spline value and its derivative\n\t\tp, dp = [], []\n\t\tfor it in t:\n\t\t\tif it &lt; x_list[0] or it &gt; x_list[-1]:\n\t\t\t\tcontinue\n\t\t\ti = bisect.bisect(x_list, it) - 1\n\t\t\tdx = it - x_list[i]\n\t\t\tp.append(a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3)\n\t\t\tdp.append(b[i] + 2.0 * c[i] * dx + 3.0 * d[i] * dx**2)\n\n\t\treturn p, dp\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\tpass\n\n\tdef run(self, points: list):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n\t\t\"\"\"\n\t\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t\timport matplotlib.pyplot as plt\n\n\t\tif len(points[0]) == 2:\n\t\t\tx_list = [ix for (ix, _) in points]\n\t\t\ty_list = [iy for (_, iy) in points]\n\t\telif len(points[0]) == 3:\n\t\t\tx_list = [ix for (ix, _, _) in points]\n\t\t\ty_list = [iy for (_, iy, _) in points]\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\tdx, dy = np.diff(x_list), np.diff(y_list)\n\t\tds = [math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)]\n\t\ts = [0]\n\t\ts.extend(np.cumsum(ds))\n\t\tt = np.arange(0, s[-1], self.step)\n\n\t\tpath_x, d_path_x = self.spline(s, x_list, t)\n\t\tpath_y, d_path_y = self.spline(s, y_list, t)\n\t\tpath_yaw = [math.atan2(d_path_y[i], d_path_x[i]) for i in range(len(d_path_x))]\n\n\t\t# animation\n\t\tplt.figure(\"curve generation\")\n\n\t\t# static\n\t\tplt.figure(\"curve generation\")\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\tfor x, y, _ in points:\n\t\t\tplt.plot(x, y, \"xr\", linewidth=2)\n\t\tplt.axis(\"equal\")\n\t\tplt.title(str(self))\n\n\t\tplt.figure(\"yaw\")\n\t\tplt.plot(t, [math.degrees(iyaw) for iyaw in path_yaw], \"-r\")\n\t\tplt.title(\"yaw curve\")\n\n\t\tplt.show()\n</code></pre>"},{"location":"curve_generation/cubic_spline/CubicSpline.html#src.python_motion_planning.curve_generation.cubic_spline.CubicSpline.run","title":"<code>run(points)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\cubic_spline.py</code> Python<pre><code>def run(self, points: list):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tpoints (list[tuple]): path points\n\t\"\"\"\n\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\timport matplotlib.pyplot as plt\n\n\tif len(points[0]) == 2:\n\t\tx_list = [ix for (ix, _) in points]\n\t\ty_list = [iy for (_, iy) in points]\n\telif len(points[0]) == 3:\n\t\tx_list = [ix for (ix, _, _) in points]\n\t\ty_list = [iy for (_, iy, _) in points]\n\telse:\n\t\traise NotImplementedError\n\n\tdx, dy = np.diff(x_list), np.diff(y_list)\n\tds = [math.hypot(idx, idy) for (idx, idy) in zip(dx, dy)]\n\ts = [0]\n\ts.extend(np.cumsum(ds))\n\tt = np.arange(0, s[-1], self.step)\n\n\tpath_x, d_path_x = self.spline(s, x_list, t)\n\tpath_y, d_path_y = self.spline(s, y_list, t)\n\tpath_yaw = [math.atan2(d_path_y[i], d_path_x[i]) for i in range(len(d_path_x))]\n\n\t# animation\n\tplt.figure(\"curve generation\")\n\n\t# static\n\tplt.figure(\"curve generation\")\n\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\tfor x, y, _ in points:\n\t\tplt.plot(x, y, \"xr\", linewidth=2)\n\tplt.axis(\"equal\")\n\tplt.title(str(self))\n\n\tplt.figure(\"yaw\")\n\tplt.plot(t, [math.degrees(iyaw) for iyaw in path_yaw], \"-r\")\n\tplt.title(\"yaw curve\")\n\n\tplt.show()\n</code></pre>"},{"location":"curve_generation/cubic_spline/CubicSpline.html#src.python_motion_planning.curve_generation.cubic_spline.CubicSpline.spline","title":"<code>spline(x_list, y_list, t)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>x_list</code> <code>list[tuple]</code> <p>path points x-direction</p> required <code>y_list</code> <code>list[tuple]</code> <p>path points y-direction</p> required <code>t</code> <code>list</code> <p>parameter</p> required <p>Returns:</p> Name Type Description <code>p</code> <code>list</code> <p>The (x, y) of curve with given t</p> <code>dp</code> <code>list</code> <p>The derivative (dx, dy) of curve with given t</p> Source code in <code>src\\python_motion_planning\\curve_generation\\cubic_spline.py</code> Python<pre><code>def spline(self, x_list: list, y_list: list, t: list):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tx_list (list[tuple]): path points x-direction\n\t\ty_list (list[tuple]): path points y-direction\n\t\tt (list): parameter\n\n\tReturns:\n\t\tp (list): The (x, y) of curve with given t\n\t\tdp (list): The derivative (dx, dy) of curve with given t\n\t\"\"\"\n\t# cubic polynomial functions\n\ta, b, c, d = y_list, [], [], []\n\th = np.diff(x_list)\n\tnum = len(x_list)\n\n\t# calculate coefficient matrix\n\tA = np.zeros((num, num))\n\tfor i in range(1, num - 1):\n\t\tA[i, i - 1] = h[i - 1]\n\t\tA[i, i] = 2.0 * (h[i - 1] + h[i])\n\t\tA[i, i + 1] = h[i]\n\tA[0, 0] = 1.0\n\tA[num - 1, num - 1] = 1.0\n\n\tB = np.zeros(num)\n\tfor i in range(1, num - 1):\n\t\tB[i] = 3.0 * (a[i + 1] - a[i]) / h[i] - \\\n\t\t\t\t3.0 * (a[i] - a[i - 1]) / h[i - 1]\n\n\tc = np.linalg.solve(A, B)\n\tfor i in range(num - 1):\n\t\td.append((c[i + 1] - c[i]) / (3.0 * h[i]))\n\t\tb.append((a[i + 1] - a[i]) / h[i] - h[i] * (c[i + 1] + 2.0 * c[i]) / 3.0)\n\n\t# calculate spline value and its derivative\n\tp, dp = [], []\n\tfor it in t:\n\t\tif it &lt; x_list[0] or it &gt; x_list[-1]:\n\t\t\tcontinue\n\t\ti = bisect.bisect(x_list, it) - 1\n\t\tdx = it - x_list[i]\n\t\tp.append(a[i] + b[i] * dx + c[i] * dx**2 + d[i] * dx**3)\n\t\tdp.append(b[i] + 2.0 * c[i] * dx + 3.0 * d[i] * dx**2)\n\n\treturn p, dp\n</code></pre>"},{"location":"curve_generation/curve/Curve.html","title":"Curve","text":""},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve","title":"<code>src.python_motion_planning.curve_generation.curve.Curve</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>class Curve(ABC):\n\tdef __init__(self, step: float) -&gt; None:\n\t\t\"\"\"\n\t\tBase class for curve generation.\n\n\t\tParameters:\n\t\t\tstep (float): Simulation or interpolation size\n\t\t\"\"\"\n\t\tself.step = step\n\n\t@abstractmethod\n\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n        \"\"\"\n\t\tpass\n\n\t@abstractmethod\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the curve.\n\t\t\"\"\"\n\t\tpass\n\n\tdef trigonometric(self, alpha: float, beta: float):\n\t\t\"\"\"\n\t\tCalculate some useful trigonometric value with angles.\n\t\t\"\"\"\n\t\treturn math.sin(alpha), math.sin(beta), math.cos(alpha), math.cos(beta), \\\n\t\t\tmath.sin(alpha - beta), math.cos(alpha - beta)\n\n\tdef pi2pi(self, theta: float) -&gt; float:\n\t\t\"\"\"\n\t\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\t\t\"\"\"\n\t\twhile theta &gt; math.pi:\n\t\t\ttheta -= 2.0 * math.pi\n\t\twhile theta &lt; -math.pi:\n\t\t\ttheta += 2.0 * math.pi\n\t\treturn theta\n\n\tdef mod2pi(self, theta: float) -&gt; float:\n\t\t\"\"\"\n\t\tPerform modulus operation on 2\u03c0.\n\t\t\"\"\"\n\t\treturn theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)\n\n\tdef length(self, path: list) -&gt; float:\n\t\t\"\"\"\n\t\tCalculate path or trajectory length with `path` format [(ix, iy)] (i from 0 to N)\n\t\t\"\"\"\n\t\tdist = 0\n\t\tfor i in range(len(path) - 1):\n\t\t\tdist = dist + math.hypot(path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])\n\t\treturn dist\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.__init__","title":"<code>__init__(step)</code>","text":"<p>Base class for curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>def __init__(self, step: float) -&gt; None:\n\t\"\"\"\n\tBase class for curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\"\"\"\n\tself.step = step\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.generation","title":"<code>generation(start_pose, goal_pose)</code>  <code>abstractmethod</code>","text":"<p>Generate the curve.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>@abstractmethod\ndef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the curve.\n\t\"\"\"\n\tpass\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.length","title":"<code>length(path)</code>","text":"<p>Calculate path or trajectory length with <code>path</code> format [(ix, iy)] (i from 0 to N)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>def length(self, path: list) -&gt; float:\n\t\"\"\"\n\tCalculate path or trajectory length with `path` format [(ix, iy)] (i from 0 to N)\n\t\"\"\"\n\tdist = 0\n\tfor i in range(len(path) - 1):\n\t\tdist = dist + math.hypot(path[i + 1][0] - path[i][0], path[i + 1][1] - path[i][1])\n\treturn dist\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.mod2pi","title":"<code>mod2pi(theta)</code>","text":"<p>Perform modulus operation on 2\u03c0.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>def mod2pi(self, theta: float) -&gt; float:\n\t\"\"\"\n\tPerform modulus operation on 2\u03c0.\n\t\"\"\"\n\treturn theta - 2.0 * math.pi * math.floor(theta / math.pi / 2.0)\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.pi2pi","title":"<code>pi2pi(theta)</code>","text":"<p>Truncate the angle to the interval of -\u03c0 to \u03c0.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>def pi2pi(self, theta: float) -&gt; float:\n\t\"\"\"\n\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\t\"\"\"\n\twhile theta &gt; math.pi:\n\t\ttheta -= 2.0 * math.pi\n\twhile theta &lt; -math.pi:\n\t\ttheta += 2.0 * math.pi\n\treturn theta\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.run","title":"<code>run(points)</code>  <code>abstractmethod</code>","text":"<p>Running both generation and animation.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>\t@abstractmethod\n\tdef run(self, points: list):\n\t\t\"\"\"\n        Running both generation and animation.\n        \"\"\"\n\t\tpass\n</code></pre>"},{"location":"curve_generation/curve/Curve.html#src.python_motion_planning.curve_generation.curve.Curve.trigonometric","title":"<code>trigonometric(alpha, beta)</code>","text":"<p>Calculate some useful trigonometric value with angles.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\curve.py</code> Python<pre><code>def trigonometric(self, alpha: float, beta: float):\n\t\"\"\"\n\tCalculate some useful trigonometric value with angles.\n\t\"\"\"\n\treturn math.sin(alpha), math.sin(beta), math.cos(alpha), math.cos(beta), \\\n\t\tmath.sin(alpha - beta), math.cos(alpha - beta)\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html","title":"Dubins","text":""},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins","title":"<code>src.python_motion_planning.curve_generation.dubins_curve.Dubins</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Dubins curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_curv</code> <code>float</code> <p>The maximum curvature of the curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Dubins\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Dubins(step, max_curv)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> References <p>[1] On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>class Dubins(Curve):\n\t\"\"\"\n\tClass for Dubins curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\tmax_curv (float): The maximum curvature of the curve\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import Dubins\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = Dubins(step, max_curv)\n\t\t&gt;&gt;&gt; generator.run(points)\n\n\tReferences:\n\t\t[1] On curves of minimal length with a constraint on average curvature, and with prescribed initial and terminal positions and tangents\n\t\"\"\"\n\tdef __init__(self, step: float, max_curv: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.max_curv = max_curv\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Dubins Curve\"\n\n\tdef LSL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)\n\t\tif p_lsl &lt; 0:\n\t\t\treturn None, None, None, [\"L\", \"S\", \"L\"]\n\t\telse:\n\t\t\tp_lsl = math.sqrt(p_lsl)\n\n\t\tt_lsl = self.mod2pi(-alpha + math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\t\tq_lsl = self.mod2pi(beta - math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\n\t\treturn t_lsl, p_lsl, q_lsl, [\"L\", \"S\", \"L\"]\n\n\tdef RSR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Straight-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)\n\t\tif p_rsr &lt; 0:\n\t\t\treturn None, None, None, [\"R\", \"S\", \"R\"]\n\t\telse:\n\t\t\tp_rsr = math.sqrt(p_rsr)\n\n\t\tt_rsr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\t\tq_rsr = self.mod2pi(-beta + math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\n\t\treturn t_rsr, p_rsr, q_rsr, [\"R\", \"S\", \"R\"]\n\n\tdef LSR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)\n\t\tif p_lsr &lt; 0:\n\t\t\treturn None, None, None, [\"L\", \"S\", \"R\"]\n\t\telse:\n\t\t\tp_lsr = math.sqrt(p_lsr)\n\n\t\tt_lsr = self.mod2pi(-alpha + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\t\tq_lsr = self.mod2pi(-beta + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\n\t\treturn t_lsr, p_lsr, q_lsr, [\"L\", \"S\", \"R\"]\n\n\n\tdef RSL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Straight-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)\n\t\tif p_rsl &lt; 0:\n\t\t\treturn None, None, None, [\"R\", \"S\", \"L\"]\n\t\telse:\n\t\t\tp_rsl = math.sqrt(p_rsl)\n\n\t\tt_rsl = self.mod2pi(alpha - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\t\tq_rsl = self.mod2pi(beta - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\n\t\treturn t_rsl, p_rsl, q_rsl, [\"R\", \"S\", \"L\"]\n\n\n\tdef RLR(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tRight-Left-Right generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_rlr = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\t\tif abs(p_rlr) &gt; 1.0:\n\t\t\treturn None, None, None, [\"R\", \"L\", \"R\"]\n\t\telse:\n\t\t\tp_rlr = self.mod2pi(2 * math.pi - math.acos(p_rlr))\n\n\t\tt_rlr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + p_rlr / 2.0)\n\t\tq_rlr = self.mod2pi(alpha - beta - t_rlr + p_rlr)\n\n\t\treturn t_rlr, p_rlr, q_rlr, [\"R\", \"L\", \"R\"]\n\n\tdef LRL(self, alpha: float, beta: float, dist: float):\n\t\t\"\"\"\n\t\tLeft-Right-Left generation mode.\n\n\t\tParameters:\n\t\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\t\tdist (float): The distance between the initial and goal pose\n\n\t\tReturns:\n\t\t\tt (float): Moving lenght of segments\n\t\t\tp (float): Moving lenght of segments\n\t\t\tq (float): Moving lenght of segments\n\t\t\tmode (list): Motion mode\n\t\t\"\"\"\n\t\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\t\tp_lrl = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\t\tif abs(p_lrl) &gt; 1.0:\n\t\t\treturn None, None, None, [\"L\", \"R\", \"L\"]\n\t\telse:\n\t\t\tp_lrl = self.mod2pi(2 * math.pi - math.acos(p_lrl))\n\n\t\tt_lrl = self.mod2pi(-alpha + math.atan2(-cos_a + cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)\n\t\tq_lrl = self.mod2pi(beta - alpha - t_lrl + p_lrl)\n\n\t\treturn t_lrl, p_lrl, q_lrl, [\"L\", \"R\", \"L\"]    \n\n\tdef interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\t\"\"\"\n\t\tPlanning path interpolation.\n\n\t\tParameters:\n\t\t\tmode (str): motion, e.g., L, S, R\n\t\t\tlength (float): Single step motion path length\n\t\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\t\"\"\"\n\t\tx, y, yaw = init_pose\n\n\t\tif mode == \"S\":\n\t\t\tnew_x   = x + length / self.max_curv * math.cos(yaw)\n\t\t\tnew_y   = y + length / self.max_curv * math.sin(yaw)\n\t\t\tnew_yaw = yaw\n\t\telif mode == \"L\":\n\t\t\tnew_x   = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y   = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw + length\n\t\telif mode == \"R\":\n\t\t\tnew_x   = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y   = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw - length\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\treturn new_x, new_y, new_yaw\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Dubins Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tbest_cost (float): Best planning path length\n\t\t\tbest_mode (list): Best motion modes\n\t\t\tx_list (list): Trajectory of x\n\t\t\ty_list (list): Trajectory of y\n\t\t\tyaw_list (list): Trajectory of yaw\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\t# coordinate transformation\n\t\tgx, gy = gx - sx, gy - sy\n\t\ttheta = self.mod2pi(math.atan2(gy, gx))\n\t\tdist = math.hypot(gx, gy) * self.max_curv\n\t\talpha = self.mod2pi(syaw - theta)\n\t\tbeta = self.mod2pi(gyaw - theta)\n\n\t\t# select the best motion\n\t\tplanners = [self.LSL, self.RSR, self.LSR, self.RSL, self.RLR, self.LRL]\n\t\tbest_t, best_p, best_q, best_mode, best_cost = None, None, None, None, float(\"inf\")\n\n\t\tfor planner in planners:\n\t\t\tt, p, q, mode = planner(alpha, beta, dist)\n\t\t\tif t is None:\n\t\t\t\tcontinue\n\t\t\tcost = (abs(t) + abs(p) + abs(q))\n\t\t\tif best_cost &gt; cost:\n\t\t\t\tbest_t, best_p, best_q, best_mode, best_cost = t, p, q, mode, cost\n\n\t\t# interpolation\n\t\tsegments = [best_t, best_p, best_q]\n\t\tpoints_num = int(sum(segments) / self.step) + len(segments) + 3\n\t\tx_list = [0.0 for _ in range(points_num)]\n\t\ty_list = [0.0 for _ in range(points_num)]\n\t\tyaw_list = [alpha for _ in range(points_num)]\n\n\t\ti = 0\n\t\tfor mode_, seg_length in zip(best_mode, segments):\n\t\t\t# path increment\n\t\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t\t# current path length\n\t\t\tlength = d_length\n\t\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\t\ti += 1\n\t\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\t\tlength += d_length\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t\t# failed\n\t\tif len(x_list) &lt;= 1:\n\t\t\treturn None, None, [], [], []\n\n\t\t# remove unused data\n\t\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\t\tx_list.pop()\n\t\t\ty_list.pop()\n\t\t\tyaw_list.pop()\n\n\t\t# coordinate transformation\n\t\trot = Rot.from_euler('z', theta).as_matrix()[0:2, 0:2]\n\t\tconverted_xy = rot @ np.stack([x_list, y_list])\n\t\tx_list = converted_xy[0, :] + sx\n\t\ty_list = converted_xy[1, :] + sy\n\t\tyaw_list = [self.pi2pi(i_yaw + theta) for i_yaw in yaw_list]\n\n\t\treturn best_cost, best_mode, x_list, y_list, yaw_list\n\n\tdef run(self, points: list):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n\t\t\"\"\"\n\t\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t\timport matplotlib.pyplot as plt\n\n\t\t# generation\n\t\tpath_x, path_y, path_yaw = [], [], []\n\t\tfor i in range(len(points) - 1):\n\t\t\t_, _, x_list, y_list, yaw_list = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\t\tfor j in range(len(x_list)):\n\t\t\t\tpath_x.append(x_list[j])\n\t\t\t\tpath_y.append(y_list[j])\n\t\t\t\tpath_yaw.append(yaw_list[j])\n\n\t\t# animation\n\t\tplt.figure(\"curve generation\")\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\tfor x, y, theta in points:\n\t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t\tplt.axis(\"equal\")\n\t\tplt.title(str(self))\n\t\tplt.show()\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.LRL","title":"<code>LRL(alpha, beta, dist)</code>","text":"<p>Left-Right-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def LRL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Right-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lrl = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\tif abs(p_lrl) &gt; 1.0:\n\t\treturn None, None, None, [\"L\", \"R\", \"L\"]\n\telse:\n\t\tp_lrl = self.mod2pi(2 * math.pi - math.acos(p_lrl))\n\n\tt_lrl = self.mod2pi(-alpha + math.atan2(-cos_a + cos_b, dist + sin_a - sin_b) + p_lrl / 2.0)\n\tq_lrl = self.mod2pi(beta - alpha - t_lrl + p_lrl)\n\n\treturn t_lrl, p_lrl, q_lrl, [\"L\", \"R\", \"L\"]    \n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.LSL","title":"<code>LSL(alpha, beta, dist)</code>","text":"<p>Left-Straight-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def LSL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Straight-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lsl = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_a - sin_b)\n\tif p_lsl &lt; 0:\n\t\treturn None, None, None, [\"L\", \"S\", \"L\"]\n\telse:\n\t\tp_lsl = math.sqrt(p_lsl)\n\n\tt_lsl = self.mod2pi(-alpha + math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\tq_lsl = self.mod2pi(beta - math.atan2(cos_b - cos_a, dist + sin_a - sin_b))\n\n\treturn t_lsl, p_lsl, q_lsl, [\"L\", \"S\", \"L\"]\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.LSR","title":"<code>LSR(alpha, beta, dist)</code>","text":"<p>Left-Straight-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def LSR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tLeft-Straight-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_lsr = -2 + dist ** 2 + 2 * cos_a_b + 2 * dist * (sin_a + sin_b)\n\tif p_lsr &lt; 0:\n\t\treturn None, None, None, [\"L\", \"S\", \"R\"]\n\telse:\n\t\tp_lsr = math.sqrt(p_lsr)\n\n\tt_lsr = self.mod2pi(-alpha + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\tq_lsr = self.mod2pi(-beta + math.atan2(-cos_a - cos_b, dist + sin_a + sin_b) - math.atan2(-2.0, p_lsr))\n\n\treturn t_lsr, p_lsr, q_lsr, [\"L\", \"S\", \"R\"]\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.RLR","title":"<code>RLR(alpha, beta, dist)</code>","text":"<p>Right-Left-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def RLR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Left-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rlr = (6.0 - dist ** 2 + 2.0 * cos_a_b + 2.0 * dist * (sin_a - sin_b)) / 8.0\n\tif abs(p_rlr) &gt; 1.0:\n\t\treturn None, None, None, [\"R\", \"L\", \"R\"]\n\telse:\n\t\tp_rlr = self.mod2pi(2 * math.pi - math.acos(p_rlr))\n\n\tt_rlr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b) + p_rlr / 2.0)\n\tq_rlr = self.mod2pi(alpha - beta - t_rlr + p_rlr)\n\n\treturn t_rlr, p_rlr, q_rlr, [\"R\", \"L\", \"R\"]\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.RSL","title":"<code>RSL(alpha, beta, dist)</code>","text":"<p>Right-Straight-Left generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <code>dist</code> <code>float</code> <p>The distance between the initial and goal pose</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def RSL(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Straight-Left generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\t\tdist (float): The distance between the initial and goal pose\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rsl = -2 + dist ** 2 + 2 * cos_a_b - 2 * dist * (sin_a + sin_b)\n\tif p_rsl &lt; 0:\n\t\treturn None, None, None, [\"R\", \"S\", \"L\"]\n\telse:\n\t\tp_rsl = math.sqrt(p_rsl)\n\n\tt_rsl = self.mod2pi(alpha - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\tq_rsl = self.mod2pi(beta - math.atan2(cos_a + cos_b, dist - sin_a - sin_b) + math.atan2(2.0, p_rsl))\n\n\treturn t_rsl, p_rsl, q_rsl, [\"R\", \"S\", \"L\"]\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.RSR","title":"<code>RSR(alpha, beta, dist)</code>","text":"<p>Right-Straight-Right generation mode.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>Initial pose of (0, 0, alpha)</p> required <code>beta</code> <code>float</code> <p>Goal pose of (dist, 0, beta)</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>float</code> <p>Moving lenght of segments</p> <code>p</code> <code>float</code> <p>Moving lenght of segments</p> <code>q</code> <code>float</code> <p>Moving lenght of segments</p> <code>mode</code> <code>list</code> <p>Motion mode</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def RSR(self, alpha: float, beta: float, dist: float):\n\t\"\"\"\n\tRight-Straight-Right generation mode.\n\n\tParameters:\n\t\talpha (float): Initial pose of (0, 0, alpha)\n\t\tbeta (float): Goal pose of (dist, 0, beta)\n\n\tReturns:\n\t\tt (float): Moving lenght of segments\n\t\tp (float): Moving lenght of segments\n\t\tq (float): Moving lenght of segments\n\t\tmode (list): Motion mode\n\t\"\"\"\n\tsin_a, sin_b, cos_a, cos_b, _, cos_a_b  = self.trigonometric(alpha, beta)\n\n\tp_rsr = 2 + dist ** 2 - 2 * cos_a_b + 2 * dist * (sin_b - sin_a)\n\tif p_rsr &lt; 0:\n\t\treturn None, None, None, [\"R\", \"S\", \"R\"]\n\telse:\n\t\tp_rsr = math.sqrt(p_rsr)\n\n\tt_rsr = self.mod2pi(alpha - math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\tq_rsr = self.mod2pi(-beta + math.atan2(cos_a - cos_b, dist - sin_a + sin_b))\n\n\treturn t_rsr, p_rsr, q_rsr, [\"R\", \"S\", \"R\"]\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Dubins Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>best_cost</code> <code>float</code> <p>Best planning path length</p> <code>best_mode</code> <code>list</code> <p>Best motion modes</p> <code>x_list</code> <code>list</code> <p>Trajectory of x</p> <code>y_list</code> <code>list</code> <p>Trajectory of y</p> <code>yaw_list</code> <code>list</code> <p>Trajectory of yaw</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Dubins Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tbest_cost (float): Best planning path length\n\t\tbest_mode (list): Best motion modes\n\t\tx_list (list): Trajectory of x\n\t\ty_list (list): Trajectory of y\n\t\tyaw_list (list): Trajectory of yaw\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\t# coordinate transformation\n\tgx, gy = gx - sx, gy - sy\n\ttheta = self.mod2pi(math.atan2(gy, gx))\n\tdist = math.hypot(gx, gy) * self.max_curv\n\talpha = self.mod2pi(syaw - theta)\n\tbeta = self.mod2pi(gyaw - theta)\n\n\t# select the best motion\n\tplanners = [self.LSL, self.RSR, self.LSR, self.RSL, self.RLR, self.LRL]\n\tbest_t, best_p, best_q, best_mode, best_cost = None, None, None, None, float(\"inf\")\n\n\tfor planner in planners:\n\t\tt, p, q, mode = planner(alpha, beta, dist)\n\t\tif t is None:\n\t\t\tcontinue\n\t\tcost = (abs(t) + abs(p) + abs(q))\n\t\tif best_cost &gt; cost:\n\t\t\tbest_t, best_p, best_q, best_mode, best_cost = t, p, q, mode, cost\n\n\t# interpolation\n\tsegments = [best_t, best_p, best_q]\n\tpoints_num = int(sum(segments) / self.step) + len(segments) + 3\n\tx_list = [0.0 for _ in range(points_num)]\n\ty_list = [0.0 for _ in range(points_num)]\n\tyaw_list = [alpha for _ in range(points_num)]\n\n\ti = 0\n\tfor mode_, seg_length in zip(best_mode, segments):\n\t\t# path increment\n\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t# current path length\n\t\tlength = d_length\n\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\tlength += d_length\n\t\ti += 1\n\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t# failed\n\tif len(x_list) &lt;= 1:\n\t\treturn None, None, [], [], []\n\n\t# remove unused data\n\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\tx_list.pop()\n\t\ty_list.pop()\n\t\tyaw_list.pop()\n\n\t# coordinate transformation\n\trot = Rot.from_euler('z', theta).as_matrix()[0:2, 0:2]\n\tconverted_xy = rot @ np.stack([x_list, y_list])\n\tx_list = converted_xy[0, :] + sx\n\ty_list = converted_xy[1, :] + sy\n\tyaw_list = [self.pi2pi(i_yaw + theta) for i_yaw in yaw_list]\n\n\treturn best_cost, best_mode, x_list, y_list, yaw_list\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.interpolate","title":"<code>interpolate(mode, length, init_pose)</code>","text":"<p>Planning path interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>motion, e.g., L, S, R</p> required <code>length</code> <code>float</code> <p>Single step motion path length</p> required <code>init_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>new_pose</code> <code>tuple</code> <p>New pose (new_x, new_y, new_yaw) after moving</p> Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\"\"\"\n\tPlanning path interpolation.\n\n\tParameters:\n\t\tmode (str): motion, e.g., L, S, R\n\t\tlength (float): Single step motion path length\n\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\tReturns:\n\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\"\"\"\n\tx, y, yaw = init_pose\n\n\tif mode == \"S\":\n\t\tnew_x   = x + length / self.max_curv * math.cos(yaw)\n\t\tnew_y   = y + length / self.max_curv * math.sin(yaw)\n\t\tnew_yaw = yaw\n\telif mode == \"L\":\n\t\tnew_x   = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y   = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw + length\n\telif mode == \"R\":\n\t\tnew_x   = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y   = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw - length\n\telse:\n\t\traise NotImplementedError\n\n\treturn new_x, new_y, new_yaw\n</code></pre>"},{"location":"curve_generation/dubins_curve/Dubins.html#src.python_motion_planning.curve_generation.dubins_curve.Dubins.run","title":"<code>run(points)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\dubins_curve.py</code> Python<pre><code>def run(self, points: list):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tpoints (list[tuple]): path points\n\t\"\"\"\n\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\timport matplotlib.pyplot as plt\n\n\t# generation\n\tpath_x, path_y, path_yaw = [], [], []\n\tfor i in range(len(points) - 1):\n\t\t_, _, x_list, y_list, yaw_list = self.generation(\n\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\tfor j in range(len(x_list)):\n\t\t\tpath_x.append(x_list[j])\n\t\t\tpath_y.append(y_list[j])\n\t\t\tpath_yaw.append(yaw_list[j])\n\n\t# animation\n\tplt.figure(\"curve generation\")\n\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\tfor x, y, theta in points:\n\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\tplt.axis(\"equal\")\n\tplt.title(str(self))\n\tplt.show()\n</code></pre>"},{"location":"curve_generation/fem_pos_smooth/FemPosSmoother.html","title":"FemPosSmoother","text":""},{"location":"curve_generation/fem_pos_smooth/FemPosSmoother.html#src.python_motion_planning.curve_generation.fem_pos_smooth.FemPosSmoother","title":"<code>src.python_motion_planning.curve_generation.fem_pos_smooth.FemPosSmoother</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Fem-pos smoother.</p> <p>Parameters:</p> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import FemPosSmoother\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = FemPosSmoother(w_smooth, w_length, w_ref, dx_l, dx_u, dy_l, dy_u)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\fem_pos_smooth.py</code> Python<pre><code>class FemPosSmoother(Curve):\n\t\"\"\"\n\tClass for Fem-pos smoother.\n\n\tParameters:\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import FemPosSmoother\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = FemPosSmoother(w_smooth, w_length, w_ref, dx_l, dx_u, dy_l, dy_u)\n\t\t&gt;&gt;&gt; generator.run(points)\n\t\"\"\"\n\tdef __init__(self, w_smooth: float, w_length: float, w_ref: float,\n\t\tdx_l: float, dx_u: float, dy_l: float, dy_u: float) -&gt; None:\n\t\tsuper().__init__(0.1)\n\t\tself.w_smooth = w_smooth\n\t\tself.w_length = w_length\n\t\tself.w_ref = w_ref\n\t\tself.dx_l = dx_l\n\t\tself.dx_u = dx_u\n\t\tself.dy_l = dy_l\n\t\tself.dy_u = dy_u\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Fem-pos Smoother\"\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\tpass\n\n\tdef run(self, points: list, display: bool = True):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n\t\t\"\"\"\n\t\tassert len(points) &gt;= 3, \"Number of points should be at least 3.\"\n\t\tif len(points[0]) == 3:\n\t\t\tpoints = [(ix, iy) for ix, iy, _ in points]\n\t\timport matplotlib.pyplot as plt\n\n\t\tn = len(points)\n\t\tP = np.zeros((2 * n, 2 * n))\n\n\t\tX = np.eye(2) * self.w_smooth\n\t\tY = np.eye(2) * self.w_length\n\t\tZ = np.eye(2) * self.w_ref\n\n\t\tP[0:2, 0:2] = X + Y + Z\n\t\tP[0:2, 2:4] = -2 * X - Y\n\t\tP[2:4, 2:4] = 5 * X + 2 * Y + Z\n\t\tP[2 * n - 2:2 * n, 2 * n - 2:2 * n] =  X + Y + Z\n\t\tP[2 * n - 4:2 * n - 2, 2 * n - 4:2 * n - 2] =  5 * X + 2 * Y + Z\n\t\tP[2 * n - 4:2 * n - 2, 2 * n - 2:2 * n] =  -2 * X - Y\n\n\t\tfor i in range(2, n - 2):\n\t\t\tP[2 * i:2 * i + 2, 2 * i:2 * i + 2] = 6 * X + 2 * Y + Z\n\t\tfor i in range(2, n - 1):\n\t\t\tP[2 * i - 2:2 * i, 2 * i:2 * i + 2] = -4 * X - Y\n\t\tfor i in range(2, n):\n\t\t\tP[2 * i - 4:2 * i - 2, 2 * i:2 * i + 2] = X\n\n\t\tA_I = np.eye(2 * n)\n\t\tg = np.zeros((2 * n, 1))\n\t\tlower = np.zeros((2 * n, 1))\n\t\tupper = np.zeros((2 * n, 1))\n\t\tfor i, p in enumerate(points):\n\t\t\tg[2 * i], g[2 * i + 1] = -2 * self.w_ref * p[0], -2 * self.w_ref * p[1]\n\t\t\tlower[2 * i], lower[2 * i + 1] = p[0] - self.dx_l, p[1] - self.dy_l\n\t\t\tupper[2 * i], upper[2 * i + 1] = p[0] + self.dx_u, p[1] + self.dy_u\n\n\t\t# solve\n\t\tsolver = osqp.OSQP()\n\t\tsolver.setup(sparse.csc_matrix(P), g, sparse.csc_matrix(A_I), lower, upper, verbose=False)\n\t\tres = solver.solve()\n\t\topt = res.x\n\n\t\tpath_x, path_y = [], []\n\t\tfor i in range(n):\n\t\t\tpath_x.append(opt[2 * i])\n\t\t\tpath_y.append(opt[2 * i + 1])\n\n\t\tif display:\n\t\t\tplt.figure(\"curve generation\")\n\t\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#ff0000\", marker=\"o\", label=\"smooth path\")\n\t\t\traw_x, raw_y = [], []\n\t\t\tfor i, (x, y) in enumerate(points):\n\t\t\t\t# label = \"bounding box\" if i == 0 else None\n\t\t\t\t# plt.gca().add_patch(\n\t\t\t\t# \tplt.Rectangle(xy=(x - self.dx_l, y - self.dy_l), width=self.dx_u + self.dx_l,\n\t\t\t\t# \theight=self.dy_u + self.dy_l, color='red', linestyle=\"--\", fill=False, label=label)\n\t\t\t\t# )\n\t\t\t\traw_x.append(x)\n\t\t\t\traw_y.append(y)\n\t\t\tplt.plot(raw_x, raw_y, linewidth=2, c=\"#1f77b4\", marker=\"x\", label=\"raw path\")\n\t\t\t# plt.axis(\"equal\")\n\t\t\tplt.legend()\n\t\t\tplt.title(str(self))\n\n\t\t\tplt.show()\n\n\t\treturn [(ix, iy) for (ix, iy) in zip(path_x, path_y)]\n</code></pre>"},{"location":"curve_generation/fem_pos_smooth/FemPosSmoother.html#src.python_motion_planning.curve_generation.fem_pos_smooth.FemPosSmoother.run","title":"<code>run(points, display=True)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\fem_pos_smooth.py</code> Python<pre><code>def run(self, points: list, display: bool = True):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tpoints (list[tuple]): path points\n\t\"\"\"\n\tassert len(points) &gt;= 3, \"Number of points should be at least 3.\"\n\tif len(points[0]) == 3:\n\t\tpoints = [(ix, iy) for ix, iy, _ in points]\n\timport matplotlib.pyplot as plt\n\n\tn = len(points)\n\tP = np.zeros((2 * n, 2 * n))\n\n\tX = np.eye(2) * self.w_smooth\n\tY = np.eye(2) * self.w_length\n\tZ = np.eye(2) * self.w_ref\n\n\tP[0:2, 0:2] = X + Y + Z\n\tP[0:2, 2:4] = -2 * X - Y\n\tP[2:4, 2:4] = 5 * X + 2 * Y + Z\n\tP[2 * n - 2:2 * n, 2 * n - 2:2 * n] =  X + Y + Z\n\tP[2 * n - 4:2 * n - 2, 2 * n - 4:2 * n - 2] =  5 * X + 2 * Y + Z\n\tP[2 * n - 4:2 * n - 2, 2 * n - 2:2 * n] =  -2 * X - Y\n\n\tfor i in range(2, n - 2):\n\t\tP[2 * i:2 * i + 2, 2 * i:2 * i + 2] = 6 * X + 2 * Y + Z\n\tfor i in range(2, n - 1):\n\t\tP[2 * i - 2:2 * i, 2 * i:2 * i + 2] = -4 * X - Y\n\tfor i in range(2, n):\n\t\tP[2 * i - 4:2 * i - 2, 2 * i:2 * i + 2] = X\n\n\tA_I = np.eye(2 * n)\n\tg = np.zeros((2 * n, 1))\n\tlower = np.zeros((2 * n, 1))\n\tupper = np.zeros((2 * n, 1))\n\tfor i, p in enumerate(points):\n\t\tg[2 * i], g[2 * i + 1] = -2 * self.w_ref * p[0], -2 * self.w_ref * p[1]\n\t\tlower[2 * i], lower[2 * i + 1] = p[0] - self.dx_l, p[1] - self.dy_l\n\t\tupper[2 * i], upper[2 * i + 1] = p[0] + self.dx_u, p[1] + self.dy_u\n\n\t# solve\n\tsolver = osqp.OSQP()\n\tsolver.setup(sparse.csc_matrix(P), g, sparse.csc_matrix(A_I), lower, upper, verbose=False)\n\tres = solver.solve()\n\topt = res.x\n\n\tpath_x, path_y = [], []\n\tfor i in range(n):\n\t\tpath_x.append(opt[2 * i])\n\t\tpath_y.append(opt[2 * i + 1])\n\n\tif display:\n\t\tplt.figure(\"curve generation\")\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#ff0000\", marker=\"o\", label=\"smooth path\")\n\t\traw_x, raw_y = [], []\n\t\tfor i, (x, y) in enumerate(points):\n\t\t\t# label = \"bounding box\" if i == 0 else None\n\t\t\t# plt.gca().add_patch(\n\t\t\t# \tplt.Rectangle(xy=(x - self.dx_l, y - self.dy_l), width=self.dx_u + self.dx_l,\n\t\t\t# \theight=self.dy_u + self.dy_l, color='red', linestyle=\"--\", fill=False, label=label)\n\t\t\t# )\n\t\t\traw_x.append(x)\n\t\t\traw_y.append(y)\n\t\tplt.plot(raw_x, raw_y, linewidth=2, c=\"#1f77b4\", marker=\"x\", label=\"raw path\")\n\t\t# plt.axis(\"equal\")\n\t\tplt.legend()\n\t\tplt.title(str(self))\n\n\t\tplt.show()\n\n\treturn [(ix, iy) for (ix, iy) in zip(path_x, path_y)]\n</code></pre>"},{"location":"curve_generation/polynomial_curve/Polynomial.html","title":"Polynomial","text":""},{"location":"curve_generation/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generation.polynomial_curve.Polynomial","title":"<code>src.python_motion_planning.curve_generation.polynomial_curve.Polynomial</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for polynomial curve generation(Quintic).</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_acc</code> <code>float</code> <p>Maximum acceleration</p> required <code>max_jerk</code> <code>float</code> <p>Maximum jerk</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import Polynomial\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = Polynomial(step, max_acc, max_jerk)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> Source code in <code>src\\python_motion_planning\\curve_generation\\polynomial_curve.py</code> Python<pre><code>class Polynomial(Curve):\n    \"\"\"\n    Class for polynomial curve generation(Quintic).\n\n    Parameters:\n        step (float): Simulation or interpolation size\n        max_acc (float): Maximum acceleration\n        max_jerk (float): Maximum jerk\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.curve_generation import Polynomial\n        &gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n        &gt;&gt;&gt; generator = Polynomial(step, max_acc, max_jerk)\n        &gt;&gt;&gt; generator.run(points)\n    \"\"\"\n    def __init__(self, step: float, max_acc: float, max_jerk: float) -&gt; None:\n        super().__init__(step)\n        self.max_acc = max_acc\n        self.max_jerk = max_jerk\n        self.dt = 0.1\n        self.t_min = 1\n        self.t_max = 30\n\n    def __str__(self) -&gt; str:\n        return \"Quintic Polynomial Curve\"\n\n    class Poly:\n        \"\"\"\n        Polynomial interpolation solver\n        \"\"\"\n        def __init__(self, state0: tuple, state1: tuple, t: float) -&gt; None:\n            x0, v0, a0 = state0\n            xt, vt, at = state1\n\n            A = np.array([[t ** 3, t ** 4, t ** 5],\n                          [3 * t ** 2, 4 * t ** 3, 5 * t ** 4],\n                          [6 * t, 12 * t ** 2, 20 * t ** 3]])\n            b = np.array([xt - x0 - v0 * t - a0 * t ** 2 / 2,\n                          vt - v0 - a0 * t,\n                          at - a0])\n            X = np.linalg.solve(A, b)\n\n            # Quintic polynomial coefficient\n            self.p0 = x0\n            self.p1 = v0\n            self.p2 = a0 / 2.0\n            self.p3 = X[0]\n            self.p4 = X[1]\n            self.p5 = X[2]\n\n        def x(self, t):\n            return self.p0 + self.p1 * t + self.p2 * t ** 2 + \\\n                self.p3 * t ** 3 + self.p4 * t ** 4 + self.p5 * t ** 5\n\n        def dx(self, t):\n            return self.p1 + 2 * self.p2 * t + 3 * self.p3 * t ** 2 + \\\n                4 * self.p4 * t ** 3 + 5 * self.p5 * t ** 4\n\n        def ddx(self, t):\n            return 2 * self.p2 + 6 * self.p3 * t + 12 * self.p4 * t ** 2 + 20 * self.p5 * t ** 3\n\n        def dddx(self, t):\n            return 6 * self.p3 + 24 * self.p4 * t + 60 * self.p5 * t ** 2\n\n    class Trajectory:\n        \"\"\"\n        Polynomial interpolation solver\n        \"\"\"\n        def __init__(self):\n            self.clear()\n\n        def clear(self):\n            self.time = []\n            self.x = []\n            self.y = []\n            self.yaw = []\n            self.v = []\n            self.a = []\n            self.jerk = []\n\n        @property\n        def size(self):\n            assert len(self.time) == len(self.x) and \\\n                   len(self.x) == len(self.y) and    \\\n                   len(self.y) == len(self.yaw) and  \\\n                   len(self.yaw) == len(self.v) and  \\\n                   len(self.v) == len(self.a) and    \\\n                   len(self.a) == len(self.jerk),    \\\n                   \"Unequal dimensions of each attribute, this should not happen.\"\n            return len(self.time)\n\n    def generation(self, start_pose: tuple, goal_pose: tuple):\n        \"\"\"\n        Generate the polynomial Curve.\n\n        Parameters:\n            start_pose (tuple): Initial pose (x, y, yaw)\n            goal_pose (tuple): Target pose (x, y, yaw)\n\n        Returns:\n            traj (Traj): The first trajectory that satisfies the acceleration and jerk constraint\n        \"\"\"\n        sx, sy, syaw, sv, sa = start_pose\n        gx, gy, gyaw, gv, ga = goal_pose\n\n        sv_x = sv * math.cos(syaw)\n        sv_y = sv * math.sin(syaw)\n        gv_x = gv * math.cos(gyaw)\n        gv_y = gv * math.sin(gyaw)\n\n        sa_x = sa * math.cos(syaw)\n        sa_y = sa * math.sin(syaw)\n        ga_x = ga * math.cos(gyaw)\n        ga_y = ga * math.sin(gyaw)\n\n        traj = self.Trajectory()\n\n        for T in np.arange(self.t_min, self.t_max, self.step):\n            x_psolver = self.Poly((sx, sv_x, sa_x), (gx, gv_x, ga_x), T)\n            y_psolver = self.Poly((sy, sv_y, sa_y), (gy, gv_y, ga_y), T)\n\n            for t in np.arange(0.0, T + self.dt, self.dt):\n                traj.time.append(t)\n                traj.x.append(x_psolver.x(t))\n                traj.y.append(y_psolver.x(t))\n\n                vx = x_psolver.dx(t)\n                vy = y_psolver.dx(t)\n                traj.v.append(math.hypot(vx, vy))\n                traj.yaw.append(math.atan2(vy, vx))\n\n                ax = x_psolver.ddx(t)\n                ay = y_psolver.ddx(t)\n                a = math.hypot(ax, ay)\n                if len(traj.v) &gt;= 2 and traj.v[-1] - traj.v[-2] &lt; 0.0:\n                    a *= -1\n                traj.a.append(a)\n\n                jx = x_psolver.dddx(t)\n                jy = y_psolver.dddx(t)\n                j = math.hypot(jx, jy)\n                if len(traj.a) &gt;= 2 and traj.a[-1] - traj.a[-2] &lt; 0.0:\n                    j *= -1\n                traj.jerk.append(j)\n\n            if max(np.abs(traj.a)) &lt;= self.max_acc and \\\n               max(np.abs(traj.jerk)) &lt;= self.max_jerk:\n                return traj\n            else:\n                traj.clear()\n\n        return traj\n\n    def run(self, points: list):\n        \"\"\"\n        Running both generation and animation.\n\n        Parameters:\n            points (list[tuple]): path points\n        \"\"\"\n        assert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n        import matplotlib.pyplot as plt\n\n        # generate velocity and acceleration constraints heuristically\n        v = [0]\n        for i in range(len(points) - 1):\n            v.append(1.0)\n\n        a = [(v[i + 1] - v[i]) / 5 for i in range(len(points) - 1)]\n        a.append(0)\n\n        # generate curve\n        path_x, path_y, path_yaw = [], [], []\n        for i in range(len(points) - 1):\n            path = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2]), v[i], a[i]),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2]), v[i + 1], a[i + 1])\n            )\n\n            for j in range(path.size):\n                path_x.append(path.x[j])\n                path_y.append(path.y[j])\n                path_yaw.append(path.yaw[j])\n\n        # animation\n        plt.figure(\"curve generation\")\n\n        # # static\n        # plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n        # for x, y, theta in points:\n        #     Plot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n        # plt.axis(\"equal\")\n        # plt.title(str(self))\n\n        # dynamic\n        plt.ion()\n        for i in range(len(path_x)):\n            plt.clf()\n            plt.gcf().canvas.mpl_connect('key_release_event',\n                                         lambda event: [exit(0) if event.key == 'escape' else None])\n            plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n            for x, y, theta in points:\n                Plot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n            Plot.plotCar(path_x[i], path_y[i], path_yaw[i], 1.5, 3, \"black\")\n            plt.axis(\"equal\")\n            plt.title(str(self))\n            plt.draw()\n            plt.pause(0.001)\n\n        plt.show()\n</code></pre>"},{"location":"curve_generation/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generation.polynomial_curve.Polynomial.Poly","title":"<code>Poly</code>","text":"<p>Polynomial interpolation solver</p> Source code in <code>src\\python_motion_planning\\curve_generation\\polynomial_curve.py</code> Python<pre><code>class Poly:\n    \"\"\"\n    Polynomial interpolation solver\n    \"\"\"\n    def __init__(self, state0: tuple, state1: tuple, t: float) -&gt; None:\n        x0, v0, a0 = state0\n        xt, vt, at = state1\n\n        A = np.array([[t ** 3, t ** 4, t ** 5],\n                      [3 * t ** 2, 4 * t ** 3, 5 * t ** 4],\n                      [6 * t, 12 * t ** 2, 20 * t ** 3]])\n        b = np.array([xt - x0 - v0 * t - a0 * t ** 2 / 2,\n                      vt - v0 - a0 * t,\n                      at - a0])\n        X = np.linalg.solve(A, b)\n\n        # Quintic polynomial coefficient\n        self.p0 = x0\n        self.p1 = v0\n        self.p2 = a0 / 2.0\n        self.p3 = X[0]\n        self.p4 = X[1]\n        self.p5 = X[2]\n\n    def x(self, t):\n        return self.p0 + self.p1 * t + self.p2 * t ** 2 + \\\n            self.p3 * t ** 3 + self.p4 * t ** 4 + self.p5 * t ** 5\n\n    def dx(self, t):\n        return self.p1 + 2 * self.p2 * t + 3 * self.p3 * t ** 2 + \\\n            4 * self.p4 * t ** 3 + 5 * self.p5 * t ** 4\n\n    def ddx(self, t):\n        return 2 * self.p2 + 6 * self.p3 * t + 12 * self.p4 * t ** 2 + 20 * self.p5 * t ** 3\n\n    def dddx(self, t):\n        return 6 * self.p3 + 24 * self.p4 * t + 60 * self.p5 * t ** 2\n</code></pre>"},{"location":"curve_generation/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generation.polynomial_curve.Polynomial.Trajectory","title":"<code>Trajectory</code>","text":"<p>Polynomial interpolation solver</p> Source code in <code>src\\python_motion_planning\\curve_generation\\polynomial_curve.py</code> Python<pre><code>class Trajectory:\n    \"\"\"\n    Polynomial interpolation solver\n    \"\"\"\n    def __init__(self):\n        self.clear()\n\n    def clear(self):\n        self.time = []\n        self.x = []\n        self.y = []\n        self.yaw = []\n        self.v = []\n        self.a = []\n        self.jerk = []\n\n    @property\n    def size(self):\n        assert len(self.time) == len(self.x) and \\\n               len(self.x) == len(self.y) and    \\\n               len(self.y) == len(self.yaw) and  \\\n               len(self.yaw) == len(self.v) and  \\\n               len(self.v) == len(self.a) and    \\\n               len(self.a) == len(self.jerk),    \\\n               \"Unequal dimensions of each attribute, this should not happen.\"\n        return len(self.time)\n</code></pre>"},{"location":"curve_generation/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generation.polynomial_curve.Polynomial.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the polynomial Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>traj</code> <code>Traj</code> <p>The first trajectory that satisfies the acceleration and jerk constraint</p> Source code in <code>src\\python_motion_planning\\curve_generation\\polynomial_curve.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n    \"\"\"\n    Generate the polynomial Curve.\n\n    Parameters:\n        start_pose (tuple): Initial pose (x, y, yaw)\n        goal_pose (tuple): Target pose (x, y, yaw)\n\n    Returns:\n        traj (Traj): The first trajectory that satisfies the acceleration and jerk constraint\n    \"\"\"\n    sx, sy, syaw, sv, sa = start_pose\n    gx, gy, gyaw, gv, ga = goal_pose\n\n    sv_x = sv * math.cos(syaw)\n    sv_y = sv * math.sin(syaw)\n    gv_x = gv * math.cos(gyaw)\n    gv_y = gv * math.sin(gyaw)\n\n    sa_x = sa * math.cos(syaw)\n    sa_y = sa * math.sin(syaw)\n    ga_x = ga * math.cos(gyaw)\n    ga_y = ga * math.sin(gyaw)\n\n    traj = self.Trajectory()\n\n    for T in np.arange(self.t_min, self.t_max, self.step):\n        x_psolver = self.Poly((sx, sv_x, sa_x), (gx, gv_x, ga_x), T)\n        y_psolver = self.Poly((sy, sv_y, sa_y), (gy, gv_y, ga_y), T)\n\n        for t in np.arange(0.0, T + self.dt, self.dt):\n            traj.time.append(t)\n            traj.x.append(x_psolver.x(t))\n            traj.y.append(y_psolver.x(t))\n\n            vx = x_psolver.dx(t)\n            vy = y_psolver.dx(t)\n            traj.v.append(math.hypot(vx, vy))\n            traj.yaw.append(math.atan2(vy, vx))\n\n            ax = x_psolver.ddx(t)\n            ay = y_psolver.ddx(t)\n            a = math.hypot(ax, ay)\n            if len(traj.v) &gt;= 2 and traj.v[-1] - traj.v[-2] &lt; 0.0:\n                a *= -1\n            traj.a.append(a)\n\n            jx = x_psolver.dddx(t)\n            jy = y_psolver.dddx(t)\n            j = math.hypot(jx, jy)\n            if len(traj.a) &gt;= 2 and traj.a[-1] - traj.a[-2] &lt; 0.0:\n                j *= -1\n            traj.jerk.append(j)\n\n        if max(np.abs(traj.a)) &lt;= self.max_acc and \\\n           max(np.abs(traj.jerk)) &lt;= self.max_jerk:\n            return traj\n        else:\n            traj.clear()\n\n    return traj\n</code></pre>"},{"location":"curve_generation/polynomial_curve/Polynomial.html#src.python_motion_planning.curve_generation.polynomial_curve.Polynomial.run","title":"<code>run(points)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\polynomial_curve.py</code> Python<pre><code>    def run(self, points: list):\n        \"\"\"\n        Running both generation and animation.\n\n        Parameters:\n            points (list[tuple]): path points\n        \"\"\"\n        assert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n        import matplotlib.pyplot as plt\n\n        # generate velocity and acceleration constraints heuristically\n        v = [0]\n        for i in range(len(points) - 1):\n            v.append(1.0)\n\n        a = [(v[i + 1] - v[i]) / 5 for i in range(len(points) - 1)]\n        a.append(0)\n\n        # generate curve\n        path_x, path_y, path_yaw = [], [], []\n        for i in range(len(points) - 1):\n            path = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2]), v[i], a[i]),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2]), v[i + 1], a[i + 1])\n            )\n\n            for j in range(path.size):\n                path_x.append(path.x[j])\n                path_y.append(path.y[j])\n                path_yaw.append(path.yaw[j])\n\n        # animation\n        plt.figure(\"curve generation\")\n\n        # # static\n        # plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n        # for x, y, theta in points:\n        #     Plot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n        # plt.axis(\"equal\")\n        # plt.title(str(self))\n\n        # dynamic\n        plt.ion()\n        for i in range(len(path_x)):\n            plt.clf()\n            plt.gcf().canvas.mpl_connect('key_release_event',\n                                         lambda event: [exit(0) if event.key == 'escape' else None])\n            plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n            for x, y, theta in points:\n                Plot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n            Plot.plotCar(path_x[i], path_y[i], path_yaw[i], 1.5, 3, \"black\")\n            plt.axis(\"equal\")\n            plt.title(str(self))\n            plt.draw()\n            plt.pause(0.001)\n\n        plt.show()\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html","title":"ReedsShepp","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp","title":"<code>src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp</code>","text":"<p>               Bases: <code>Curve</code></p> <p>Class for Reeds shepp curve generation.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Simulation or interpolation size</p> required <code>max_curv</code> <code>float</code> <p>The maximum curvature of the curve</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.curve_generation import ReedsShepp\n&gt;&gt;&gt;     points = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n&gt;&gt;&gt; generator = ReedsShepp(step, max_curv)\n&gt;&gt;&gt; generator.run(points)\n</code></pre> References <p>[1] Optimal paths for a car that goes both forwards and backwards</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>class ReedsShepp(Curve):\n\t\"\"\"\n\tClass for Reeds shepp curve generation.\n\n\tParameters:\n\t\tstep (float): Simulation or interpolation size\n\t\tmax_curv (float): The maximum curvature of the curve\n\n\tExamples:\n\t\t&gt;&gt;&gt; from python_motion_planning.curve_generation import ReedsShepp\n\t\t&gt;&gt;&gt;\tpoints = [(0, 0, 0), (10, 10, -90), (20, 5, 60)]\n\t\t&gt;&gt;&gt; generator = ReedsShepp(step, max_curv)\n\t\t&gt;&gt;&gt; generator.run(points)\n\n\tReferences:\n\t\t[1] Optimal paths for a car that goes both forwards and backwards\n\t\"\"\"\n\tdef __init__(self, step: float, max_curv: float) -&gt; None:\n\t\tsuper().__init__(step)\n\t\tself.max_curv = max_curv\n\n\tdef __str__(self) -&gt; str:\n\t\treturn \"Reeds Shepp Curve\"\n\n\tdef R(self, x, y):\n\t\t\"\"\"\n\t\tReturn the polar coordinates (r, theta) of the point (x, y)\n\t\ti.e. rcos(theta) = x; rsin(theta) = y\n\n\t\tParameters:\n\t\t\tx (float): x-coordinate value\n\t\t\ty (float): y-coordinate value\n\n\t\tReturns:\n\t\t\tr, theta (float): Polar coordinates\n\n\t\t\"\"\"\n\t\tr = math.hypot(x, y)\n\t\ttheta = math.atan2(y, x)\n\n\t\treturn r, theta\n\n\tdef M(self, theta):\n\t\t\"\"\"\n\t\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\n\t\tParameters:\n\t\t\ttheta (float): Angle value\n\n\t\tReturns:\n\t\t\ttheta (float): Truncated angle value\n\t\t\"\"\"\n\t\treturn self.pi2pi(theta)\n\n\tclass Path:\n\t\t\"\"\"\n\t\tclass for Path element\n\t\t\"\"\"\n\t\tdef __init__(self, lengths: list = [], ctypes: list = [], x: list = [],\n\t\t\ty: list = [], yaw: list = [], dirs: list = []):\n\t\t\tself.lengths = lengths  \t# lengths of each part of path (+: forward, -: backward)\n\t\t\tself.ctypes = ctypes  \t\t# type of each part of the path\n\t\t\tself.path_length = sum([abs(i) for i in lengths])  # total path length\n\t\t\tself.x = x  \t\t\t\t# x-coordinate value of curve\n\t\t\tself.y = y  \t\t\t\t# y-coordinate value of curve\n\t\t\tself.yaw = yaw  \t\t\t# yaw value of curve\n\t\t\tself.dirs = dirs \t\t\t# direction value of curve (1: forward, -1: backward)\n\n\tdef SLS(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tStraight-Left-Straight generation mode.\n\t\t\"\"\"\n\t\tphi = self.M(phi)\n\n\t\tif y &gt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\t\txd = -y / math.tan(phi) + x\n\t\t\tt = xd - math.tan(phi / 2.0)\n\t\t\tu = phi\n\t\t\tv = math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\t\treturn True, t, u, v\n\t\telif y &lt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\t\txd = -y / math.tan(phi) + x\n\t\t\tt = xd - math.tan(phi / 2.0)\n\t\t\tu = phi\n\t\t\tv = -math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right-Left generation mode. (L+R-L-)\n\t\t\"\"\"\n\t\tr, theta = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\t\tif r &lt;= 4.0:\n\t\t\tu = -2.0 * math.asin(0.25 * r)\n\t\t\tt = self.M(theta + 0.5 * u + math.pi)\n\t\t\tv = self.M(phi - t + u)\n\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LSL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Left generation mode. (L+S+L+)\n\t\t\"\"\"\n\t\tu, t = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\t\tif t &gt;= 0.0:\n\t\t\tv = self.M(phi - t)\n\t\t\tif v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LSR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Straight-Right generation mode. (L+S+R+)\n\t\t\"\"\"\n\t\tr, theta = self.R(x + math.sin(phi), y - 1.0 - math.cos(phi))\n\t\tr = r ** 2\n\n\t\tif r &gt;= 4.0:\n\t\t\tu = math.sqrt(r - 4.0)\n\t\t\tt = self.M(theta + math.atan2(2.0, u))\n\t\t\tv = self.M(t - phi)\n\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRLRn(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho = 0.25 * (2.0 + math.sqrt(xi * xi + eta * eta))\n\n\t\tif rho &lt;= 1.0:\n\t\t\tu = math.acos(rho)\n\t\t\tt, v = self._calTauOmega(u, -u, xi, eta, phi)\n\t\t\tif t &gt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRLRp(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho = (20.0 - xi * xi - eta * eta) / 16.0\n\n\t\tif 0.0 &lt;= rho &lt;= 1.0:\n\t\t\tu = -math.acos(rho)\n\t\t\tif u &gt;= -0.5 * math.pi:\n\t\t\t\tt, v = self._calTauOmega(u, u, xi, eta, phi)\n\t\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\trho, theta = self.R(-eta, xi)\n\n\t\tif rho &gt;= 2.0:\n\t\t\tt = theta\n\t\t\tu = 2.0 - rho\n\t\t\tv = self.M(t + 0.5 * math.pi - phi)\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSL(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)\n\t\t\"\"\"\n\t\txi = x - math.sin(phi)\n\t\teta = y - 1.0 + math.cos(phi)\n\t\trho, theta = self.R(xi, eta)\n\n\t\tif rho &gt;= 2.0:\n\t\t\tr = math.sqrt(rho * rho - 4.0)\n\t\t\tu = 2.0 - r\n\t\t\tt = self.M(theta + math.atan2(r, -2.0))\n\t\t\tv = self.M(phi - 0.5 * math.pi - t)\n\t\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef LRSLR(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\tLeft-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)\n\t\t\"\"\"\n\t\txi = x + math.sin(phi)\n\t\teta = y - 1.0 - math.cos(phi)\n\t\tr, _ = self.R(xi, eta)\n\n\t\tif r &gt;= 2.0:\n\t\t\tu = 4.0 - math.sqrt(r * r - 4.0)\n\t\t\tif u &lt;= 0.0:\n\t\t\t\tt = self.M(math.atan2((4.0 - u) * xi - 2.0 * eta, -2.0 * xi + (u - 4.0) * eta))\n\t\t\t\tv = self.M(t - phi)\n\n\t\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\t\treturn True, t, u, v\n\n\t\treturn False, 0.0, 0.0, 0.0\n\n\tdef SCS(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 2\n\t\tStraight-Circle-Straight generation mode(using reflect).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\tflag, t, u, v = self.SLS(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"L\", \"S\"]))\n\n\t\tflag, t, u, v = self.SLS(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"R\", \"S\"]))\n\n\t\treturn paths\n\n\tdef CCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Circle-Circle generation mode(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-L-\n\t\tflag, t, u, v = self.LRL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# timefilp: L-R+L+\n\t\tflag, t, u, v = self.LRL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# reflect: R+L-R-\n\t\tflag, t, u, v = self.LRL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# timeflip + reflect: R-L+R+\n\t\tflag, t, u, v = self.LRL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# backwards\n\t\txb = x * math.cos(phi) + y * math.sin(phi)\n\t\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t\t# backwards: L-R-L+\n\t\tflag, t, u, v = self.LRL(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: L+R+L-\n\t\tflag, t, u, v = self.LRL(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: R-L-R+\n\t\tflag, t, u, v = self.LRL(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\t# backwards + timeflip + reflect: R+L+R-\n\t\tflag, t, u, v = self.LRL(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t\treturn paths\n\n\tdef CSC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Straight-Circle generation mode(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+S+L+\n\t\tflag, t, u, v = self.LSL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t\t# timefilp: L-S-L-\n\t\tflag, t, u, v = self.LSL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t\t# reflect: R+S+R+\n\t\tflag, t, u, v = self.LSL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t\t# timeflip + reflect: R-S-R-\n\t\tflag, t, u, v = self.LSL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t\t# L+S+R+\n\t\tflag, t, u, v = self.LSR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t\t# timefilp: L-S-R-\n\t\tflag, t, u, v = self.LSR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t\t# reflect: R+S+L+\n\t\tflag, t, u, v = self.LSR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t\t# timeflip + reflect: R+S+l-\n\t\tflag, t, u, v = self.LSR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t\treturn paths\n\n\tdef CCCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 8\n\t\tCircle-Circle(beta)-Circle(beta)-Circle generation mode\n\t\t(using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R+L-R-\n\t\tflag, t, u, v = self.LRLRn(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R-L+R+\n\t\tflag, t, u, v = self.LRLRn(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L+R-L-\n\t\tflag, t, u, v = self.LRLRn(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L-R+L+\n\t\tflag, t, u, v = self.LRLRn(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# L+R-L-R+\n\t\tflag, t, u, v = self.LRLRp(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R+L+R-\n\t\tflag, t, u, v = self.LRLRp(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L-R-L+\n\t\tflag, t, u, v = self.LRLRp(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L+R+L-\n\t\tflag, t, u, v = self.LRLRp(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t\treturn paths\n\n\tdef CCSC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 16\n\t\tCircle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle\n\t\tgeneration mode (using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-(pi/2)S-L-\n\t\tflag, t, u, v = self.LRSL(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+L+\n\t\tflag, t, u, v = self.LRSL(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t\t# reflect: R+L-(pi/2)S-R-\n\t\tflag, t, u, v = self.LRSL(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t\t# timeflip + reflect: R-L+(pi/2)S+R+\n\t\tflag, t, u, v = self.LRSL(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t\t# L+R-(pi/2)S-R-\n\t\tflag, t, u, v = self.LRSR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+R+\n\t\tflag, t, u, v = self.LRSR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t\t# reflect: R+L-(pi/2)S-L-\n\t\tflag, t, u, v = self.LRSR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t\t# timeflip + reflect: R-L+(pi/2)S+L+\n\t\tflag, t, u, v = self.LRSR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t\t# backwards\n\t\txb = x * math.cos(phi) + y * math.sin(phi)\n\t\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t\t# backwards: L-S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSL(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: L+S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSL(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: R-S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSL(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards + timefilp + reflect: R+S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSL(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards: R-S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSR(xb, yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + timefilp: R+S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSR(-xb, yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t\t# backwards + reflect: L-S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSR(xb, -yb, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t\t# backwards + timefilp + reflect: L+S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSR(-xb, -yb, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t\treturn paths\n\n\tdef CCSCC(self, x: float, y: float, phi: float):\n\t\t\"\"\"\n\t\t# 4\n\t\tCircle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).\n\n\t\tParameters:\n\t\t\tx (float): x of goal position\n\t\t\ty (float): y of goal position\n\t\t\tphi (float): goal orientation\n\n\t\tReturns:\n\t\t\tpaths (list): Available paths\n\t\t\"\"\"\n\t\tpaths = []\n\n\t\t# L+R-(pi/2)S-L-(pi/2)R+\n\t\tflag, t, u, v = self.LRSLR(x, y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# timefilp: L-R+(pi/2)S+L+(pi/2)R-\n\t\tflag, t, u, v = self.LRSLR(-x, y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t\t# reflect: R+L-(pi/2)S-R-(pi/2)L+\n\t\tflag, t, u, v = self.LRSLR(x, -y, -phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t\t# timefilp + reflect: R-L+(pi/2)S+R+(pi/2)L-\n\t\tflag, t, u, v = self.LRSLR(-x, -y, phi)\n\t\tif flag:\n\t\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t\treturn paths\n\n\tdef interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\t\"\"\"\n\t\tPlanning path interpolation.\n\n\t\tParameters:\n\t\t\tmode (str): motion, e.g., L, S, R\n\t\t\tlength (float): Single step motion path length\n\t\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\t\"\"\"\n\t\tx, y, yaw = init_pose\n\n\t\tif mode == \"S\":\n\t\t\tnew_x = x + length / self.max_curv * math.cos(yaw)\n\t\t\tnew_y = y + length / self.max_curv * math.sin(yaw)\n\t\t\tnew_yaw = yaw\n\t\telif mode == \"L\":\n\t\t\tnew_x = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw + length\n\t\telif mode == \"R\":\n\t\t\tnew_x = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\t\tnew_y = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\t\tnew_yaw = yaw - length\n\t\telse:\n\t\t\traise NotImplementedError\n\n\t\treturn new_x, new_y, new_yaw\n\n\tdef generation(self, start_pose: tuple, goal_pose: tuple):\n\t\t\"\"\"\n\t\tGenerate the Reeds Shepp Curve.\n\n\t\tParameters:\n\t\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\t\tReturns:\n\t\t\tbest_cost (float): Best planning path length\n\t\t\tbest_mode: Best motion modes\n\t\t\tx_list (list): Trajectory of x\n\t\t\ty_list (list): Trajectory of y\n\t\t\tyaw_list (list): Trajectory of yaw\n\t\t\"\"\"\n\t\tsx, sy, syaw = start_pose\n\t\tgx, gy, gyaw = goal_pose\n\n\t\t# coordinate transformation\n\t\tdx, dy, dyaw = gx - sx, gy - sy, gyaw - syaw\n\t\tx = (math.cos(syaw) * dx + math.sin(syaw) * dy) * self.max_curv\n\t\ty = (-math.sin(syaw) * dx + math.cos(syaw) * dy) * self.max_curv\n\n\t\t# select the best motion\n\t\tplanners = [self.SCS, self.CCC, self.CSC, self.CCCC, self.CCSC, self.CCSCC]\n\t\tbest_path, best_cost = None, float(\"inf\")\n\n\t\tfor planner in planners:\n\t\t\tpaths = planner(x, y, dyaw)\n\t\t\tfor path in paths:\n\t\t\t\tif path.path_length &lt; best_cost:\n\t\t\t\t\tbest_path, best_cost = path, path.path_length\n\n\t\t# interpolation\n\t\tpoints_num = int(best_cost / self.step) + len(best_path.lengths) + 3\n\t\tx_list = [0.0 for _ in range(points_num)]\n\t\ty_list = [0.0 for _ in range(points_num)]\n\t\tyaw_list = [0.0 for _ in range(points_num)]\n\n\t\ti = 0\n\t\tfor mode_, seg_length in zip(best_path.ctypes, best_path.lengths):\n\t\t\t# path increment\n\t\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t\t# current path length\n\t\t\tlength = d_length\n\t\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\t\ti += 1\n\t\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\t\tlength += d_length\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t\t# failed\n\t\tif len(x_list) &lt;= 1:\n\t\t\treturn None, None, [], [], []\n\n\t\t# remove unused data\n\t\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\t\tx_list.pop()\n\t\t\ty_list.pop()\n\t\t\tyaw_list.pop()\n\n\t\t# coordinate transformation\n\t\tx_list_ = [math.cos(-syaw) * ix + math.sin(-syaw) * iy + sx for (ix, iy) in zip(x_list, y_list)]\n\t\ty_list_ = [-math.sin(-syaw) * ix + math.cos(-syaw) * iy + sy for (ix, iy) in zip(x_list, y_list)]\n\t\tyaw_list_ = [self.pi2pi(iyaw + syaw) for iyaw in yaw_list]\n\n\t\treturn best_cost / self.max_curv, best_path.ctypes, x_list_, y_list_, yaw_list_\n\n\tdef run(self, points: list):\n\t\t\"\"\"\n\t\tRunning both generation and animation.\n\n\t\tParameters:\n\t\t\tpoints (list[tuple]): path points\n\t\t\"\"\"\n\t\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\t\timport matplotlib.pyplot as plt\n\n\t\t# generation\n\t\tpath_x, path_y, path_yaw = [], [], []\n\t\tfor i in range(len(points) - 1):\n\t\t\t_, _, x_list, y_list, yaw_list = self.generation(\n\t\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\t\tfor j in range(len(x_list)):\n\t\t\t\tpath_x.append(x_list[j])\n\t\t\t\tpath_y.append(y_list[j])\n\t\t\t\tpath_yaw.append(yaw_list[j])\n\n\t\t# animation\n\t\tplt.figure(\"curve generation\")\n\t\t# # static\n\t\t# plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\t# for x, y, theta in points:\n\t\t# \tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t\t# dynamic\n\t\tplt.ion()\n\t\tfor i in range(len(path_x)):\n\t\t\tplt.clf()\n\t\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\t\tlambda event: [exit(0) if event.key == 'escape' else None])\n\t\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\t\tfor x, y, theta in points:\n\t\t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\t\t\tPlot.plotCar(path_x[i], path_y[i], path_yaw[i], 1.5, 3, \"black\")\n\t\t\tplt.axis(\"equal\")\n\t\t\tplt.title(str(self))\n\t\t\tplt.draw()\n\t\t\tplt.pause(0.001)\n\n\t\tplt.axis(\"equal\")\n\t\tplt.title(str(self))\n\t\tplt.show()\n\n\n\tdef _calTauOmega(self, u, v, xi, eta, phi):\n\t\tdelta = self.M(u - v)\n\t\tA = math.sin(u) - math.sin(delta)\n\t\tB = math.cos(u) - math.cos(delta) - 1.0\n\n\t\tt1 = math.atan2(eta * A - xi * B, xi * A + eta * B)\n\t\tt2 = 2.0 * (math.cos(delta) - math.cos(v) - math.cos(u)) + 3.0\n\n\t\ttau = self.M(t1 + math.pi) if t2 &lt; 0 else self.M(t1)\n\t\tomega = self.M(tau - u + v - phi)\n\n\t\treturn tau, omega\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.Path","title":"<code>Path</code>","text":"<p>class for Path element</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>class Path:\n\t\"\"\"\n\tclass for Path element\n\t\"\"\"\n\tdef __init__(self, lengths: list = [], ctypes: list = [], x: list = [],\n\t\ty: list = [], yaw: list = [], dirs: list = []):\n\t\tself.lengths = lengths  \t# lengths of each part of path (+: forward, -: backward)\n\t\tself.ctypes = ctypes  \t\t# type of each part of the path\n\t\tself.path_length = sum([abs(i) for i in lengths])  # total path length\n\t\tself.x = x  \t\t\t\t# x-coordinate value of curve\n\t\tself.y = y  \t\t\t\t# y-coordinate value of curve\n\t\tself.yaw = yaw  \t\t\t# yaw value of curve\n\t\tself.dirs = dirs \t\t\t# direction value of curve (1: forward, -1: backward)\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCC","title":"<code>CCC(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCC--8","title":"8","text":"<p>Circle-Circle-Circle generation mode(using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def CCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Circle-Circle generation mode(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-L-\n\tflag, t, u, v = self.LRL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# timefilp: L-R+L+\n\tflag, t, u, v = self.LRL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# reflect: R+L-R-\n\tflag, t, u, v = self.LRL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# timeflip + reflect: R-L+R+\n\tflag, t, u, v = self.LRL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# backwards\n\txb = x * math.cos(phi) + y * math.sin(phi)\n\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t# backwards: L-R-L+\n\tflag, t, u, v = self.LRL(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: L+R+L-\n\tflag, t, u, v = self.LRL(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"L\", \"R\", \"L\"]))\n\n\t# backwards + reflect: R-L-R+\n\tflag, t, u, v = self.LRL(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\t# backwards + timeflip + reflect: R+L+R-\n\tflag, t, u, v = self.LRL(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, -t], ctypes=[\"R\", \"L\", \"R\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCCC","title":"<code>CCCC(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCCC--8","title":"8","text":"<p>Circle-Circle(beta)-Circle(beta)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def CCCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Circle(beta)-Circle(beta)-Circle generation mode\n\t(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R+L-R-\n\tflag, t, u, v = self.LRLRn(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# timefilp: L-R-L+R+\n\tflag, t, u, v = self.LRLRn(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# reflect: R+L+R-L-\n\tflag, t, u, v = self.LRLRn(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, -u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# timeflip + reflect: R-L-R+L+\n\tflag, t, u, v = self.LRLRn(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# L+R-L-R+\n\tflag, t, u, v = self.LRLRp(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# timefilp: L-R+L+R-\n\tflag, t, u, v = self.LRLRp(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"L\", \"R\", \"L\", \"R\"]))\n\n\t# reflect: R+L-R-L+\n\tflag, t, u, v = self.LRLRp(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, u, v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\t# timeflip + reflect: R-L+R+L-\n\tflag, t, u, v = self.LRLRp(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -u, -v], ctypes=[\"R\", \"L\", \"R\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCSC","title":"<code>CCSC(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCSC--16","title":"16","text":"<p>Circle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def CCSC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 16\n\tCircle-Circle(pi/2)-Straight-Circle and Circle-Straight-Circle(pi/2)-Circle\n\tgeneration mode (using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-(pi/2)S-L-\n\tflag, t, u, v = self.LRSL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t# timefilp: L-R+(pi/2)S+L+\n\tflag, t, u, v = self.LRSL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"L\"]))\n\n\t# reflect: R+L-(pi/2)S-R-\n\tflag, t, u, v = self.LRSL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t# timeflip + reflect: R-L+(pi/2)S+R+\n\tflag, t, u, v = self.LRSL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"R\"]))\n\n\t# L+R-(pi/2)S-R-\n\tflag, t, u, v = self.LRSR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t# timefilp: L-R+(pi/2)S+R+\n\tflag, t, u, v = self.LRSR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"L\", \"R\", \"S\", \"R\"]))\n\n\t# reflect: R+L-(pi/2)S-L-\n\tflag, t, u, v = self.LRSR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t# timeflip + reflect: R-L+(pi/2)S+L+\n\tflag, t, u, v = self.LRSR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, -v], ctypes=[\"R\", \"L\", \"S\", \"L\"]))\n\n\t# backwards\n\txb = x * math.cos(phi) + y * math.sin(phi)\n\tyb = x * math.sin(phi) - y * math.cos(phi)\n\n\t# backwards: L-S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSL(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: L+S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSL(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + reflect: R-S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSL(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t# backwards + timefilp + reflect: R+S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSL(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"L\", \"R\"]))\n\n\t# backwards: R-S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSR(xb, yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + timefilp: R+S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSR(-xb, yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"R\", \"S\", \"R\", \"L\"]))\n\n\t# backwards + reflect: L-S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSR(xb, -yb, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[v, u, -0.5 * math.pi, t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\t# backwards + timefilp + reflect: L+S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSR(-xb, -yb, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-v, -u, 0.5 * math.pi, -t], ctypes=[\"L\", \"S\", \"L\", \"R\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCSCC","title":"<code>CCSCC(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CCSCC--4","title":"4","text":"<p>Circle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def CCSCC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 4\n\tCircle-Circle(pi/2)-Straight--Circle(pi/2)-Circle generation mode (using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+R-(pi/2)S-L-(pi/2)R+\n\tflag, t, u, v = self.LRSLR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t# timefilp: L-R+(pi/2)S+L+(pi/2)R-\n\tflag, t, u, v = self.LRSLR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"L\", \"R\", \"S\", \"L\", \"R\"]))\n\n\t# reflect: R+L-(pi/2)S-R-(pi/2)L+\n\tflag, t, u, v = self.LRSLR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, -0.5 * math.pi, u, -0.5 * math.pi, v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\t# timefilp + reflect: R-L+(pi/2)S+R+(pi/2)L-\n\tflag, t, u, v = self.LRSLR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, 0.5 * math.pi, -u, 0.5 * math.pi, -v], ctypes=[\"R\", \"L\", \"S\", \"R\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CSC","title":"<code>CSC(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.CSC--8","title":"8","text":"<p>Circle-Straight-Circle generation mode(using reflect, timeflip and backwards).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def CSC(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 8\n\tCircle-Straight-Circle generation mode(using reflect, timeflip and backwards).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\t# L+S+L+\n\tflag, t, u, v = self.LSL(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t# timefilp: L-S-L-\n\tflag, t, u, v = self.LSL(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"L\"]))\n\n\t# reflect: R+S+R+\n\tflag, t, u, v = self.LSL(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t# timeflip + reflect: R-S-R-\n\tflag, t, u, v = self.LSL(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"R\"]))\n\n\t# L+S+R+\n\tflag, t, u, v = self.LSR(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t# timefilp: L-S-R-\n\tflag, t, u, v = self.LSR(-x, y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"L\", \"S\", \"R\"]))\n\n\t# reflect: R+S+L+\n\tflag, t, u, v = self.LSR(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\t# timeflip + reflect: R+S+l-\n\tflag, t, u, v = self.LSR(-x, -y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[-t, -u, -v], ctypes=[\"R\", \"S\", \"L\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRL","title":"<code>LRL(x, y, phi)</code>","text":"<p>Left-Right-Left generation mode. (L+R-L-)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right-Left generation mode. (L+R-L-)\n\t\"\"\"\n\tr, theta = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\tif r &lt;= 4.0:\n\t\tu = -2.0 * math.asin(0.25 * r)\n\t\tt = self.M(theta + 0.5 * u + math.pi)\n\t\tv = self.M(phi - t + u)\n\n\t\tif t &gt;= 0.0 and u &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRLRn","title":"<code>LRLRn(x, y, phi)</code>","text":"<p>Left-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRLRn(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R+L-R-)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho = 0.25 * (2.0 + math.sqrt(xi * xi + eta * eta))\n\n\tif rho &lt;= 1.0:\n\t\tu = math.acos(rho)\n\t\tt, v = self._calTauOmega(u, -u, xi, eta, phi)\n\t\tif t &gt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRLRp","title":"<code>LRLRp(x, y, phi)</code>","text":"<p>Left-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRLRp(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(beta)-Left(beta)-Right generation mode. (L+R-L-R+)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho = (20.0 - xi * xi - eta * eta) / 16.0\n\n\tif 0.0 &lt;= rho &lt;= 1.0:\n\t\tu = -math.acos(rho)\n\t\tif u &gt;= -0.5 * math.pi:\n\t\t\tt, v = self._calTauOmega(u, u, xi, eta, phi)\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRSL","title":"<code>LRSL(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRSL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Left generation mode. (L+R-S-L-)\n\t\"\"\"\n\txi = x - math.sin(phi)\n\teta = y - 1.0 + math.cos(phi)\n\trho, theta = self.R(xi, eta)\n\n\tif rho &gt;= 2.0:\n\t\tr = math.sqrt(rho * rho - 4.0)\n\t\tu = 2.0 - r\n\t\tt = self.M(theta + math.atan2(r, -2.0))\n\t\tv = self.M(phi - 0.5 * math.pi - t)\n\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRSLR","title":"<code>LRSLR(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRSLR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Left(pi/2)-Right generation mode. (L+R-S-L-R+)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\tr, _ = self.R(xi, eta)\n\n\tif r &gt;= 2.0:\n\t\tu = 4.0 - math.sqrt(r * r - 4.0)\n\t\tif u &lt;= 0.0:\n\t\t\tt = self.M(math.atan2((4.0 - u) * xi - 2.0 * eta, -2.0 * xi + (u - 4.0) * eta))\n\t\t\tv = self.M(t - phi)\n\n\t\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LRSR","title":"<code>LRSR(x, y, phi)</code>","text":"<p>Left-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LRSR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Right(pi/2)-Straight-Right generation mode. (L+R-S-R-)\n\t\"\"\"\n\txi = x + math.sin(phi)\n\teta = y - 1.0 - math.cos(phi)\n\trho, theta = self.R(-eta, xi)\n\n\tif rho &gt;= 2.0:\n\t\tt = theta\n\t\tu = 2.0 - rho\n\t\tv = self.M(t + 0.5 * math.pi - phi)\n\t\tif t &gt;= 0.0 and u &lt;= 0.0 and v &lt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LSL","title":"<code>LSL(x, y, phi)</code>","text":"<p>Left-Straight-Left generation mode. (L+S+L+)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LSL(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Straight-Left generation mode. (L+S+L+)\n\t\"\"\"\n\tu, t = self.R(x - math.sin(phi), y - 1.0 + math.cos(phi))\n\n\tif t &gt;= 0.0:\n\t\tv = self.M(phi - t)\n\t\tif v &gt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.LSR","title":"<code>LSR(x, y, phi)</code>","text":"<p>Left-Straight-Right generation mode. (L+S+R+)</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def LSR(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tLeft-Straight-Right generation mode. (L+S+R+)\n\t\"\"\"\n\tr, theta = self.R(x + math.sin(phi), y - 1.0 - math.cos(phi))\n\tr = r ** 2\n\n\tif r &gt;= 4.0:\n\t\tu = math.sqrt(r - 4.0)\n\t\tt = self.M(theta + math.atan2(2.0, u))\n\t\tv = self.M(t - phi)\n\n\t\tif t &gt;= 0.0 and v &gt;= 0.0:\n\t\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.M","title":"<code>M(theta)</code>","text":"<p>Truncate the angle to the interval of -\u03c0 to \u03c0.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle value</p> required <p>Returns:</p> Name Type Description <code>theta</code> <code>float</code> <p>Truncated angle value</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def M(self, theta):\n\t\"\"\"\n\tTruncate the angle to the interval of -\u03c0 to \u03c0.\n\n\tParameters:\n\t\ttheta (float): Angle value\n\n\tReturns:\n\t\ttheta (float): Truncated angle value\n\t\"\"\"\n\treturn self.pi2pi(theta)\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.R","title":"<code>R(x, y)</code>","text":"<p>Return the polar coordinates (r, theta) of the point (x, y) i.e. rcos(theta) = x; rsin(theta) = y</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x-coordinate value</p> required <code>y</code> <code>float</code> <p>y-coordinate value</p> required <p>Returns:</p> Type Description <p>r, theta (float): Polar coordinates</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def R(self, x, y):\n\t\"\"\"\n\tReturn the polar coordinates (r, theta) of the point (x, y)\n\ti.e. rcos(theta) = x; rsin(theta) = y\n\n\tParameters:\n\t\tx (float): x-coordinate value\n\t\ty (float): y-coordinate value\n\n\tReturns:\n\t\tr, theta (float): Polar coordinates\n\n\t\"\"\"\n\tr = math.hypot(x, y)\n\ttheta = math.atan2(y, x)\n\n\treturn r, theta\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.SCS","title":"<code>SCS(x, y, phi)</code>","text":""},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.SCS--2","title":"2","text":"<p>Straight-Circle-Straight generation mode(using reflect).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x of goal position</p> required <code>y</code> <code>float</code> <p>y of goal position</p> required <code>phi</code> <code>float</code> <p>goal orientation</p> required <p>Returns:</p> Name Type Description <code>paths</code> <code>list</code> <p>Available paths</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def SCS(self, x: float, y: float, phi: float):\n\t\"\"\"\n\t# 2\n\tStraight-Circle-Straight generation mode(using reflect).\n\n\tParameters:\n\t\tx (float): x of goal position\n\t\ty (float): y of goal position\n\t\tphi (float): goal orientation\n\n\tReturns:\n\t\tpaths (list): Available paths\n\t\"\"\"\n\tpaths = []\n\n\tflag, t, u, v = self.SLS(x, y, phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"L\", \"S\"]))\n\n\tflag, t, u, v = self.SLS(x, -y, -phi)\n\tif flag:\n\t\tpaths.append(self.Path(lengths=[t, u, v], ctypes=[\"S\", \"R\", \"S\"]))\n\n\treturn paths\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.SLS","title":"<code>SLS(x, y, phi)</code>","text":"<p>Straight-Left-Straight generation mode.</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def SLS(self, x: float, y: float, phi: float):\n\t\"\"\"\n\tStraight-Left-Straight generation mode.\n\t\"\"\"\n\tphi = self.M(phi)\n\n\tif y &gt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\txd = -y / math.tan(phi) + x\n\t\tt = xd - math.tan(phi / 2.0)\n\t\tu = phi\n\t\tv = math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\treturn True, t, u, v\n\telif y &lt; 0.0 and 0.0 &lt; phi &lt; math.pi * 0.99:\n\t\txd = -y / math.tan(phi) + x\n\t\tt = xd - math.tan(phi / 2.0)\n\t\tu = phi\n\t\tv = -math.sqrt((x - xd) ** 2 + y ** 2) - math.tan(phi / 2.0)\n\t\treturn True, t, u, v\n\n\treturn False, 0.0, 0.0, 0.0\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.generation","title":"<code>generation(start_pose, goal_pose)</code>","text":"<p>Generate the Reeds Shepp Curve.</p> <p>Parameters:</p> Name Type Description Default <code>start_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <code>goal_pose</code> <code>tuple</code> <p>Target pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>best_cost</code> <code>float</code> <p>Best planning path length</p> <code>best_mode</code> <p>Best motion modes</p> <code>x_list</code> <code>list</code> <p>Trajectory of x</p> <code>y_list</code> <code>list</code> <p>Trajectory of y</p> <code>yaw_list</code> <code>list</code> <p>Trajectory of yaw</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def generation(self, start_pose: tuple, goal_pose: tuple):\n\t\"\"\"\n\tGenerate the Reeds Shepp Curve.\n\n\tParameters:\n\t\tstart_pose (tuple): Initial pose (x, y, yaw)\n\t\tgoal_pose (tuple): Target pose (x, y, yaw)\n\n\tReturns:\n\t\tbest_cost (float): Best planning path length\n\t\tbest_mode: Best motion modes\n\t\tx_list (list): Trajectory of x\n\t\ty_list (list): Trajectory of y\n\t\tyaw_list (list): Trajectory of yaw\n\t\"\"\"\n\tsx, sy, syaw = start_pose\n\tgx, gy, gyaw = goal_pose\n\n\t# coordinate transformation\n\tdx, dy, dyaw = gx - sx, gy - sy, gyaw - syaw\n\tx = (math.cos(syaw) * dx + math.sin(syaw) * dy) * self.max_curv\n\ty = (-math.sin(syaw) * dx + math.cos(syaw) * dy) * self.max_curv\n\n\t# select the best motion\n\tplanners = [self.SCS, self.CCC, self.CSC, self.CCCC, self.CCSC, self.CCSCC]\n\tbest_path, best_cost = None, float(\"inf\")\n\n\tfor planner in planners:\n\t\tpaths = planner(x, y, dyaw)\n\t\tfor path in paths:\n\t\t\tif path.path_length &lt; best_cost:\n\t\t\t\tbest_path, best_cost = path, path.path_length\n\n\t# interpolation\n\tpoints_num = int(best_cost / self.step) + len(best_path.lengths) + 3\n\tx_list = [0.0 for _ in range(points_num)]\n\ty_list = [0.0 for _ in range(points_num)]\n\tyaw_list = [0.0 for _ in range(points_num)]\n\n\ti = 0\n\tfor mode_, seg_length in zip(best_path.ctypes, best_path.lengths):\n\t\t# path increment\n\t\td_length = self.step if seg_length &gt; 0.0 else -self.step\n\t\tx, y, yaw = x_list[i], y_list[i], yaw_list[i]\n\t\t# current path length\n\t\tlength = d_length\n\t\twhile abs(length) &lt;= abs(seg_length):\n\t\t\ti += 1\n\t\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, length, (x, y, yaw))\n\t\t\tlength += d_length\n\t\ti += 1\n\t\tx_list[i], y_list[i], yaw_list[i] = self.interpolate(mode_, seg_length, (x, y, yaw))\n\n\t# failed\n\tif len(x_list) &lt;= 1:\n\t\treturn None, None, [], [], []\n\n\t# remove unused data\n\twhile len(x_list) &gt;= 1 and x_list[-1] == 0.0:\n\t\tx_list.pop()\n\t\ty_list.pop()\n\t\tyaw_list.pop()\n\n\t# coordinate transformation\n\tx_list_ = [math.cos(-syaw) * ix + math.sin(-syaw) * iy + sx for (ix, iy) in zip(x_list, y_list)]\n\ty_list_ = [-math.sin(-syaw) * ix + math.cos(-syaw) * iy + sy for (ix, iy) in zip(x_list, y_list)]\n\tyaw_list_ = [self.pi2pi(iyaw + syaw) for iyaw in yaw_list]\n\n\treturn best_cost / self.max_curv, best_path.ctypes, x_list_, y_list_, yaw_list_\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.interpolate","title":"<code>interpolate(mode, length, init_pose)</code>","text":"<p>Planning path interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>motion, e.g., L, S, R</p> required <code>length</code> <code>float</code> <p>Single step motion path length</p> required <code>init_pose</code> <code>tuple</code> <p>Initial pose (x, y, yaw)</p> required <p>Returns:</p> Name Type Description <code>new_pose</code> <code>tuple</code> <p>New pose (new_x, new_y, new_yaw) after moving</p> Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def interpolate(self, mode: str, length: float, init_pose: tuple):\n\t\"\"\"\n\tPlanning path interpolation.\n\n\tParameters:\n\t\tmode (str): motion, e.g., L, S, R\n\t\tlength (float): Single step motion path length\n\t\tinit_pose (tuple): Initial pose (x, y, yaw)\n\n\tReturns:\n\t\tnew_pose (tuple): New pose (new_x, new_y, new_yaw) after moving\n\t\"\"\"\n\tx, y, yaw = init_pose\n\n\tif mode == \"S\":\n\t\tnew_x = x + length / self.max_curv * math.cos(yaw)\n\t\tnew_y = y + length / self.max_curv * math.sin(yaw)\n\t\tnew_yaw = yaw\n\telif mode == \"L\":\n\t\tnew_x = x + (math.sin(yaw + length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y = y - (math.cos(yaw + length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw + length\n\telif mode == \"R\":\n\t\tnew_x = x - (math.sin(yaw - length) - math.sin(yaw)) / self.max_curv\n\t\tnew_y = y + (math.cos(yaw - length) - math.cos(yaw)) / self.max_curv\n\t\tnew_yaw = yaw - length\n\telse:\n\t\traise NotImplementedError\n\n\treturn new_x, new_y, new_yaw\n</code></pre>"},{"location":"curve_generation/reeds_shepp/ReedsShepp.html#src.python_motion_planning.curve_generation.reeds_shepp.ReedsShepp.run","title":"<code>run(points)</code>","text":"<p>Running both generation and animation.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[tuple]</code> <p>path points</p> required Source code in <code>src\\python_motion_planning\\curve_generation\\reeds_shepp.py</code> Python<pre><code>def run(self, points: list):\n\t\"\"\"\n\tRunning both generation and animation.\n\n\tParameters:\n\t\tpoints (list[tuple]): path points\n\t\"\"\"\n\tassert len(points) &gt;= 2, \"Number of points should be at least 2.\"\n\timport matplotlib.pyplot as plt\n\n\t# generation\n\tpath_x, path_y, path_yaw = [], [], []\n\tfor i in range(len(points) - 1):\n\t\t_, _, x_list, y_list, yaw_list = self.generation(\n\t\t\t(points[i][0], points[i][1], np.deg2rad(points[i][2])),\n\t\t\t(points[i + 1][0], points[i + 1][1], np.deg2rad(points[i + 1][2])))\n\n\t\tfor j in range(len(x_list)):\n\t\t\tpath_x.append(x_list[j])\n\t\t\tpath_y.append(y_list[j])\n\t\t\tpath_yaw.append(yaw_list[j])\n\n\t# animation\n\tplt.figure(\"curve generation\")\n\t# # static\n\t# plt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t# for x, y, theta in points:\n\t# \tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\n\t# dynamic\n\tplt.ion()\n\tfor i in range(len(path_x)):\n\t\tplt.clf()\n\t\tplt.gcf().canvas.mpl_connect('key_release_event',\n\t\t\t\t\t\t\t\t\t\tlambda event: [exit(0) if event.key == 'escape' else None])\n\t\tplt.plot(path_x, path_y, linewidth=2, c=\"#1f77b4\")\n\t\tfor x, y, theta in points:\n\t\t\tPlot.plotArrow(x, y, np.deg2rad(theta), 2, 'blueviolet')\n\t\tPlot.plotCar(path_x[i], path_y[i], path_yaw[i], 1.5, 3, \"black\")\n\t\tplt.axis(\"equal\")\n\t\tplt.title(str(self))\n\t\tplt.draw()\n\t\tplt.pause(0.001)\n\n\tplt.axis(\"equal\")\n\tplt.title(str(self))\n\tplt.show()\n</code></pre>"},{"location":"global_planner/evolutionary_search/aco/ACO.html","title":"ACO","text":""},{"location":"global_planner/evolutionary_search/aco/ACO.html#src.python_motion_planning.global_planner.evolutionary_search.aco.ACO","title":"<code>src.python_motion_planning.global_planner.evolutionary_search.aco.ACO</code>","text":"<p>               Bases: <code>EvolutionarySearcher</code></p> <p>Class for Ant Colony Optimization(ACO) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type, default is euclidean</p> <code>'euclidean'</code> <code>n_ants</code> <code>int</code> <p>number of ants</p> <code>50</code> <code>alpha</code> <code>float</code> <p>pheromone and heuristic factor weight coefficient</p> <code>1.0</code> <code>beta</code> <code>float</code> <p>pheromone and heuristic factor weight coefficient</p> <code>5.0</code> <code>rho</code> <code>float</code> <p>evaporation coefficient</p> <code>0.1</code> <code>Q</code> <code>float</code> <p>pheromone gain</p> <code>1.0</code> <code>max_iter</code> <code>int</code> <p>maximum iterations</p> <code>100</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.ACO((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, cost_list = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, cost_curve=cost_list)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Ant Colony Optimization: A New Meta-Heuristic</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\aco.py</code> Python<pre><code>class ACO(EvolutionarySearcher):\n    \"\"\"\n    Class for Ant Colony Optimization(ACO) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type, default is euclidean\n        n_ants (int): number of ants\n        alpha (float): pheromone and heuristic factor weight coefficient\n        beta (float): pheromone and heuristic factor weight coefficient\n        rho (float): evaporation coefficient\n        Q (float): pheromone gain\n        max_iter (int): maximum iterations\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.ACO((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, cost_list = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, cost_curve=cost_list)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Ant Colony Optimization: A New Meta-Heuristic\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", \n        n_ants: int = 50, alpha: float = 1.0, beta: float = 5.0, rho: float = 0.1, Q: float = 1.0,\n        max_iter: int = 100) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n        self.n_ants = n_ants\n        self.alpha = alpha\n        self.beta = beta\n        self.rho = rho\n        self.Q = Q\n        self.max_iter = max_iter\n\n    def __str__(self) -&gt; str:\n        return \"Ant Colony Optimization(ACO)\"\n\n    class Ant:\n        def __init__(self) -&gt; None:\n            self.reset()\n\n        def reset(self) -&gt; None:\n            self.found_goal = False\n            self.current_node = None\n            self.path = []\n            self.path_set = set()\n            self.steps = 0\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Ant Colony Optimization(ACO) motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n        \"\"\"\n        best_length_list, best_path = [], None\n\n        # pheromone initialization\n        pheromone_edges = {}\n        for i in range(self.env.x_range):\n            for j in range(self.env.y_range):\n                if (i, j) in self.obstacles:\n                    continue\n                cur_node = Node((i, j), (i, j), 0, 0)\n                for node_n in self.getNeighbor(cur_node):\n                    pheromone_edges[(cur_node, node_n)] = 1.0\n\n        # heuristically set max steps\n        max_steps = self.env.x_range * self.env.y_range / 2 + max(self.env.x_range, self.env.y_range)\n\n        # main loop\n        cost_list = []\n        for _ in range(self.max_iter):\n            ants_list = []\n            for _ in range(self.n_ants):\n                ant = self.Ant()\n                ant.current_node = self.start\n                while ant.current_node is not self.goal and ant.steps &lt; max_steps:\n                    ant.path.append(ant.current_node)\n                    ant.path_set.add(ant.current_node.current)\n\n                    # candidate\n                    prob_sum = 0.0\n                    next_positions, next_probabilities = [], []\n                    for node_n in self.getNeighbor(ant.current_node):                \n                        # existed\n                        if node_n.current in ant.path_set:\n                            continue\n\n                        node_n.parent = ant.current_node.current\n\n                        # goal found\n                        if node_n == self.goal:\n                            ant.path.append(node_n)\n                            ant.path_set.add(node_n.current)\n                            ant.found_goal = True\n                            break\n\n                        next_positions.append(node_n)\n                        prob_new = pheromone_edges[(ant.current_node, node_n)] ** self.alpha \\\n                                    * (1.0 / self.h(node_n, self.goal)) ** self.beta\n                        next_probabilities.append(prob_new)\n                        prob_sum = prob_sum + prob_new\n\n                    if prob_sum == 0 or ant.found_goal:\n                        break\n\n                    # roulette selection\n                    next_probabilities = list(map(lambda prob: prob / prob_sum, next_probabilities))\n                    p0, cp = 0, []\n                    for prob in next_probabilities:\n                        p0 = p0 + prob\n                        cp.append(p0)\n                    ant.current_node = next_positions[bisect_left(cp, random.random())]\n\n                    ant.steps = ant.steps + 1\n\n                ants_list.append(ant)\n\n            # pheromone deterioration\n            for key, _ in pheromone_edges.items():\n                pheromone_edges[key] *= (1 - self.rho)\n\n            # pheromone update based on successful ants\n            bpl, bp = float(\"inf\"), None\n            for ant in ants_list:\n                if ant.found_goal:\n                    if len(ant.path) &lt; bpl:\n                        bpl, bp = len(ant.path), ant.path\n                    c = self.Q / len(ant.path)\n                    for i in range(len(ant.path) - 1):\n                        pheromone_edges[(ant.path[i], ant.path[i + 1])] += c\n\n            if bpl &lt; float(\"inf\"):\n                best_length_list.append(bpl)\n\n            if len(best_length_list) &gt; 0:\n                cost_list.append(min(best_length_list))\n                if bpl &lt;= min(best_length_list):\n                    best_path = bp\n\n        if best_path:\n            cost = 0\n            path = [self.start.current]\n            for i in range(len(best_path) - 1):\n                cost += self.dist(best_path[i], best_path[i + 1])\n                path.append(best_path[i + 1].current)\n            return cost, path, cost_list\n        return [], [], []\n\n    def getNeighbor(self, node: Node) -&gt; list:\n        \"\"\"\n        Find neighbors of node.\n\n        Parameters:\n            node (Node): current node\n\n        Returns:\n            neighbors (list): neighbors of current node\n        \"\"\"\n        return [node + motion for motion in self.motions\n                if not self.isCollision(node, node + motion)]\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        cost, path, cost_list = self.plan()\n        self.plot.animation(path, str(self), cost, cost_curve=cost_list)\n</code></pre>"},{"location":"global_planner/evolutionary_search/aco/ACO.html#src.python_motion_planning.global_planner.evolutionary_search.aco.ACO.getNeighbor","title":"<code>getNeighbor(node)</code>","text":"<p>Find neighbors of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>neighbors</code> <code>list</code> <p>neighbors of current node</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\aco.py</code> Python<pre><code>def getNeighbor(self, node: Node) -&gt; list:\n    \"\"\"\n    Find neighbors of node.\n\n    Parameters:\n        node (Node): current node\n\n    Returns:\n        neighbors (list): neighbors of current node\n    \"\"\"\n    return [node + motion for motion in self.motions\n            if not self.isCollision(node, node + motion)]\n</code></pre>"},{"location":"global_planner/evolutionary_search/aco/ACO.html#src.python_motion_planning.global_planner.evolutionary_search.aco.ACO.plan","title":"<code>plan()</code>","text":"<p>Ant Colony Optimization(ACO) motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\aco.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Ant Colony Optimization(ACO) motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n    \"\"\"\n    best_length_list, best_path = [], None\n\n    # pheromone initialization\n    pheromone_edges = {}\n    for i in range(self.env.x_range):\n        for j in range(self.env.y_range):\n            if (i, j) in self.obstacles:\n                continue\n            cur_node = Node((i, j), (i, j), 0, 0)\n            for node_n in self.getNeighbor(cur_node):\n                pheromone_edges[(cur_node, node_n)] = 1.0\n\n    # heuristically set max steps\n    max_steps = self.env.x_range * self.env.y_range / 2 + max(self.env.x_range, self.env.y_range)\n\n    # main loop\n    cost_list = []\n    for _ in range(self.max_iter):\n        ants_list = []\n        for _ in range(self.n_ants):\n            ant = self.Ant()\n            ant.current_node = self.start\n            while ant.current_node is not self.goal and ant.steps &lt; max_steps:\n                ant.path.append(ant.current_node)\n                ant.path_set.add(ant.current_node.current)\n\n                # candidate\n                prob_sum = 0.0\n                next_positions, next_probabilities = [], []\n                for node_n in self.getNeighbor(ant.current_node):                \n                    # existed\n                    if node_n.current in ant.path_set:\n                        continue\n\n                    node_n.parent = ant.current_node.current\n\n                    # goal found\n                    if node_n == self.goal:\n                        ant.path.append(node_n)\n                        ant.path_set.add(node_n.current)\n                        ant.found_goal = True\n                        break\n\n                    next_positions.append(node_n)\n                    prob_new = pheromone_edges[(ant.current_node, node_n)] ** self.alpha \\\n                                * (1.0 / self.h(node_n, self.goal)) ** self.beta\n                    next_probabilities.append(prob_new)\n                    prob_sum = prob_sum + prob_new\n\n                if prob_sum == 0 or ant.found_goal:\n                    break\n\n                # roulette selection\n                next_probabilities = list(map(lambda prob: prob / prob_sum, next_probabilities))\n                p0, cp = 0, []\n                for prob in next_probabilities:\n                    p0 = p0 + prob\n                    cp.append(p0)\n                ant.current_node = next_positions[bisect_left(cp, random.random())]\n\n                ant.steps = ant.steps + 1\n\n            ants_list.append(ant)\n\n        # pheromone deterioration\n        for key, _ in pheromone_edges.items():\n            pheromone_edges[key] *= (1 - self.rho)\n\n        # pheromone update based on successful ants\n        bpl, bp = float(\"inf\"), None\n        for ant in ants_list:\n            if ant.found_goal:\n                if len(ant.path) &lt; bpl:\n                    bpl, bp = len(ant.path), ant.path\n                c = self.Q / len(ant.path)\n                for i in range(len(ant.path) - 1):\n                    pheromone_edges[(ant.path[i], ant.path[i + 1])] += c\n\n        if bpl &lt; float(\"inf\"):\n            best_length_list.append(bpl)\n\n        if len(best_length_list) &gt; 0:\n            cost_list.append(min(best_length_list))\n            if bpl &lt;= min(best_length_list):\n                best_path = bp\n\n    if best_path:\n        cost = 0\n        path = [self.start.current]\n        for i in range(len(best_path) - 1):\n            cost += self.dist(best_path[i], best_path[i + 1])\n            path.append(best_path[i + 1].current)\n        return cost, path, cost_list\n    return [], [], []\n</code></pre>"},{"location":"global_planner/evolutionary_search/aco/ACO.html#src.python_motion_planning.global_planner.evolutionary_search.aco.ACO.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\aco.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    cost, path, cost_list = self.plan()\n    self.plot.animation(path, str(self), cost, cost_curve=cost_list)\n</code></pre>"},{"location":"global_planner/evolutionary_search/evolutionary_search/EvolutionarySearcher.html","title":"EvolutionarySearcher","text":""},{"location":"global_planner/evolutionary_search/evolutionary_search/EvolutionarySearcher.html#src.python_motion_planning.global_planner.evolutionary_search.evolutionary_search.EvolutionarySearcher","title":"<code>src.python_motion_planning.global_planner.evolutionary_search.evolutionary_search.EvolutionarySearcher</code>","text":"<p>               Bases: <code>Planner</code></p> <p>Base class for planner based on evolutionary searching.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\evolutionary_search.py</code> Python<pre><code>class EvolutionarySearcher(Planner):\n    \"\"\"\n    Base class for planner based on evolutionary searching.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str=\"euclidean\") -&gt; None:\n        super().__init__(start, goal, env)\n        # heuristic type\n        self.heuristic_type = heuristic_type\n        # allowed motions\n        self.motions = self.env.motions\n        # obstacles\n        self.obstacles = self.env.obstacles\n\n    def h(self, node: Node, goal: Node) -&gt; float:\n        \"\"\"\n        Calculate heuristic.\n\n        Parameters:\n            node (Node): current node\n            goal (Node): goal node\n\n        Returns:\n            h (float): heuristic function value of node\n        \"\"\"\n        if self.heuristic_type == \"manhattan\":\n            return abs(goal.x - node.x) + abs(goal.y - node.y)\n        elif self.heuristic_type == \"euclidean\":\n            return math.hypot(goal.x - node.x, goal.y - node.y)\n\n    def cost(self, node1: Node, node2: Node) -&gt; float:\n        \"\"\"\n        Calculate cost for this motion.\n\n        Parameters:\n            node1 (Node): node 1\n            node2 (Node): node 2\n\n        Returns:\n            cost (float): cost of this motion\n        \"\"\"\n        if self.isCollision(node1, node2):\n            return float(\"inf\")\n        return self.dist(node1, node2)\n\n    def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2.\n\n        Parameters:\n            node1 (Node): node 1\n            node2 (Node): node 2\n\n        Returns:\n            collision (bool): True if collision exists else False\n        \"\"\"\n        if node1.current in self.obstacles or node2.current in self.obstacles:\n            return True\n\n        x1, y1 = node1.current\n        x2, y2 = node2.current\n\n        if x1 != x2 and y1 != y2:\n            if x2 - x1 == y1 - y2:\n                s1 = (min(x1, x2), min(y1, y2))\n                s2 = (max(x1, x2), max(y1, y2))\n            else:\n                s1 = (min(x1, x2), max(y1, y2))\n                s2 = (max(x1, x2), min(y1, y2))\n            if s1 in self.obstacles or s2 in self.obstacles:\n                return True\n        return False\n</code></pre>"},{"location":"global_planner/evolutionary_search/evolutionary_search/EvolutionarySearcher.html#src.python_motion_planning.global_planner.evolutionary_search.evolutionary_search.EvolutionarySearcher.cost","title":"<code>cost(node1, node2)</code>","text":"<p>Calculate cost for this motion.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>node 1</p> required <code>node2</code> <code>Node</code> <p>node 2</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>cost of this motion</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\evolutionary_search.py</code> Python<pre><code>def cost(self, node1: Node, node2: Node) -&gt; float:\n    \"\"\"\n    Calculate cost for this motion.\n\n    Parameters:\n        node1 (Node): node 1\n        node2 (Node): node 2\n\n    Returns:\n        cost (float): cost of this motion\n    \"\"\"\n    if self.isCollision(node1, node2):\n        return float(\"inf\")\n    return self.dist(node1, node2)\n</code></pre>"},{"location":"global_planner/evolutionary_search/evolutionary_search/EvolutionarySearcher.html#src.python_motion_planning.global_planner.evolutionary_search.evolutionary_search.EvolutionarySearcher.h","title":"<code>h(node, goal)</code>","text":"<p>Calculate heuristic.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <code>goal</code> <code>Node</code> <p>goal node</p> required <p>Returns:</p> Name Type Description <code>h</code> <code>float</code> <p>heuristic function value of node</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\evolutionary_search.py</code> Python<pre><code>def h(self, node: Node, goal: Node) -&gt; float:\n    \"\"\"\n    Calculate heuristic.\n\n    Parameters:\n        node (Node): current node\n        goal (Node): goal node\n\n    Returns:\n        h (float): heuristic function value of node\n    \"\"\"\n    if self.heuristic_type == \"manhattan\":\n        return abs(goal.x - node.x) + abs(goal.y - node.y)\n    elif self.heuristic_type == \"euclidean\":\n        return math.hypot(goal.x - node.x, goal.y - node.y)\n</code></pre>"},{"location":"global_planner/evolutionary_search/evolutionary_search/EvolutionarySearcher.html#src.python_motion_planning.global_planner.evolutionary_search.evolutionary_search.EvolutionarySearcher.isCollision","title":"<code>isCollision(node1, node2)</code>","text":"<p>Judge collision when moving from node1 to node2.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>node 1</p> required <code>node2</code> <code>Node</code> <p>node 2</p> required <p>Returns:</p> Name Type Description <code>collision</code> <code>bool</code> <p>True if collision exists else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\evolutionary_search.py</code> Python<pre><code>def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2.\n\n    Parameters:\n        node1 (Node): node 1\n        node2 (Node): node 2\n\n    Returns:\n        collision (bool): True if collision exists else False\n    \"\"\"\n    if node1.current in self.obstacles or node2.current in self.obstacles:\n        return True\n\n    x1, y1 = node1.current\n    x2, y2 = node2.current\n\n    if x1 != x2 and y1 != y2:\n        if x2 - x1 == y1 - y2:\n            s1 = (min(x1, x2), min(y1, y2))\n            s2 = (max(x1, x2), max(y1, y2))\n        else:\n            s1 = (min(x1, x2), max(y1, y2))\n            s2 = (max(x1, x2), min(y1, y2))\n        if s1 in self.obstacles or s2 in self.obstacles:\n            return True\n    return False\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html","title":"PSO","text":""},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO","title":"<code>src.python_motion_planning.global_planner.evolutionary_search.pso.PSO</code>","text":"<p>               Bases: <code>EvolutionarySearcher</code></p> <p>Class for Particle Swarm Optimization (PSO) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>n_particles</code> <code>int</code> <p>number of particles</p> <code>300</code> <code>w_inertial</code> <code>float</code> <p>inertial weight</p> <code>1.0</code> <code>w_cognitive</code> <code>float</code> <p>cognitive weight</p> <code>1.0</code> <code>w_social</code> <code>float</code> <p>social weight</p> <code>1.0</code> <code>point_num</code> <code>int</code> <p>number of position points contained in each particle</p> <code>5</code> <code>max_speed</code> <code>int</code> <p>The maximum velocity of particle motion</p> <code>6</code> <code>max_iter</code> <code>int</code> <p>maximum iterations</p> <code>200</code> <code>init_mode</code> <code>int</code> <p>Set the generation mode for the initial position points of the particle swarm</p> <code>GEN_MODE_RANDOM</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.PSO((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, fitness_history = planner.plan(verbose=True)     # planning results only\n&gt;&gt;&gt; cost_curve = [-f for f in fitness_history]\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, cost_curve=cost_curve)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>class PSO(EvolutionarySearcher):\n    \"\"\"\n    Class for Particle Swarm Optimization (PSO) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        n_particles (int): number of particles\n        w_inertial (float): inertial weight\n        w_cognitive (float): cognitive weight\n        w_social (float): social weight\n        point_num (int): number of position points contained in each particle\n        max_speed (int): The maximum velocity of particle motion\n        max_iter (int): maximum iterations\n        init_mode (int): Set the generation mode for the initial position points of the particle swarm\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.PSO((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, fitness_history = planner.plan(verbose=True)     # planning results only\n        &gt;&gt;&gt; cost_curve = [-f for f in fitness_history]\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, cost_curve=cost_curve)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", \n        n_particles: int = 300, point_num: int = 5, w_inertial: float = 1.0,\n        w_cognitive: float = 1.0, w_social: float = 1.0, max_speed: int = 6,\n        max_iter: int = 200, init_mode: int = GEN_MODE_RANDOM) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n        self.max_iter = max_iter\n        self.n_particles = n_particles\n        self.w_inertial = w_inertial\n        self.w_social = w_social\n        self.w_cognitive = w_cognitive\n        self.point_num = point_num\n        self.init_mode = init_mode\n        self.max_speed = max_speed\n\n        self.particles = []\n        self.inherited_particles = []\n        self.best_particle = self.Particle()\n        self.b_spline_gen = BSpline(step=0.01, k=4)\n\n    def __str__(self) -&gt; str:\n        return \"Particle Swarm Optimization (PSO)\"\n\n    class Particle:\n        def __init__(self) -&gt; None:\n            self.reset()\n\n        def reset(self):\n            self.position = []\n            self.velocity = []\n            self.fitness = -1\n            self.best_pos = []\n            self.best_fitness = -1\n\n    def plan(self, verbose: bool = False):\n        \"\"\"\n        Particle Swarm Optimization (PSO) motion plan function.\n\n        Parameters:\n            verbose (bool): print the best fitness value of each iteration\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n        \"\"\"\n        # Generate initial position of particle swarm\n        init_positions = self.initializePositions()\n\n        # Particle initialization\n        for i in range(self.n_particles):\n            # Calculate fitness\n            init_fitness = self.calFitnessValue(init_positions[i])\n\n            if i == 0 or init_fitness &gt; self.best_particle.fitness:\n                self.best_particle.fitness = init_fitness\n                self.best_particle.position = deepcopy(init_positions[i])\n\n            # Create and add particle objects to containers\n            p = self.Particle()\n            p.position = init_positions[i]\n            p.velocity = [(0, 0) for _ in range(self.point_num)]\n            p.best_pos = init_positions[i]\n            p.fitness = init_fitness\n            p.best_fitness = init_fitness\n            self.particles.append(p)\n\n        # Iterative optimization\n        fitness_history = []\n        for _ in range(self.max_iter):\n            for p in self.particles:\n                self.optimizeParticle(p)\n            fitness_history.append(self.best_particle.fitness)\n            if verbose:\n                print(f\"iteration {_}: best fitness = {self.best_particle.fitness}\")\n\n        # Generating Paths from Optimal Particles\n        points = [self.start.current] + self.best_particle.position + [self.goal.current]\n        points = sorted(set(points), key=points.index)\n        path = self.b_spline_gen.run(points, display=False)\n\n        return self.b_spline_gen.length(path), path, fitness_history\n\n    def initializePositions(self) -&gt; list:\n        \"\"\"\n        Generate n particles with pointNum_ positions each within the map range.\n\n        Returns:\n            init_positions (list): initial position sequence of particle swarm\n        \"\"\"\n        init_positions = []\n\n        # Calculate sequence direction\n        x_order = self.goal.x &gt; self.start.x\n        y_order = self.goal.y &gt; self.start.y\n\n        # circle generation\n        center_x, center_y, radius = None, None, None\n        if self.init_mode == GEN_MODE_CIRCLE:\n            # Calculate the center and the radius of the circle (midpoint between start and goal)\n            center_x = (self.start.x + self.goal.x) / 2\n            center_y = (self.start.y + self.goal.y) / 2\n            radius = 5 if self.dist(self.start, self.goal) / 2.0 &lt; 5 else self.dist(self.start, self.goal) / 2.0\n\n        # initialize n_particles positions\n        for _ in range(self.n_particles):\n            point_id, visited = 0, []\n            pts_x, pts_y = [], []\n            # Generate point_num_ unique coordinates\n            while point_id &lt; self.point_num:\n                if self.init_mode == GEN_MODE_RANDOM:\n                    pt_x = random.randint(self.start.x, self.goal.x)\n                    pt_y = random.randint(self.start.y, self.goal.y)\n                    pos_id = pt_x + self.env.x_range * pt_y\n                else:\n                    # Generate random angle in radians\n                    angle = random.random() * 2 * math.pi\n                    # Generate random distance from the center within the circle\n                    r = math.sqrt(random.random()) * radius\n                    # Convert polar coordinates to Cartesian coordinates\n                    pt_x = int(center_x + r * math.cos(angle))\n                    pt_y = int(center_y + r * math.sin(angle))\n                    # Check if the coordinates are within the map range\n                    if 0 &lt;= pt_x &lt; self.env.x_range and 0 &lt;= pt_y &lt; self.env.y_range:\n                        pos_id = pt_x + self.env.x_range * pt_y\n                    else:\n                        continue\n\n                # Check if the coordinates have already been used\n                if not pos_id in visited:\n                    point_id = point_id + 1\n                    visited.append(pos_id)\n                    pts_x.append(pt_x)\n                    pts_y.append(pt_y)\n\n            # sort\n            pts_x = sorted(pts_x, reverse=False) if x_order else sorted(pts_x, reverse=True)\n            pts_y = sorted(pts_y, reverse=False) if y_order else sorted(pts_y, reverse=True)\n\n            # Store elements from x and y in particle_positions\n            init_positions.append([(ix, iy) for (ix, iy) in zip(pts_x, pts_y)])\n\n        return init_positions\n\n    def calFitnessValue(self, position: list) -&gt; float:\n        \"\"\"\n        Calculate the value of fitness function.\n\n        Parameters:\n            position (list): control points calculated by PSO\n\n        Returns:\n            fitness (float): the value of fitness function\n        \"\"\"\n        points = [self.start.current] + position + [self.goal.current]\n        points = sorted(set(points), key=points.index)\n        try:\n            path = self.b_spline_gen.run(points, display=False)\n        except:\n            return float(\"inf\")\n\n        # collision detection\n        obs_cost = 0\n        for i in range(len(path) - 1):\n            p1 = (round(path[i][0]), round(path[i][1]))\n            p2 = (round(path[i+1][0]), round(path[i+1][1]))\n            if self.isCollision(p1, p2):\n                obs_cost = obs_cost + 1\n\n        # Calculate particle fitness\n        return 100000.0 / (self.b_spline_gen.length(path) + 50000 * obs_cost)\n\n    def updateParticleVelocity(self, particle):\n        \"\"\"\n        A function to update the particle velocity\n\n        Parameters:\n            particle (Particle): the particle\n        \"\"\"\n        # update Velocity\n        for i in range(self.point_num):\n            rand1, rand2 = random.random(), random.random()\n            vx, vy = particle.velocity[i]\n            px, py = particle.position[i]\n            vx_new = self.w_inertial * vx + self.w_cognitive * rand1 * (particle.best_pos[i][0] - px) \\\n                + self.w_social * rand2 * (self.best_particle.position[i][0] - px)\n\n            vy_new = self.w_inertial * vy + self.w_cognitive * rand1 * (particle.best_pos[i][1] - py) \\\n                + self.w_social * rand2 * (self.best_particle.position[i][1] - py)\n\n            # Velocity Scaling\n            if self.env.x_range &gt; self.env.y_range:\n                vx_new *= self.env.x_range / self.env.y_range\n            else:\n                vy_new *= self.env.y_range / self.env.x_range\n\n            # Velocity limit\n            vx_new = MathHelper.clamp(vx_new, -self.max_speed, self.max_speed)\n            vy_new = MathHelper.clamp(vy_new, -self.max_speed, self.max_speed)\n            particle.velocity[i] = (vx_new, vy_new)\n\n    def updateParticlePosition(self, particle):\n        \"\"\"\n        A function to update the particle position\n\n        Parameters:\n            particle (Particle): the particle\n        \"\"\"\n        # update Position\n        for i in range(self.point_num):\n            px = particle.position[i][0] + int(particle.velocity[i][0])\n            py = particle.position[i][1] + int(particle.velocity[i][1])\n\n            # Position limit\n            px = MathHelper.clamp(px, 0, self.env.x_range - 1)\n            py = MathHelper.clamp(py, 0, self.env.y_range - 1)\n\n            particle.position[i] = (px, py)\n        particle.position.sort(key=lambda p: p[0])\n\n    def optimizeParticle(self, particle):\n        \"\"\"\n        Particle update optimization iteration\n\n        Parameters:\n            particle (Particle): the particle\n        \"\"\"\n        # update speed\n        self.updateParticleVelocity(particle)\n        # update position\n        self.updateParticlePosition(particle)\n\n        # Calculate fitness\n        particle.fitness = self.calFitnessValue(particle.position)\n\n        # Update individual optima\n        if particle.fitness &gt; particle.best_fitness:\n            particle.best_fitness = particle.fitness\n            particle.best_pos = particle.position\n\n        # Update global optimal particles\n        if particle.best_fitness &gt; self.best_particle.fitness:\n            self.best_particle.fitness = particle.best_fitness\n            self.best_particle.position = deepcopy(particle.position)\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        cost, path, fitness_history = self.plan(verbose=True)\n        cost_curve = [-f for f in fitness_history]\n        self.plot.animation(path, str(self), cost, cost_curve=cost_curve)\n\n    def isCollision(self, p1: tuple, p2: tuple) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2 using Bresenham.\n\n        Parameters:\n            p1 (tuple): start point\n            p2 (tuple): end point\n\n        Returns:\n            collision (bool): True if collision exists, False otherwise.\n        \"\"\"\n        if p1 in self.obstacles or p2 in self.obstacles:\n            return True\n\n        x1, y1 = p1\n        x2, y2 = p2\n\n        if x1 &lt; 0 or x1 &gt;= self.env.x_range or y1 &lt; 0 or y1 &gt;= self.env.y_range:\n            return True\n        if x2 &lt; 0 or x2 &gt;= self.env.x_range or y2 &lt; 0 or y2 &gt;= self.env.y_range:\n            return True\n\n        d_x = abs(x2 - x1)\n        d_y = abs(y2 - y1)\n        s_x = 0 if (x2 - x1) == 0 else (x2 - x1) / d_x\n        s_y = 0 if (y2 - y1) == 0 else (y2 - y1) / d_y\n        x, y, e = x1, y1, 0\n\n        # check if any obstacle exists between node1 and node2\n        if d_x &gt; d_y:\n            tau = (d_y - d_x) / 2\n            while not x == x2:\n                if e &gt; tau:\n                    x = x + s_x\n                    e = e - d_y\n                elif e &lt; tau:\n                    y = y + s_y\n                    e = e + d_x\n                else:\n                    x = x + s_x\n                    y = y + s_y\n                    e = e + d_x - d_y\n                if (x, y) in self.obstacles:\n                    return True\n        # swap x and y\n        else:\n            tau = (d_x - d_y) / 2\n            while not y == y2:\n                if e &gt; tau:\n                    y = y + s_y\n                    e = e - d_x\n                elif e &lt; tau:\n                    x = x + s_x\n                    e = e + d_y\n                else:\n                    x = x + s_x\n                    y = y + s_y\n                    e = e + d_y - d_x\n                if (x, y) in self.obstacles:\n                    return True\n\n        return False\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.calFitnessValue","title":"<code>calFitnessValue(position)</code>","text":"<p>Calculate the value of fitness function.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>list</code> <p>control points calculated by PSO</p> required <p>Returns:</p> Name Type Description <code>fitness</code> <code>float</code> <p>the value of fitness function</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def calFitnessValue(self, position: list) -&gt; float:\n    \"\"\"\n    Calculate the value of fitness function.\n\n    Parameters:\n        position (list): control points calculated by PSO\n\n    Returns:\n        fitness (float): the value of fitness function\n    \"\"\"\n    points = [self.start.current] + position + [self.goal.current]\n    points = sorted(set(points), key=points.index)\n    try:\n        path = self.b_spline_gen.run(points, display=False)\n    except:\n        return float(\"inf\")\n\n    # collision detection\n    obs_cost = 0\n    for i in range(len(path) - 1):\n        p1 = (round(path[i][0]), round(path[i][1]))\n        p2 = (round(path[i+1][0]), round(path[i+1][1]))\n        if self.isCollision(p1, p2):\n            obs_cost = obs_cost + 1\n\n    # Calculate particle fitness\n    return 100000.0 / (self.b_spline_gen.length(path) + 50000 * obs_cost)\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.initializePositions","title":"<code>initializePositions()</code>","text":"<p>Generate n particles with pointNum_ positions each within the map range.</p> <p>Returns:</p> Name Type Description <code>init_positions</code> <code>list</code> <p>initial position sequence of particle swarm</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def initializePositions(self) -&gt; list:\n    \"\"\"\n    Generate n particles with pointNum_ positions each within the map range.\n\n    Returns:\n        init_positions (list): initial position sequence of particle swarm\n    \"\"\"\n    init_positions = []\n\n    # Calculate sequence direction\n    x_order = self.goal.x &gt; self.start.x\n    y_order = self.goal.y &gt; self.start.y\n\n    # circle generation\n    center_x, center_y, radius = None, None, None\n    if self.init_mode == GEN_MODE_CIRCLE:\n        # Calculate the center and the radius of the circle (midpoint between start and goal)\n        center_x = (self.start.x + self.goal.x) / 2\n        center_y = (self.start.y + self.goal.y) / 2\n        radius = 5 if self.dist(self.start, self.goal) / 2.0 &lt; 5 else self.dist(self.start, self.goal) / 2.0\n\n    # initialize n_particles positions\n    for _ in range(self.n_particles):\n        point_id, visited = 0, []\n        pts_x, pts_y = [], []\n        # Generate point_num_ unique coordinates\n        while point_id &lt; self.point_num:\n            if self.init_mode == GEN_MODE_RANDOM:\n                pt_x = random.randint(self.start.x, self.goal.x)\n                pt_y = random.randint(self.start.y, self.goal.y)\n                pos_id = pt_x + self.env.x_range * pt_y\n            else:\n                # Generate random angle in radians\n                angle = random.random() * 2 * math.pi\n                # Generate random distance from the center within the circle\n                r = math.sqrt(random.random()) * radius\n                # Convert polar coordinates to Cartesian coordinates\n                pt_x = int(center_x + r * math.cos(angle))\n                pt_y = int(center_y + r * math.sin(angle))\n                # Check if the coordinates are within the map range\n                if 0 &lt;= pt_x &lt; self.env.x_range and 0 &lt;= pt_y &lt; self.env.y_range:\n                    pos_id = pt_x + self.env.x_range * pt_y\n                else:\n                    continue\n\n            # Check if the coordinates have already been used\n            if not pos_id in visited:\n                point_id = point_id + 1\n                visited.append(pos_id)\n                pts_x.append(pt_x)\n                pts_y.append(pt_y)\n\n        # sort\n        pts_x = sorted(pts_x, reverse=False) if x_order else sorted(pts_x, reverse=True)\n        pts_y = sorted(pts_y, reverse=False) if y_order else sorted(pts_y, reverse=True)\n\n        # Store elements from x and y in particle_positions\n        init_positions.append([(ix, iy) for (ix, iy) in zip(pts_x, pts_y)])\n\n    return init_positions\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.isCollision","title":"<code>isCollision(p1, p2)</code>","text":"<p>Judge collision when moving from node1 to node2 using Bresenham.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>tuple</code> <p>start point</p> required <code>p2</code> <code>tuple</code> <p>end point</p> required <p>Returns:</p> Name Type Description <code>collision</code> <code>bool</code> <p>True if collision exists, False otherwise.</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def isCollision(self, p1: tuple, p2: tuple) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2 using Bresenham.\n\n    Parameters:\n        p1 (tuple): start point\n        p2 (tuple): end point\n\n    Returns:\n        collision (bool): True if collision exists, False otherwise.\n    \"\"\"\n    if p1 in self.obstacles or p2 in self.obstacles:\n        return True\n\n    x1, y1 = p1\n    x2, y2 = p2\n\n    if x1 &lt; 0 or x1 &gt;= self.env.x_range or y1 &lt; 0 or y1 &gt;= self.env.y_range:\n        return True\n    if x2 &lt; 0 or x2 &gt;= self.env.x_range or y2 &lt; 0 or y2 &gt;= self.env.y_range:\n        return True\n\n    d_x = abs(x2 - x1)\n    d_y = abs(y2 - y1)\n    s_x = 0 if (x2 - x1) == 0 else (x2 - x1) / d_x\n    s_y = 0 if (y2 - y1) == 0 else (y2 - y1) / d_y\n    x, y, e = x1, y1, 0\n\n    # check if any obstacle exists between node1 and node2\n    if d_x &gt; d_y:\n        tau = (d_y - d_x) / 2\n        while not x == x2:\n            if e &gt; tau:\n                x = x + s_x\n                e = e - d_y\n            elif e &lt; tau:\n                y = y + s_y\n                e = e + d_x\n            else:\n                x = x + s_x\n                y = y + s_y\n                e = e + d_x - d_y\n            if (x, y) in self.obstacles:\n                return True\n    # swap x and y\n    else:\n        tau = (d_x - d_y) / 2\n        while not y == y2:\n            if e &gt; tau:\n                y = y + s_y\n                e = e - d_x\n            elif e &lt; tau:\n                x = x + s_x\n                e = e + d_y\n            else:\n                x = x + s_x\n                y = y + s_y\n                e = e + d_y - d_x\n            if (x, y) in self.obstacles:\n                return True\n\n    return False\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.optimizeParticle","title":"<code>optimizeParticle(particle)</code>","text":"<p>Particle update optimization iteration</p> <p>Parameters:</p> Name Type Description Default <code>particle</code> <code>Particle</code> <p>the particle</p> required Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def optimizeParticle(self, particle):\n    \"\"\"\n    Particle update optimization iteration\n\n    Parameters:\n        particle (Particle): the particle\n    \"\"\"\n    # update speed\n    self.updateParticleVelocity(particle)\n    # update position\n    self.updateParticlePosition(particle)\n\n    # Calculate fitness\n    particle.fitness = self.calFitnessValue(particle.position)\n\n    # Update individual optima\n    if particle.fitness &gt; particle.best_fitness:\n        particle.best_fitness = particle.fitness\n        particle.best_pos = particle.position\n\n    # Update global optimal particles\n    if particle.best_fitness &gt; self.best_particle.fitness:\n        self.best_particle.fitness = particle.best_fitness\n        self.best_particle.position = deepcopy(particle.position)\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.plan","title":"<code>plan(verbose=False)</code>","text":"<p>Particle Swarm Optimization (PSO) motion plan function.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>print the best fitness value of each iteration</p> <code>False</code> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def plan(self, verbose: bool = False):\n    \"\"\"\n    Particle Swarm Optimization (PSO) motion plan function.\n\n    Parameters:\n        verbose (bool): print the best fitness value of each iteration\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n    \"\"\"\n    # Generate initial position of particle swarm\n    init_positions = self.initializePositions()\n\n    # Particle initialization\n    for i in range(self.n_particles):\n        # Calculate fitness\n        init_fitness = self.calFitnessValue(init_positions[i])\n\n        if i == 0 or init_fitness &gt; self.best_particle.fitness:\n            self.best_particle.fitness = init_fitness\n            self.best_particle.position = deepcopy(init_positions[i])\n\n        # Create and add particle objects to containers\n        p = self.Particle()\n        p.position = init_positions[i]\n        p.velocity = [(0, 0) for _ in range(self.point_num)]\n        p.best_pos = init_positions[i]\n        p.fitness = init_fitness\n        p.best_fitness = init_fitness\n        self.particles.append(p)\n\n    # Iterative optimization\n    fitness_history = []\n    for _ in range(self.max_iter):\n        for p in self.particles:\n            self.optimizeParticle(p)\n        fitness_history.append(self.best_particle.fitness)\n        if verbose:\n            print(f\"iteration {_}: best fitness = {self.best_particle.fitness}\")\n\n    # Generating Paths from Optimal Particles\n    points = [self.start.current] + self.best_particle.position + [self.goal.current]\n    points = sorted(set(points), key=points.index)\n    path = self.b_spline_gen.run(points, display=False)\n\n    return self.b_spline_gen.length(path), path, fitness_history\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    cost, path, fitness_history = self.plan(verbose=True)\n    cost_curve = [-f for f in fitness_history]\n    self.plot.animation(path, str(self), cost, cost_curve=cost_curve)\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.updateParticlePosition","title":"<code>updateParticlePosition(particle)</code>","text":"<p>A function to update the particle position</p> <p>Parameters:</p> Name Type Description Default <code>particle</code> <code>Particle</code> <p>the particle</p> required Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def updateParticlePosition(self, particle):\n    \"\"\"\n    A function to update the particle position\n\n    Parameters:\n        particle (Particle): the particle\n    \"\"\"\n    # update Position\n    for i in range(self.point_num):\n        px = particle.position[i][0] + int(particle.velocity[i][0])\n        py = particle.position[i][1] + int(particle.velocity[i][1])\n\n        # Position limit\n        px = MathHelper.clamp(px, 0, self.env.x_range - 1)\n        py = MathHelper.clamp(py, 0, self.env.y_range - 1)\n\n        particle.position[i] = (px, py)\n    particle.position.sort(key=lambda p: p[0])\n</code></pre>"},{"location":"global_planner/evolutionary_search/pso/PSO.html#src.python_motion_planning.global_planner.evolutionary_search.pso.PSO.updateParticleVelocity","title":"<code>updateParticleVelocity(particle)</code>","text":"<p>A function to update the particle velocity</p> <p>Parameters:</p> Name Type Description Default <code>particle</code> <code>Particle</code> <p>the particle</p> required Source code in <code>src\\python_motion_planning\\global_planner\\evolutionary_search\\pso.py</code> Python<pre><code>def updateParticleVelocity(self, particle):\n    \"\"\"\n    A function to update the particle velocity\n\n    Parameters:\n        particle (Particle): the particle\n    \"\"\"\n    # update Velocity\n    for i in range(self.point_num):\n        rand1, rand2 = random.random(), random.random()\n        vx, vy = particle.velocity[i]\n        px, py = particle.position[i]\n        vx_new = self.w_inertial * vx + self.w_cognitive * rand1 * (particle.best_pos[i][0] - px) \\\n            + self.w_social * rand2 * (self.best_particle.position[i][0] - px)\n\n        vy_new = self.w_inertial * vy + self.w_cognitive * rand1 * (particle.best_pos[i][1] - py) \\\n            + self.w_social * rand2 * (self.best_particle.position[i][1] - py)\n\n        # Velocity Scaling\n        if self.env.x_range &gt; self.env.y_range:\n            vx_new *= self.env.x_range / self.env.y_range\n        else:\n            vy_new *= self.env.y_range / self.env.x_range\n\n        # Velocity limit\n        vx_new = MathHelper.clamp(vx_new, -self.max_speed, self.max_speed)\n        vy_new = MathHelper.clamp(vy_new, -self.max_speed, self.max_speed)\n        particle.velocity[i] = (vx_new, vy_new)\n</code></pre>"},{"location":"global_planner/graph_search/a_star/AStar.html","title":"AStar","text":""},{"location":"global_planner/graph_search/a_star/AStar.html#src.python_motion_planning.global_planner.graph_search.a_star.AStar","title":"<code>src.python_motion_planning.global_planner.graph_search.a_star.AStar</code>","text":"<p>               Bases: <code>GraphSearcher</code></p> <p>Class for A* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.AStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] A Formal Basis for the heuristic Determination of Minimum Cost Paths</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\a_star.py</code> Python<pre><code>class AStar(GraphSearcher):\n    \"\"\"\n    Class for A* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.AStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] A Formal Basis for the heuristic Determination of Minimum Cost Paths\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"A*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        A* motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): all nodes that planner has searched\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):                \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                node_n.parent = node.current\n                node_n.h = self.h(node_n, self.goal)\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n\n    def getNeighbor(self, node: Node) -&gt; list:\n        \"\"\"\n        Find neighbors of node.\n\n        Parameters:\n            node (Node): current node\n\n        Returns:\n            neighbors (list): neighbors of current node\n        \"\"\"\n        return [node + motion for motion in self.motions\n                if not self.isCollision(node, node + motion)]\n\n    def extractPath(self, closed_list: dict) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED list.\n\n        Parameters:\n            closed_list (dict): CLOSED list\n\n        Returns:\n            cost (float): the cost of planned path\n            path (list): the planning path\n        \"\"\"\n        cost = 0\n        node = closed_list[self.goal.current]\n        path = [node.current]\n        while node != self.start:\n            node_parent = closed_list[node.parent]\n            cost += self.dist(node, node_parent)\n            node = node_parent\n            path.append(node.current)\n        return cost, path\n\n    def run(self):\n        \"\"\"\n        Running both planning and animation.\n        \"\"\"\n        cost, path, expand = self.plan()\n        self.plot.animation(path, str(self), cost, expand)\n</code></pre>"},{"location":"global_planner/graph_search/a_star/AStar.html#src.python_motion_planning.global_planner.graph_search.a_star.AStar.extractPath","title":"<code>extractPath(closed_list)</code>","text":"<p>Extract the path based on the CLOSED list.</p> <p>Parameters:</p> Name Type Description Default <code>closed_list</code> <code>dict</code> <p>CLOSED list</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planned path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\a_star.py</code> Python<pre><code>def extractPath(self, closed_list: dict) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED list.\n\n    Parameters:\n        closed_list (dict): CLOSED list\n\n    Returns:\n        cost (float): the cost of planned path\n        path (list): the planning path\n    \"\"\"\n    cost = 0\n    node = closed_list[self.goal.current]\n    path = [node.current]\n    while node != self.start:\n        node_parent = closed_list[node.parent]\n        cost += self.dist(node, node_parent)\n        node = node_parent\n        path.append(node.current)\n    return cost, path\n</code></pre>"},{"location":"global_planner/graph_search/a_star/AStar.html#src.python_motion_planning.global_planner.graph_search.a_star.AStar.getNeighbor","title":"<code>getNeighbor(node)</code>","text":"<p>Find neighbors of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>neighbors</code> <code>list</code> <p>neighbors of current node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\a_star.py</code> Python<pre><code>def getNeighbor(self, node: Node) -&gt; list:\n    \"\"\"\n    Find neighbors of node.\n\n    Parameters:\n        node (Node): current node\n\n    Returns:\n        neighbors (list): neighbors of current node\n    \"\"\"\n    return [node + motion for motion in self.motions\n            if not self.isCollision(node, node + motion)]\n</code></pre>"},{"location":"global_planner/graph_search/a_star/AStar.html#src.python_motion_planning.global_planner.graph_search.a_star.AStar.plan","title":"<code>plan()</code>","text":"<p>A* motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>all nodes that planner has searched</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\a_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    A* motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): all nodes that planner has searched\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):                \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            node_n.parent = node.current\n            node_n.h = self.h(node_n, self.goal)\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/a_star/AStar.html#src.python_motion_planning.global_planner.graph_search.a_star.AStar.run","title":"<code>run()</code>","text":"<p>Running both planning and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\a_star.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both planning and animation.\n    \"\"\"\n    cost, path, expand = self.plan()\n    self.plot.animation(path, str(self), cost, expand)\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DNode.html","title":"DNode","text":""},{"location":"global_planner/graph_search/d_star/DNode.html#src.python_motion_planning.global_planner.graph_search.d_star.DNode","title":"<code>src.python_motion_planning.global_planner.graph_search.d_star.DNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Class for D* nodes.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>tuple</code> <p>current coordinate</p> required <code>parent</code> <code>tuple</code> <p>coordinate of parent node</p> required <code>t</code> <code>str</code> <p>state of node, including <code>NEW</code> <code>OPEN</code> and <code>CLOSED</code></p> required <code>h</code> <code>float</code> <p>cost from goal to current node</p> required <code>k</code> <code>float</code> <p>minimum cost from goal to current node in history</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>class DNode(Node):\n    \"\"\"\n    Class for D* nodes.\n\n    Parameters:\n        current (tuple): current coordinate\n        parent (tuple): coordinate of parent node\n        t (str): state of node, including `NEW` `OPEN` and `CLOSED`\n        h (float): cost from goal to current node\n        k (float): minimum cost from goal to current node in history\n    \"\"\"\n    def __init__(self, current: tuple, parent: tuple, t: str, h: float, k: float) -&gt; None:\n        self.current = current\n        self.parent = parent\n        self.t = t\n        self.h = h\n        self.k = k\n\n    def __add__(self, node):\n        return DNode((self.x + node.x, self.y + node.y), \n                     self.parent, self.t, self.h + node.h, self.k)\n\n    def __str__(self) -&gt; str:\n        return \"----------\\ncurrent:{}\\nparent:{}\\nt:{}\\nh:{}\\nk:{}\\n----------\" \\\n            .format(self.current, self.parent, self.t, self.h, self.k)\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html","title":"DStar","text":""},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar","title":"<code>src.python_motion_planning.global_planner.graph_search.d_star.DStar</code>","text":"<p>               Bases: <code>GraphSearcher</code></p> <p>Class for D* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.DStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1]Optimal and Efficient Path Planning for Partially-Known Environments</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>class DStar(GraphSearcher):\n    \"\"\"\n    Class for D* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.DStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1]Optimal and Efficient Path Planning for Partially-Known Environments\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env) -&gt; None:\n        super().__init__(start, goal, env, None)\n        self.start = DNode(start, None, 'NEW', float('inf'), float(\"inf\"))\n        self.goal = DNode(goal, None, 'NEW', 0, float('inf'))\n        # allowed motions\n        self.motions = [DNode(motion.current, None, None, motion.g, 0) for motion in self.env.motions]\n        # OPEN list and EXPAND list\n        self.OPEN = []\n        self.EXPAND = []\n        # record history infomation of map grids\n        self.map = {s: DNode(s, None, 'NEW', float(\"inf\"), float(\"inf\")) for s in self.env.grid_map}\n        self.map[self.goal.current] = self.goal\n        self.map[self.start.current] = self.start\n        # intialize OPEN list\n        self.insert(self.goal, 0)\n\n    def __str__(self) -&gt; str:\n        return \"Dynamic A*(D*)\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        D* static motion planning function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            _ (None): None\n        \"\"\"\n        while True:\n            self.processState()\n            if self.start.t == 'CLOSED':\n                break\n        cost, path = self.extractPath(self.map)\n        return cost, path, None\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        # static planning\n        cost, path, _ = self.plan()\n\n        # animation\n        self.plot.connect('button_press_event', self.OnPress)\n        self.plot.animation(path, str(self), cost=cost)\n\n    def OnPress(self, event) -&gt; None:\n        \"\"\"\n        Mouse button callback function.\n\n        Parameters:\n            event (MouseEvent): mouse event\n        \"\"\"\n        x, y = int(event.xdata), int(event.ydata)\n        if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n            print(\"Please choose right area!\")\n        else:\n            if (x, y) not in self.obstacles:\n                print(\"Add obstacle at: ({}, {})\".format(x, y))\n                # update obstacles\n                self.obstacles.add((x, y))\n                self.env.update(self.obstacles)\n\n                # move from start to goal, replan locally when meeting collisions\n                node = self.start\n                self.EXPAND, path, cost = [], [], 0\n                while node != self.goal:\n                    node_parent = self.map[node.parent]\n                    if self.isCollision(node, node_parent):\n                        self.modify(node, node_parent)\n                        continue\n                    path.append(node.current)\n                    cost += self.cost(node, node_parent)\n                    node = node_parent\n\n                self.plot.clean()\n                self.plot.animation(path, str(self), cost, self.EXPAND)\n\n            self.plot.update()\n\n    def extractPath(self, closed_list: dict) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED list.\n\n        Parameters:\n            closed_list (dict): CLOSED list\n\n        Returns:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        cost = 0\n        node = self.start\n        path = [node.current]\n        while node != self.goal:\n            node_parent = closed_list[node.parent]\n            cost += self.cost(node, node_parent)\n            node = node_parent\n            path.append(node.current)\n\n        return cost, path\n\n    def processState(self) -&gt; float:\n        \"\"\"\n        Broadcast dynamic obstacle information.\n\n        Returns:\n            min_k (float): minimum k value of map\n        \"\"\"\n        # get node in OPEN list with min k value\n        node = self.min_state\n        self.EXPAND.append(node)\n\n        if node is None:\n            return -1\n\n        # record the min k value of this iteration\n        k_old = self.min_k\n        # move node from OPEN list to CLOSED list\n        self.delete(node)  \n\n        # k_min &lt; h[x] --&gt; x: RAISE state (try to reduce k value by neighbor)\n        if k_old &lt; node.h:\n            for node_n in self.getNeighbor(node):\n                if node_n.h &lt;= k_old and node.h &gt; node_n.h + self.cost(node, node_n):\n                    # update h_value and choose parent\n                    node.parent = node_n.current\n                    node.h = node_n.h + self.cost(node, node_n)\n\n        # k_min &gt;= h[x] -- &gt; x: LOWER state (cost reductions)\n        if k_old == node.h:\n            for node_n in self.getNeighbor(node):\n                if node_n.t == 'NEW' or \\\n                    (node_n.parent == node.current and node_n.h != node.h + self.cost(node, node_n)) or \\\n                    (node_n.parent != node.current and node_n.h &gt; node.h + self.cost(node, node_n)):\n                    # Condition:\n                    # 1) t[node_n] == 'NEW': not visited\n                    # 2) node_n's parent: cost reduction\n                    # 3) node_n find a better parent\n                    node_n.parent = node.current\n                    self.insert(node_n, node.h + self.cost(node, node_n))\n        else:\n            for node_n in self.getNeighbor(node):\n                if node_n.t == 'NEW' or \\\n                    (node_n.parent == node.current and node_n.h != node.h + self.cost(node, node_n)):\n                    # Condition:\n                    # 1) t[node_n] == 'NEW': not visited\n                    # 2) node_n's parent: cost reduction\n                    node_n.parent = node.current\n                    self.insert(node_n, node.h + self.cost(node, node_n))\n                else:\n                    if node_n.parent != node.current and \\\n                        node_n.h &gt; node.h + self.cost(node, node_n):\n                        # Condition: LOWER happened in OPEN list (s), s should be explored again\n                        self.insert(node, node.h)\n                    else:\n                        if node_n.parent != node.current and \\\n                            node.h &gt; node_n.h + self.cost(node, node_n) and \\\n                            node_n.t == 'CLOSED' and \\\n                            node_n.h &gt; k_old:\n                            # Condition: LOWER happened in CLOSED list (s_n), s_n should be explored again\n                            self.insert(node_n, node_n.h)\n        return self.min_k\n\n    @property\n    def min_state(self) -&gt; DNode:\n        \"\"\"\n        Choose the node with the minimum k value in OPEN list.\n        \"\"\"\n        if not self.OPEN:\n            return None\n        return min(self.OPEN, key=lambda node: node.k)\n\n    @property\n    def min_k(self) -&gt; float:\n        \"\"\"\n        Choose the minimum k value for nodes in OPEN list.\n        \"\"\"\n        return self.min_state.k\n\n    def insert(self, node: DNode, h_new: float) -&gt; None:\n        \"\"\"\n        Insert node into OPEN list.\n\n        Parameters:\n            node (DNode): the node to insert\n            h_new (float): new or better cost to come value\n        \"\"\"\n        if node.t == 'NEW':         node.k = h_new\n        elif node.t == 'OPEN':      node.k = min(node.k, h_new)\n        elif node.t == 'CLOSED':    node.k = min(node.h, h_new)\n        node.h, node.t = h_new, 'OPEN'\n        self.OPEN.append(node)\n\n    def delete(self, node: DNode) -&gt; None:\n        \"\"\"\n        Delete node from OPEN list.\n\n        Parameters:\n            node (DNode): the node to delete\n        \"\"\"\n        if node.t == 'OPEN':\n            node.t = 'CLOSED'\n        self.OPEN.remove(node)\n\n    def modify(self, node: DNode, node_parent: DNode) -&gt; None:\n        \"\"\"\n        Start processing from node.\n\n        Parameters:\n            node (DNode): the node to modify\n            node_parent (DNode): the parent node of `node`\n        \"\"\"\n        if node.t == 'CLOSED':\n            self.insert(node, node_parent.h + self.cost(node, node_parent))\n        while True:\n            k_min = self.processState()\n            if k_min &gt;= node.h:\n                break\n\n    def getNeighbor(self, node: DNode) -&gt; list:\n        \"\"\"\n        Find neighbors of node.\n\n        Parameters:\n            node (DNode): current node\n\n        Returns:\n            neighbors (list): neighbors of current node\n        \"\"\"\n        neighbors = []\n        for motion in self.motions:\n            n = self.map[(node + motion).current]\n            if not self.isCollision(node, n):\n                neighbors.append(n)\n        return neighbors\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.min_k","title":"<code>min_k: float</code>  <code>property</code>","text":"<p>Choose the minimum k value for nodes in OPEN list.</p>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.min_state","title":"<code>min_state: DNode</code>  <code>property</code>","text":"<p>Choose the node with the minimum k value in OPEN list.</p>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.OnPress","title":"<code>OnPress(event)</code>","text":"<p>Mouse button callback function.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>mouse event</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def OnPress(self, event) -&gt; None:\n    \"\"\"\n    Mouse button callback function.\n\n    Parameters:\n        event (MouseEvent): mouse event\n    \"\"\"\n    x, y = int(event.xdata), int(event.ydata)\n    if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n        print(\"Please choose right area!\")\n    else:\n        if (x, y) not in self.obstacles:\n            print(\"Add obstacle at: ({}, {})\".format(x, y))\n            # update obstacles\n            self.obstacles.add((x, y))\n            self.env.update(self.obstacles)\n\n            # move from start to goal, replan locally when meeting collisions\n            node = self.start\n            self.EXPAND, path, cost = [], [], 0\n            while node != self.goal:\n                node_parent = self.map[node.parent]\n                if self.isCollision(node, node_parent):\n                    self.modify(node, node_parent)\n                    continue\n                path.append(node.current)\n                cost += self.cost(node, node_parent)\n                node = node_parent\n\n            self.plot.clean()\n            self.plot.animation(path, str(self), cost, self.EXPAND)\n\n        self.plot.update()\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.delete","title":"<code>delete(node)</code>","text":"<p>Delete node from OPEN list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DNode</code> <p>the node to delete</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def delete(self, node: DNode) -&gt; None:\n    \"\"\"\n    Delete node from OPEN list.\n\n    Parameters:\n        node (DNode): the node to delete\n    \"\"\"\n    if node.t == 'OPEN':\n        node.t = 'CLOSED'\n    self.OPEN.remove(node)\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.extractPath","title":"<code>extractPath(closed_list)</code>","text":"<p>Extract the path based on the CLOSED list.</p> <p>Parameters:</p> Name Type Description Default <code>closed_list</code> <code>dict</code> <p>CLOSED list</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planning path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def extractPath(self, closed_list: dict) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED list.\n\n    Parameters:\n        closed_list (dict): CLOSED list\n\n    Returns:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    cost = 0\n    node = self.start\n    path = [node.current]\n    while node != self.goal:\n        node_parent = closed_list[node.parent]\n        cost += self.cost(node, node_parent)\n        node = node_parent\n        path.append(node.current)\n\n    return cost, path\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.getNeighbor","title":"<code>getNeighbor(node)</code>","text":"<p>Find neighbors of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DNode</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>neighbors</code> <code>list</code> <p>neighbors of current node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def getNeighbor(self, node: DNode) -&gt; list:\n    \"\"\"\n    Find neighbors of node.\n\n    Parameters:\n        node (DNode): current node\n\n    Returns:\n        neighbors (list): neighbors of current node\n    \"\"\"\n    neighbors = []\n    for motion in self.motions:\n        n = self.map[(node + motion).current]\n        if not self.isCollision(node, n):\n            neighbors.append(n)\n    return neighbors\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.insert","title":"<code>insert(node, h_new)</code>","text":"<p>Insert node into OPEN list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DNode</code> <p>the node to insert</p> required <code>h_new</code> <code>float</code> <p>new or better cost to come value</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def insert(self, node: DNode, h_new: float) -&gt; None:\n    \"\"\"\n    Insert node into OPEN list.\n\n    Parameters:\n        node (DNode): the node to insert\n        h_new (float): new or better cost to come value\n    \"\"\"\n    if node.t == 'NEW':         node.k = h_new\n    elif node.t == 'OPEN':      node.k = min(node.k, h_new)\n    elif node.t == 'CLOSED':    node.k = min(node.h, h_new)\n    node.h, node.t = h_new, 'OPEN'\n    self.OPEN.append(node)\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.modify","title":"<code>modify(node, node_parent)</code>","text":"<p>Start processing from node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>DNode</code> <p>the node to modify</p> required <code>node_parent</code> <code>DNode</code> <p>the parent node of <code>node</code></p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def modify(self, node: DNode, node_parent: DNode) -&gt; None:\n    \"\"\"\n    Start processing from node.\n\n    Parameters:\n        node (DNode): the node to modify\n        node_parent (DNode): the parent node of `node`\n    \"\"\"\n    if node.t == 'CLOSED':\n        self.insert(node, node_parent.h + self.cost(node, node_parent))\n    while True:\n        k_min = self.processState()\n        if k_min &gt;= node.h:\n            break\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.plan","title":"<code>plan()</code>","text":"<p>D* static motion planning function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>_</code> <code>None</code> <p>None</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    D* static motion planning function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        _ (None): None\n    \"\"\"\n    while True:\n        self.processState()\n        if self.start.t == 'CLOSED':\n            break\n    cost, path = self.extractPath(self.map)\n    return cost, path, None\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.processState","title":"<code>processState()</code>","text":"<p>Broadcast dynamic obstacle information.</p> <p>Returns:</p> Name Type Description <code>min_k</code> <code>float</code> <p>minimum k value of map</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def processState(self) -&gt; float:\n    \"\"\"\n    Broadcast dynamic obstacle information.\n\n    Returns:\n        min_k (float): minimum k value of map\n    \"\"\"\n    # get node in OPEN list with min k value\n    node = self.min_state\n    self.EXPAND.append(node)\n\n    if node is None:\n        return -1\n\n    # record the min k value of this iteration\n    k_old = self.min_k\n    # move node from OPEN list to CLOSED list\n    self.delete(node)  \n\n    # k_min &lt; h[x] --&gt; x: RAISE state (try to reduce k value by neighbor)\n    if k_old &lt; node.h:\n        for node_n in self.getNeighbor(node):\n            if node_n.h &lt;= k_old and node.h &gt; node_n.h + self.cost(node, node_n):\n                # update h_value and choose parent\n                node.parent = node_n.current\n                node.h = node_n.h + self.cost(node, node_n)\n\n    # k_min &gt;= h[x] -- &gt; x: LOWER state (cost reductions)\n    if k_old == node.h:\n        for node_n in self.getNeighbor(node):\n            if node_n.t == 'NEW' or \\\n                (node_n.parent == node.current and node_n.h != node.h + self.cost(node, node_n)) or \\\n                (node_n.parent != node.current and node_n.h &gt; node.h + self.cost(node, node_n)):\n                # Condition:\n                # 1) t[node_n] == 'NEW': not visited\n                # 2) node_n's parent: cost reduction\n                # 3) node_n find a better parent\n                node_n.parent = node.current\n                self.insert(node_n, node.h + self.cost(node, node_n))\n    else:\n        for node_n in self.getNeighbor(node):\n            if node_n.t == 'NEW' or \\\n                (node_n.parent == node.current and node_n.h != node.h + self.cost(node, node_n)):\n                # Condition:\n                # 1) t[node_n] == 'NEW': not visited\n                # 2) node_n's parent: cost reduction\n                node_n.parent = node.current\n                self.insert(node_n, node.h + self.cost(node, node_n))\n            else:\n                if node_n.parent != node.current and \\\n                    node_n.h &gt; node.h + self.cost(node, node_n):\n                    # Condition: LOWER happened in OPEN list (s), s should be explored again\n                    self.insert(node, node.h)\n                else:\n                    if node_n.parent != node.current and \\\n                        node.h &gt; node_n.h + self.cost(node, node_n) and \\\n                        node_n.t == 'CLOSED' and \\\n                        node_n.h &gt; k_old:\n                        # Condition: LOWER happened in CLOSED list (s_n), s_n should be explored again\n                        self.insert(node_n, node_n.h)\n    return self.min_k\n</code></pre>"},{"location":"global_planner/graph_search/d_star/DStar.html#src.python_motion_planning.global_planner.graph_search.d_star.DStar.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    # static planning\n    cost, path, _ = self.plan()\n\n    # animation\n    self.plot.connect('button_press_event', self.OnPress)\n    self.plot.animation(path, str(self), cost=cost)\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html","title":"DStarLite","text":""},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite","title":"<code>src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite</code>","text":"<p>               Bases: <code>LPAStar</code></p> <p>Class for D* Lite motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.DStarLite((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] D* Lite</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>class DStarLite(LPAStar):\n    \"\"\"\n    Class for D* Lite motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.DStarLite((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] D* Lite\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        GraphSearcher.__init__(self, start, goal, env, heuristic_type)\n        # start and goal\n        self.start = LNode(start, float('inf'), float('inf'), None)\n        self.goal = LNode(goal, float('inf'), 0.0, None)\n        # correction\n        self.km = 0\n        # OPEN set and expand zone\n        self.U, self.EXPAND = [], []\n\n        # intialize global information, record history infomation of map grids\n        self.map = {s: LNode(s, float('inf'), float('inf'), None) for s in self.env.grid_map}\n        self.map[self.goal.current] = self.goal\n        self.map[self.start.current] = self.start\n        # OPEN set with priority\n        self.goal.key = self.calculateKey(self.goal)\n        heapq.heappush(self.U, self.goal)\n\n    def __str__(self) -&gt; str:\n        return \"D* Lite\"\n\n    def OnPress(self, event) -&gt; None:\n        \"\"\"\n        Mouse button callback function.\n\n        Parameters:\n            event (MouseEvent): mouse event\n        \"\"\"\n        x, y = int(event.xdata), int(event.ydata)\n        if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n            print(\"Please choose right area!\")\n        else:\n            print(\"Change position: x = {}, y = {}\".format(x, y))\n\n            cur_start, new_start = self.start, self.start\n            update_start = True\n            cost, count = 0, 0\n            path = [self.start.current]\n            self.EXPAND = []\n\n            while cur_start != self.goal:\n                neighbors = [node_n for node_n in self.getNeighbor(cur_start)\n                    if not self.isCollision(cur_start, node_n)]\n                next_node = min(neighbors, key=lambda n: n.g)\n                path.append(next_node.current)\n                cost += self.cost(cur_start, next_node)\n                count += 1\n                cur_start = next_node\n\n                if update_start:\n                    update_start = False\n                    self.km = self.h(cur_start, new_start)\n                    new_start = cur_start\n\n                    node_change = self.map[(x, y)]\n                    if (x, y) not in self.obstacles:\n                        self.obstacles.add((x, y))\n                    else:\n                        self.obstacles.remove((x, y))\n                        self.updateVertex(node_change)\n\n                    self.env.update(self.obstacles)\n                    for node_n in self.getNeighbor(node_change):\n                        self.updateVertex(node_n)\n\n                    self.computeShortestPath()    \n\n            # animation\n            self.plot.clean()\n            self.plot.animation(path, str(self), cost, self.EXPAND)\n            self.plot.update()\n\n    def computeShortestPath(self) -&gt; None:\n        \"\"\"\n        Perceived dynamic obstacle information to optimize global path.\n        \"\"\"\n        while True:\n            node = min(self.U, key=lambda node: node.key)\n            if node.key &gt;= self.calculateKey(self.start) and \\\n                    self.start.rhs == self.start.g:\n                break\n\n            self.U.remove(node)\n            self.EXPAND.append(node)\n\n            # affected by obstacles\n            if node.key &lt; self.calculateKey(node):\n                node.key = self.calculateKey(node)\n                heapq.heappush(self.U, node)\n            # Locally over-consistent -&gt; Locally consistent\n            elif node.g &gt; node.rhs:\n                node.g = node.rhs\n                for node_n in self.getNeighbor(node):\n                    self.updateVertex(node_n)\n            # Locally under-consistent -&gt; Locally over-consistent\n            else:\n                node.g = float(\"inf\")\n                self.updateVertex(node)\n                for node_n in self.getNeighbor(node):\n                    self.updateVertex(node_n)\n\n    def updateVertex(self, node: LNode) -&gt; None:\n        \"\"\"\n        Update the status and the current cost to node and it's neighbor.\n\n        Parameters:\n            node (LNode): the node to be updated\n        \"\"\"\n        # greed correction(reverse searching)\n        if node != self.goal:\n            node.rhs = min([node_n.g + self.cost(node_n, node)\n                        for node_n in self.getNeighbor(node)])\n\n        if node in self.U:\n            self.U.remove(node)\n\n        # Locally unconsistent nodes should be added into OPEN set (set U)\n        if node.g != node.rhs:\n            node.key = self.calculateKey(node)\n            heapq.heappush(self.U, node)\n\n    def calculateKey(self, node: LNode) -&gt; list:\n        \"\"\"\n        Calculate priority of node.\n\n        Parameters:\n            node (LNode): the node to be calculated\n\n        Returns:\n            key (list): the priority of node\n        \"\"\"\n        return [min(node.g, node.rhs) + self.h(node, self.start) + self.km,\n                min(node.g, node.rhs)]\n\n    def extractPath(self) -&gt; tuple:\n        \"\"\"\n        Extract the path based on greedy policy.\n\n        Returns:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        node = self.start\n        path = [node.current]\n        cost, count = 0, 0\n        while node != self.goal:\n            neighbors = [node_n for node_n in self.getNeighbor(node) if not self.isCollision(node, node_n)]\n            next_node = min(neighbors, key=lambda n: n.g)\n            path.append(next_node.current)\n            cost += self.cost(node, next_node)\n            node = next_node\n            count += 1\n            if count == 1000:\n                return cost, []\n        return cost, list(path)\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite.OnPress","title":"<code>OnPress(event)</code>","text":"<p>Mouse button callback function.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>mouse event</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>def OnPress(self, event) -&gt; None:\n    \"\"\"\n    Mouse button callback function.\n\n    Parameters:\n        event (MouseEvent): mouse event\n    \"\"\"\n    x, y = int(event.xdata), int(event.ydata)\n    if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n        print(\"Please choose right area!\")\n    else:\n        print(\"Change position: x = {}, y = {}\".format(x, y))\n\n        cur_start, new_start = self.start, self.start\n        update_start = True\n        cost, count = 0, 0\n        path = [self.start.current]\n        self.EXPAND = []\n\n        while cur_start != self.goal:\n            neighbors = [node_n for node_n in self.getNeighbor(cur_start)\n                if not self.isCollision(cur_start, node_n)]\n            next_node = min(neighbors, key=lambda n: n.g)\n            path.append(next_node.current)\n            cost += self.cost(cur_start, next_node)\n            count += 1\n            cur_start = next_node\n\n            if update_start:\n                update_start = False\n                self.km = self.h(cur_start, new_start)\n                new_start = cur_start\n\n                node_change = self.map[(x, y)]\n                if (x, y) not in self.obstacles:\n                    self.obstacles.add((x, y))\n                else:\n                    self.obstacles.remove((x, y))\n                    self.updateVertex(node_change)\n\n                self.env.update(self.obstacles)\n                for node_n in self.getNeighbor(node_change):\n                    self.updateVertex(node_n)\n\n                self.computeShortestPath()    \n\n        # animation\n        self.plot.clean()\n        self.plot.animation(path, str(self), cost, self.EXPAND)\n        self.plot.update()\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite.calculateKey","title":"<code>calculateKey(node)</code>","text":"<p>Calculate priority of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LNode</code> <p>the node to be calculated</p> required <p>Returns:</p> Name Type Description <code>key</code> <code>list</code> <p>the priority of node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>def calculateKey(self, node: LNode) -&gt; list:\n    \"\"\"\n    Calculate priority of node.\n\n    Parameters:\n        node (LNode): the node to be calculated\n\n    Returns:\n        key (list): the priority of node\n    \"\"\"\n    return [min(node.g, node.rhs) + self.h(node, self.start) + self.km,\n            min(node.g, node.rhs)]\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite.computeShortestPath","title":"<code>computeShortestPath()</code>","text":"<p>Perceived dynamic obstacle information to optimize global path.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>def computeShortestPath(self) -&gt; None:\n    \"\"\"\n    Perceived dynamic obstacle information to optimize global path.\n    \"\"\"\n    while True:\n        node = min(self.U, key=lambda node: node.key)\n        if node.key &gt;= self.calculateKey(self.start) and \\\n                self.start.rhs == self.start.g:\n            break\n\n        self.U.remove(node)\n        self.EXPAND.append(node)\n\n        # affected by obstacles\n        if node.key &lt; self.calculateKey(node):\n            node.key = self.calculateKey(node)\n            heapq.heappush(self.U, node)\n        # Locally over-consistent -&gt; Locally consistent\n        elif node.g &gt; node.rhs:\n            node.g = node.rhs\n            for node_n in self.getNeighbor(node):\n                self.updateVertex(node_n)\n        # Locally under-consistent -&gt; Locally over-consistent\n        else:\n            node.g = float(\"inf\")\n            self.updateVertex(node)\n            for node_n in self.getNeighbor(node):\n                self.updateVertex(node_n)\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite.extractPath","title":"<code>extractPath()</code>","text":"<p>Extract the path based on greedy policy.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planning path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>def extractPath(self) -&gt; tuple:\n    \"\"\"\n    Extract the path based on greedy policy.\n\n    Returns:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    node = self.start\n    path = [node.current]\n    cost, count = 0, 0\n    while node != self.goal:\n        neighbors = [node_n for node_n in self.getNeighbor(node) if not self.isCollision(node, node_n)]\n        next_node = min(neighbors, key=lambda n: n.g)\n        path.append(next_node.current)\n        cost += self.cost(node, next_node)\n        node = next_node\n        count += 1\n        if count == 1000:\n            return cost, []\n    return cost, list(path)\n</code></pre>"},{"location":"global_planner/graph_search/d_star_lite/DStarLite.html#src.python_motion_planning.global_planner.graph_search.d_star_lite.DStarLite.updateVertex","title":"<code>updateVertex(node)</code>","text":"<p>Update the status and the current cost to node and it's neighbor.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LNode</code> <p>the node to be updated</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\d_star_lite.py</code> Python<pre><code>def updateVertex(self, node: LNode) -&gt; None:\n    \"\"\"\n    Update the status and the current cost to node and it's neighbor.\n\n    Parameters:\n        node (LNode): the node to be updated\n    \"\"\"\n    # greed correction(reverse searching)\n    if node != self.goal:\n        node.rhs = min([node_n.g + self.cost(node_n, node)\n                    for node_n in self.getNeighbor(node)])\n\n    if node in self.U:\n        self.U.remove(node)\n\n    # Locally unconsistent nodes should be added into OPEN set (set U)\n    if node.g != node.rhs:\n        node.key = self.calculateKey(node)\n        heapq.heappush(self.U, node)\n</code></pre>"},{"location":"global_planner/graph_search/dijkstra/Dijkstra.html","title":"Dijkstra","text":""},{"location":"global_planner/graph_search/dijkstra/Dijkstra.html#src.python_motion_planning.global_planner.graph_search.dijkstra.Dijkstra","title":"<code>src.python_motion_planning.global_planner.graph_search.dijkstra.Dijkstra</code>","text":"<p>               Bases: <code>AStar</code></p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\dijkstra.py</code> Python<pre><code>class Dijkstra(AStar):\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"Dijkstra\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Class for Dijkstra motion planning.\n\n        Parameters:\n            start (tuple): start point coordinate\n            goal (tuple): goal point coordinate\n            env (Env): environment\n            heuristic_type (str): heuristic function type\n\n        Examples:\n            &gt;&gt;&gt; import python_motion_planning as pmp\n            &gt;&gt;&gt; planner = pmp.Dijkstra((5, 5), (45, 25), pmp.Grid(51, 31))\n            &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n            &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n            &gt;&gt;&gt; planner.run()       # run both planning and animation\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):\n\n                # hit the obstacle\n                if node_n.current in self.obstacles:\n                    continue\n\n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                node_n.parent = node.current\n                node_n.h = 0\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN set\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/dijkstra/Dijkstra.html#src.python_motion_planning.global_planner.graph_search.dijkstra.Dijkstra.plan","title":"<code>plan()</code>","text":"<p>Class for Dijkstra motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.Dijkstra((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\dijkstra.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Class for Dijkstra motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.Dijkstra((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):\n\n            # hit the obstacle\n            if node_n.current in self.obstacles:\n                continue\n\n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            node_n.parent = node.current\n            node_n.h = 0\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN set\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/gbfs/GBFS.html","title":"GBFS","text":""},{"location":"global_planner/graph_search/gbfs/GBFS.html#src.python_motion_planning.global_planner.graph_search.gbfs.GBFS","title":"<code>src.python_motion_planning.global_planner.graph_search.gbfs.GBFS</code>","text":"<p>               Bases: <code>AStar</code></p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\gbfs.py</code> Python<pre><code>class GBFS(AStar):\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"Greedy Best First Search(GBFS)\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Class for Greedy Best First Search.\n\n        Parameters:\n            start (tuple): start point coordinate\n            goal (tuple): goal point coordinate\n            env (Env): environment\n            heuristic_type (str): heuristic function type\n\n        Examples:\n            &gt;&gt;&gt; import python_motion_planning as pmp\n            &gt;&gt;&gt; planner = pmp.GBFS((5, 5), (45, 25), pmp.Grid(51, 31))\n            &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n            &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n            &gt;&gt;&gt; planner.run()       # run both planning and animation\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):\n\n                # hit the obstacle\n                if node_n.current in self.obstacles:\n                    continue\n\n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                node_n.parent = node.current\n                node_n.h = self.h(node_n, self.goal)\n                node_n.g = 0\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN set\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/gbfs/GBFS.html#src.python_motion_planning.global_planner.graph_search.gbfs.GBFS.plan","title":"<code>plan()</code>","text":"<p>Class for Greedy Best First Search.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> required <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.GBFS((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\gbfs.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Class for Greedy Best First Search.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.GBFS((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):\n\n            # hit the obstacle\n            if node_n.current in self.obstacles:\n                continue\n\n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            node_n.parent = node.current\n            node_n.h = self.h(node_n, self.goal)\n            node_n.g = 0\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN set\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/graph_search/GraphSearcher.html","title":"GraphSearcher","text":""},{"location":"global_planner/graph_search/graph_search/GraphSearcher.html#src.python_motion_planning.global_planner.graph_search.graph_search.GraphSearcher","title":"<code>src.python_motion_planning.global_planner.graph_search.graph_search.GraphSearcher</code>","text":"<p>               Bases: <code>Planner</code></p> <p>Base class for planner based on graph searching.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\graph_search.py</code> Python<pre><code>class GraphSearcher(Planner):\n    \"\"\"\n    Base class for planner based on graph searching.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str=\"euclidean\") -&gt; None:\n        super().__init__(start, goal, env)\n        # heuristic type\n        self.heuristic_type = heuristic_type\n        # allowed motions\n        self.motions = self.env.motions\n        # obstacles\n        self.obstacles = self.env.obstacles\n\n    def h(self, node: Node, goal: Node) -&gt; float:\n        \"\"\"\n        Calculate heuristic.\n\n        Parameters:\n            node (Node): current node\n            goal (Node): goal node\n\n        Returns:\n            h (float): heuristic function value of node\n        \"\"\"\n        if self.heuristic_type == \"manhattan\":\n            return abs(goal.x - node.x) + abs(goal.y - node.y)\n        elif self.heuristic_type == \"euclidean\":\n            return math.hypot(goal.x - node.x, goal.y - node.y)\n\n    def cost(self, node1: Node, node2: Node) -&gt; float:\n        \"\"\"\n        Calculate cost for this motion.\n\n        Parameters:\n            node1 (Node): node 1\n            node2 (Node): node 2\n\n        Returns:\n            cost (float): cost of this motion\n        \"\"\"\n        if self.isCollision(node1, node2):\n            return float(\"inf\")\n        return self.dist(node1, node2)\n\n    def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2.\n\n        Parameters:\n            node1 (Node): node 1\n            node2 (Node): node 2\n\n        Returns:\n            collision (bool): True if collision exists else False\n        \"\"\"\n        if node1.current in self.obstacles or node2.current in self.obstacles:\n            return True\n\n        x1, y1 = node1.x, node1.y\n        x2, y2 = node2.x, node2.y\n\n        if x1 != x2 and y1 != y2:\n            if x2 - x1 == y1 - y2:\n                s1 = (min(x1, x2), min(y1, y2))\n                s2 = (max(x1, x2), max(y1, y2))\n            else:\n                s1 = (min(x1, x2), max(y1, y2))\n                s2 = (max(x1, x2), min(y1, y2))\n            if s1 in self.obstacles or s2 in self.obstacles:\n                return True\n        return False\n</code></pre>"},{"location":"global_planner/graph_search/graph_search/GraphSearcher.html#src.python_motion_planning.global_planner.graph_search.graph_search.GraphSearcher.cost","title":"<code>cost(node1, node2)</code>","text":"<p>Calculate cost for this motion.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>node 1</p> required <code>node2</code> <code>Node</code> <p>node 2</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>cost of this motion</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\graph_search.py</code> Python<pre><code>def cost(self, node1: Node, node2: Node) -&gt; float:\n    \"\"\"\n    Calculate cost for this motion.\n\n    Parameters:\n        node1 (Node): node 1\n        node2 (Node): node 2\n\n    Returns:\n        cost (float): cost of this motion\n    \"\"\"\n    if self.isCollision(node1, node2):\n        return float(\"inf\")\n    return self.dist(node1, node2)\n</code></pre>"},{"location":"global_planner/graph_search/graph_search/GraphSearcher.html#src.python_motion_planning.global_planner.graph_search.graph_search.GraphSearcher.h","title":"<code>h(node, goal)</code>","text":"<p>Calculate heuristic.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <code>goal</code> <code>Node</code> <p>goal node</p> required <p>Returns:</p> Name Type Description <code>h</code> <code>float</code> <p>heuristic function value of node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\graph_search.py</code> Python<pre><code>def h(self, node: Node, goal: Node) -&gt; float:\n    \"\"\"\n    Calculate heuristic.\n\n    Parameters:\n        node (Node): current node\n        goal (Node): goal node\n\n    Returns:\n        h (float): heuristic function value of node\n    \"\"\"\n    if self.heuristic_type == \"manhattan\":\n        return abs(goal.x - node.x) + abs(goal.y - node.y)\n    elif self.heuristic_type == \"euclidean\":\n        return math.hypot(goal.x - node.x, goal.y - node.y)\n</code></pre>"},{"location":"global_planner/graph_search/graph_search/GraphSearcher.html#src.python_motion_planning.global_planner.graph_search.graph_search.GraphSearcher.isCollision","title":"<code>isCollision(node1, node2)</code>","text":"<p>Judge collision when moving from node1 to node2.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>node 1</p> required <code>node2</code> <code>Node</code> <p>node 2</p> required <p>Returns:</p> Name Type Description <code>collision</code> <code>bool</code> <p>True if collision exists else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\graph_search.py</code> Python<pre><code>def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2.\n\n    Parameters:\n        node1 (Node): node 1\n        node2 (Node): node 2\n\n    Returns:\n        collision (bool): True if collision exists else False\n    \"\"\"\n    if node1.current in self.obstacles or node2.current in self.obstacles:\n        return True\n\n    x1, y1 = node1.x, node1.y\n    x2, y2 = node2.x, node2.y\n\n    if x1 != x2 and y1 != y2:\n        if x2 - x1 == y1 - y2:\n            s1 = (min(x1, x2), min(y1, y2))\n            s2 = (max(x1, x2), max(y1, y2))\n        else:\n            s1 = (min(x1, x2), max(y1, y2))\n            s2 = (max(x1, x2), min(y1, y2))\n        if s1 in self.obstacles or s2 in self.obstacles:\n            return True\n    return False\n</code></pre>"},{"location":"global_planner/graph_search/jps/JPS.html","title":"JPS","text":""},{"location":"global_planner/graph_search/jps/JPS.html#src.python_motion_planning.global_planner.graph_search.jps.JPS","title":"<code>src.python_motion_planning.global_planner.graph_search.jps.JPS</code>","text":"<p>               Bases: <code>AStar</code></p> <p>Class for JPS motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.JPS((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Online Graph Pruning for Pathfinding On Grid Maps</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\jps.py</code> Python<pre><code>class JPS(AStar):\n    \"\"\"\n    Class for JPS motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.JPS((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Online Graph Pruning for Pathfinding On Grid Maps\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"Jump Point Search(JPS)\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        JPS motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): all nodes that planner has searched\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            jp_list = []\n            for motion in self.motions:\n                jp = self.jump(node, motion)\n                # exists and not in CLOSED list\n                if jp and jp.current not in CLOSED:\n                    jp.parent = node.current\n                    jp.h = self.h(jp, self.goal)\n                    jp_list.append(jp)\n\n            for jp in jp_list:\n                # update OPEN list\n                heapq.heappush(OPEN, jp)\n\n                # goal found\n                if jp == self.goal:\n                    break\n\n            CLOSED[node.current] = node\n        return [], [], []\n\n    def jump(self, node: Node, motion: Node):\n        \"\"\"\n        Jumping search recursively.\n\n        Parameters:\n            node (Node): current node\n            motion (Node): the motion that current node executes\n\n        Returns:\n            jump_point (Node): jump point or None if searching fails\n        \"\"\"\n        # explore a new node\n        new_node = node + motion\n        new_node.parent = node.current\n        new_node.h = self.h(new_node, self.goal)\n\n        # hit the obstacle\n        if new_node.current in self.obstacles:\n            return None\n\n        # goal found\n        if new_node == self.goal:\n            return new_node\n\n        # diagonal\n        if motion.x and motion.y:\n            # if exists jump point at horizontal or vertical\n            x_dir = Node((motion.x, 0), None, 1, None)\n            y_dir = Node((0, motion.y), None, 1, None)\n            if self.jump(new_node, x_dir) or self.jump(new_node, y_dir):\n                return new_node\n\n        # if exists forced neighbor\n        if self.detectForceNeighbor(new_node, motion):\n            return new_node\n        else:\n            return self.jump(new_node, motion)\n\n    def detectForceNeighbor(self, node, motion):\n        \"\"\"\n        Detect forced neighbor of node.\n\n        Parameters:\n            node (Node): current node\n            motion (Node): the motion that current node executes\n\n        Returns:\n            flag (bool): True if current node has forced neighbor else Flase\n        \"\"\"\n        x, y = node.current\n        x_dir, y_dir = motion.current\n\n        # horizontal\n        if x_dir and not y_dir:\n            if (x, y + 1) in self.obstacles and \\\n                (x + x_dir, y + 1) not in self.obstacles:\n                return True\n            if (x, y - 1) in self.obstacles and \\\n                (x + x_dir, y - 1) not in self.obstacles:\n                return True\n\n        # vertical\n        if not x_dir and y_dir:\n            if (x + 1, y) in self.obstacles and \\\n                (x + 1, y + y_dir) not in self.obstacles:\n                return True\n            if (x - 1, y) in self.obstacles and \\\n                (x - 1, y + y_dir) not in self.obstacles:\n                return True\n\n        # diagonal\n        if x_dir and y_dir:\n            if (x - x_dir, y) in self.obstacles and \\\n                (x - x_dir, y + y_dir) not in self.obstacles:\n                return True\n            if (x, y - y_dir) in self.obstacles and \\\n                (x + x_dir, y - y_dir) not in self.obstacles:\n                return True\n\n        return False\n</code></pre>"},{"location":"global_planner/graph_search/jps/JPS.html#src.python_motion_planning.global_planner.graph_search.jps.JPS.detectForceNeighbor","title":"<code>detectForceNeighbor(node, motion)</code>","text":"<p>Detect forced neighbor of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <code>motion</code> <code>Node</code> <p>the motion that current node executes</p> required <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>True if current node has forced neighbor else Flase</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\jps.py</code> Python<pre><code>def detectForceNeighbor(self, node, motion):\n    \"\"\"\n    Detect forced neighbor of node.\n\n    Parameters:\n        node (Node): current node\n        motion (Node): the motion that current node executes\n\n    Returns:\n        flag (bool): True if current node has forced neighbor else Flase\n    \"\"\"\n    x, y = node.current\n    x_dir, y_dir = motion.current\n\n    # horizontal\n    if x_dir and not y_dir:\n        if (x, y + 1) in self.obstacles and \\\n            (x + x_dir, y + 1) not in self.obstacles:\n            return True\n        if (x, y - 1) in self.obstacles and \\\n            (x + x_dir, y - 1) not in self.obstacles:\n            return True\n\n    # vertical\n    if not x_dir and y_dir:\n        if (x + 1, y) in self.obstacles and \\\n            (x + 1, y + y_dir) not in self.obstacles:\n            return True\n        if (x - 1, y) in self.obstacles and \\\n            (x - 1, y + y_dir) not in self.obstacles:\n            return True\n\n    # diagonal\n    if x_dir and y_dir:\n        if (x - x_dir, y) in self.obstacles and \\\n            (x - x_dir, y + y_dir) not in self.obstacles:\n            return True\n        if (x, y - y_dir) in self.obstacles and \\\n            (x + x_dir, y - y_dir) not in self.obstacles:\n            return True\n\n    return False\n</code></pre>"},{"location":"global_planner/graph_search/jps/JPS.html#src.python_motion_planning.global_planner.graph_search.jps.JPS.jump","title":"<code>jump(node, motion)</code>","text":"<p>Jumping search recursively.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>current node</p> required <code>motion</code> <code>Node</code> <p>the motion that current node executes</p> required <p>Returns:</p> Name Type Description <code>jump_point</code> <code>Node</code> <p>jump point or None if searching fails</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\jps.py</code> Python<pre><code>def jump(self, node: Node, motion: Node):\n    \"\"\"\n    Jumping search recursively.\n\n    Parameters:\n        node (Node): current node\n        motion (Node): the motion that current node executes\n\n    Returns:\n        jump_point (Node): jump point or None if searching fails\n    \"\"\"\n    # explore a new node\n    new_node = node + motion\n    new_node.parent = node.current\n    new_node.h = self.h(new_node, self.goal)\n\n    # hit the obstacle\n    if new_node.current in self.obstacles:\n        return None\n\n    # goal found\n    if new_node == self.goal:\n        return new_node\n\n    # diagonal\n    if motion.x and motion.y:\n        # if exists jump point at horizontal or vertical\n        x_dir = Node((motion.x, 0), None, 1, None)\n        y_dir = Node((0, motion.y), None, 1, None)\n        if self.jump(new_node, x_dir) or self.jump(new_node, y_dir):\n            return new_node\n\n    # if exists forced neighbor\n    if self.detectForceNeighbor(new_node, motion):\n        return new_node\n    else:\n        return self.jump(new_node, motion)\n</code></pre>"},{"location":"global_planner/graph_search/jps/JPS.html#src.python_motion_planning.global_planner.graph_search.jps.JPS.plan","title":"<code>plan()</code>","text":"<p>JPS motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>all nodes that planner has searched</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\jps.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    JPS motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): all nodes that planner has searched\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        jp_list = []\n        for motion in self.motions:\n            jp = self.jump(node, motion)\n            # exists and not in CLOSED list\n            if jp and jp.current not in CLOSED:\n                jp.parent = node.current\n                jp.h = self.h(jp, self.goal)\n                jp_list.append(jp)\n\n        for jp in jp_list:\n            # update OPEN list\n            heapq.heappush(OPEN, jp)\n\n            # goal found\n            if jp == self.goal:\n                break\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/lazy_theta_star/LazyThetaStar.html","title":"LazyThetaStar","text":""},{"location":"global_planner/graph_search/lazy_theta_star/LazyThetaStar.html#src.python_motion_planning.global_planner.graph_search.lazy_theta_star.LazyThetaStar","title":"<code>src.python_motion_planning.global_planner.graph_search.lazy_theta_star.LazyThetaStar</code>","text":"<p>               Bases: <code>ThetaStar</code></p> <p>Class for Lazy Theta* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.LazyThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Lazy Theta*: Any-Angle Path Planning and Path Length Analysis in 3D</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lazy_theta_star.py</code> Python<pre><code>class LazyThetaStar(ThetaStar):\n    \"\"\"\n    Class for Lazy Theta* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.LazyThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Lazy Theta*: Any-Angle Path Planning and Path Length Analysis in 3D\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"Lazy Theta*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Lazy Theta* motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): all nodes that planner has searched\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # set vertex: path 1\n            node_p = CLOSED.get(node.parent)\n            if node_p:\n                if not self.lineOfSight(node_p, node):\n                    node.g = float(\"inf\")\n                    for node_n in self.getNeighbor(node):\n                        if node_n.current in CLOSED:\n                            node_n = CLOSED[node_n.current]\n                            if node.g &gt; node_n.g + self.dist(node_n, node):\n                                node.g = node_n.g + self.dist(node_n, node)\n                                node.parent = node_n.current\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):                \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                # path1\n                node_n.parent = node.current\n                node_n.h = self.h(node_n, self.goal)\n\n                node_p = CLOSED.get(node.parent)\n\n                if node_p:\n                    # path2\n                    self.updateVertex(node_p, node_n)\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n\n    def updateVertex(self, node_p: Node, node_c: Node) -&gt; None:\n        \"\"\"\n        Update extend node information with current node's parent node.\n\n        Parameters:\n            node_p (Node): parent node\n            node_c (Node): current node\n        \"\"\"\n        # path 2\n        if node_p.g + self.dist(node_c, node_p) &lt;= node_c.g:\n            node_c.g = node_p.g + self.dist(node_c, node_p)\n            node_c.parent = node_p.current  \n</code></pre>"},{"location":"global_planner/graph_search/lazy_theta_star/LazyThetaStar.html#src.python_motion_planning.global_planner.graph_search.lazy_theta_star.LazyThetaStar.plan","title":"<code>plan()</code>","text":"<p>Lazy Theta* motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>all nodes that planner has searched</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lazy_theta_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Lazy Theta* motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): all nodes that planner has searched\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # set vertex: path 1\n        node_p = CLOSED.get(node.parent)\n        if node_p:\n            if not self.lineOfSight(node_p, node):\n                node.g = float(\"inf\")\n                for node_n in self.getNeighbor(node):\n                    if node_n.current in CLOSED:\n                        node_n = CLOSED[node_n.current]\n                        if node.g &gt; node_n.g + self.dist(node_n, node):\n                            node.g = node_n.g + self.dist(node_n, node)\n                            node.parent = node_n.current\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):                \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            # path1\n            node_n.parent = node.current\n            node_n.h = self.h(node_n, self.goal)\n\n            node_p = CLOSED.get(node.parent)\n\n            if node_p:\n                # path2\n                self.updateVertex(node_p, node_n)\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/lazy_theta_star/LazyThetaStar.html#src.python_motion_planning.global_planner.graph_search.lazy_theta_star.LazyThetaStar.updateVertex","title":"<code>updateVertex(node_p, node_c)</code>","text":"<p>Update extend node information with current node's parent node.</p> <p>Parameters:</p> Name Type Description Default <code>node_p</code> <code>Node</code> <p>parent node</p> required <code>node_c</code> <code>Node</code> <p>current node</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lazy_theta_star.py</code> Python<pre><code>def updateVertex(self, node_p: Node, node_c: Node) -&gt; None:\n    \"\"\"\n    Update extend node information with current node's parent node.\n\n    Parameters:\n        node_p (Node): parent node\n        node_c (Node): current node\n    \"\"\"\n    # path 2\n    if node_p.g + self.dist(node_c, node_p) &lt;= node_c.g:\n        node_c.g = node_p.g + self.dist(node_c, node_p)\n        node_c.parent = node_p.current  \n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LNode.html","title":"LNode","text":""},{"location":"global_planner/graph_search/lpa_star/LNode.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LNode","title":"<code>src.python_motion_planning.global_planner.graph_search.lpa_star.LNode</code>","text":"<p>               Bases: <code>Node</code></p> <p>Class for LPA* nodes.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>tuple</code> <p>current coordinate</p> required <code>g</code> <code>float</code> <p>minimum cost moving from start(predict)</p> required <code>rhs</code> <code>float</code> <p>minimum cost moving from start(value)</p> required <code>key</code> <code>list</code> <p>priority</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>class LNode(Node):\n    \"\"\"\n    Class for LPA* nodes.\n\n    Parameters:\n        current (tuple): current coordinate\n        g (float): minimum cost moving from start(predict)\n        rhs (float): minimum cost moving from start(value)\n        key (list): priority\n    \"\"\"\n    def __init__(self, current: tuple, g: float, rhs: float, key: list) -&gt; None:\n        self.current = current\n        self.g = g\n        self.rhs = rhs\n        self.key = key\n\n    def __add__(self, node):\n        return LNode((self.x + node.x, self.y + node.y), \n                      self.g, self.rhs, self.key)\n\n    def __lt__(self, node) -&gt; bool:\n        return self.key &lt; node.key\n\n    def __str__(self) -&gt; str:\n        return \"----------\\ncurrent:{}\\ng:{}\\nrhs:{}\\nkey:{}\\n----------\" \\\n            .format(self.current, self.g, self.rhs, self.key)\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html","title":"LPAStar","text":""},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar","title":"<code>src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar</code>","text":"<p>               Bases: <code>GraphSearcher</code></p> <p>Class for LPA* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.LPAStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Lifelong Planning A*</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>class LPAStar(GraphSearcher):\n    \"\"\"\n    Class for LPA* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.LPAStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Lifelong Planning A*\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n        # start and goal\n        self.start = LNode(start, float('inf'), 0.0, None)\n        self.goal = LNode(goal, float('inf'), float('inf'), None)\n        # OPEN set and expand zone\n        self.U, self.EXPAND = [], []\n\n        # intialize global information, record history infomation of map grids\n        self.map = {s: LNode(s, float('inf'), float('inf'), None) for s in self.env.grid_map}\n        self.map[self.goal.current] = self.goal\n        self.map[self.start.current] = self.start\n        # OPEN set with priority\n        self.start.key = self.calculateKey(self.start)\n        heapq.heappush(self.U, self.start)\n\n    def __str__(self) -&gt; str:\n        return \"Lifelong Planning A*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        LPA* dynamic motion planning function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            _ (None): None\n        \"\"\"\n        self.computeShortestPath()\n        cost, path = self.extractPath()\n        return cost, path, None\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        # static planning\n        cost, path, _ = self.plan()\n\n        # animation\n        self.plot.connect('button_press_event', self.OnPress)\n        self.plot.animation(path, str(self), cost=cost)\n\n    def OnPress(self, event):\n        \"\"\"\n        Mouse button callback function.\n\n        Parameters:\n            event (MouseEvent): mouse event\n        \"\"\"\n        x, y = int(event.xdata), int(event.ydata)\n        if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n            print(\"Please choose right area!\")\n        else:\n            print(\"Change position: x = {}, y = {}\".format(x, y))\n            self.EXPAND = []\n            node_change = self.map[(x, y)]\n\n            if (x, y) not in self.obstacles:\n                self.obstacles.add((x, y))\n            else:\n                self.obstacles.remove((x, y))\n                self.updateVertex(node_change)\n\n            self.env.update(self.obstacles)\n\n            for node_n in self.getNeighbor(node_change):\n                self.updateVertex(node_n)\n\n            cost, path, _ = self.plan()\n\n            # animation\n            self.plot.clean()\n            self.plot.animation(path, str(self), cost, self.EXPAND)\n            self.plot.update()\n\n    def computeShortestPath(self) -&gt; None:\n        \"\"\"\n        Perceived dynamic obstacle information to optimize global path.\n        \"\"\"\n        while True:\n            node = min(self.U, key=lambda node: node.key)\n            if node.key &gt;= self.calculateKey(self.goal) and \\\n                    self.goal.rhs == self.goal.g:\n                break\n\n            self.U.remove(node)\n            self.EXPAND.append(node)\n\n            # Locally over-consistent -&gt; Locally consistent\n            if node.g &gt; node.rhs:\n                node.g = node.rhs\n            # Locally under-consistent -&gt; Locally over-consistent\n            else:\n                node.g = float(\"inf\")\n                self.updateVertex(node)\n\n            for node_n in self.getNeighbor(node):\n                self.updateVertex(node_n)\n\n    def updateVertex(self, node: LNode) -&gt; None:\n        \"\"\"\n        Update the status and the current cost to node and it's neighbor.\n\n        Parameters:\n            node (LNode): current node\n        \"\"\"\n        # greed correction\n        if node != self.start:\n            node.rhs = min([node_n.g + self.cost(node_n, node)\n                        for node_n in self.getNeighbor(node)])\n\n        if node in self.U:\n            self.U.remove(node)\n\n        # Locally unconsistent nodes should be added into OPEN set (set U)\n        if node.g != node.rhs:\n            node.key = self.calculateKey(node)\n            heapq.heappush(self.U, node)\n\n    def calculateKey(self, node: LNode) -&gt; list:\n        \"\"\"\n        Calculate priority of node.\n\n        Parameters:\n            node (LNode): current node\n\n        Returns:\n            key (list): priority of node\n        \"\"\"\n        return [min(node.g, node.rhs) + self.h(node, self.goal),\n                min(node.g, node.rhs)]\n\n    def getNeighbor(self, node: LNode) -&gt; list:\n        \"\"\"\n        Find neighbors of node.\n\n        Parameters:\n            node (LNode): current node\n\n        Returns:\n            neighbors (list): neighbors of node\n        \"\"\"\n        neighbors = []\n        for motion in self.motions:\n            n = self.map[(node + motion).current]\n            if n.current not in self.obstacles:\n                neighbors.append(n)\n        return neighbors\n\n    def extractPath(self):\n        \"\"\"\n        Extract the path based on greedy policy.\n\n        Return:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        node = self.goal\n        path = [node.current]\n        cost, count = 0, 0\n        while node != self.start:\n            neighbors = [node_n for node_n in self.getNeighbor(node) if not self.isCollision(node, node_n)]\n            next_node = min(neighbors, key=lambda n: n.g)\n            path.append(next_node.current)\n            cost += self.cost(node, next_node)\n            node = next_node\n            count += 1\n            if count == 1000:\n                return cost, []\n        return cost, list(reversed(path))\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.OnPress","title":"<code>OnPress(event)</code>","text":"<p>Mouse button callback function.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MouseEvent</code> <p>mouse event</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def OnPress(self, event):\n    \"\"\"\n    Mouse button callback function.\n\n    Parameters:\n        event (MouseEvent): mouse event\n    \"\"\"\n    x, y = int(event.xdata), int(event.ydata)\n    if x &lt; 0 or x &gt; self.env.x_range - 1 or y &lt; 0 or y &gt; self.env.y_range - 1:\n        print(\"Please choose right area!\")\n    else:\n        print(\"Change position: x = {}, y = {}\".format(x, y))\n        self.EXPAND = []\n        node_change = self.map[(x, y)]\n\n        if (x, y) not in self.obstacles:\n            self.obstacles.add((x, y))\n        else:\n            self.obstacles.remove((x, y))\n            self.updateVertex(node_change)\n\n        self.env.update(self.obstacles)\n\n        for node_n in self.getNeighbor(node_change):\n            self.updateVertex(node_n)\n\n        cost, path, _ = self.plan()\n\n        # animation\n        self.plot.clean()\n        self.plot.animation(path, str(self), cost, self.EXPAND)\n        self.plot.update()\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.calculateKey","title":"<code>calculateKey(node)</code>","text":"<p>Calculate priority of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LNode</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>key</code> <code>list</code> <p>priority of node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def calculateKey(self, node: LNode) -&gt; list:\n    \"\"\"\n    Calculate priority of node.\n\n    Parameters:\n        node (LNode): current node\n\n    Returns:\n        key (list): priority of node\n    \"\"\"\n    return [min(node.g, node.rhs) + self.h(node, self.goal),\n            min(node.g, node.rhs)]\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.computeShortestPath","title":"<code>computeShortestPath()</code>","text":"<p>Perceived dynamic obstacle information to optimize global path.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def computeShortestPath(self) -&gt; None:\n    \"\"\"\n    Perceived dynamic obstacle information to optimize global path.\n    \"\"\"\n    while True:\n        node = min(self.U, key=lambda node: node.key)\n        if node.key &gt;= self.calculateKey(self.goal) and \\\n                self.goal.rhs == self.goal.g:\n            break\n\n        self.U.remove(node)\n        self.EXPAND.append(node)\n\n        # Locally over-consistent -&gt; Locally consistent\n        if node.g &gt; node.rhs:\n            node.g = node.rhs\n        # Locally under-consistent -&gt; Locally over-consistent\n        else:\n            node.g = float(\"inf\")\n            self.updateVertex(node)\n\n        for node_n in self.getNeighbor(node):\n            self.updateVertex(node_n)\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.extractPath","title":"<code>extractPath()</code>","text":"<p>Extract the path based on greedy policy.</p> Return <p>cost (float): the cost of planning path path (list): the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def extractPath(self):\n    \"\"\"\n    Extract the path based on greedy policy.\n\n    Return:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    node = self.goal\n    path = [node.current]\n    cost, count = 0, 0\n    while node != self.start:\n        neighbors = [node_n for node_n in self.getNeighbor(node) if not self.isCollision(node, node_n)]\n        next_node = min(neighbors, key=lambda n: n.g)\n        path.append(next_node.current)\n        cost += self.cost(node, next_node)\n        node = next_node\n        count += 1\n        if count == 1000:\n            return cost, []\n    return cost, list(reversed(path))\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.getNeighbor","title":"<code>getNeighbor(node)</code>","text":"<p>Find neighbors of node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LNode</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>neighbors</code> <code>list</code> <p>neighbors of node</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def getNeighbor(self, node: LNode) -&gt; list:\n    \"\"\"\n    Find neighbors of node.\n\n    Parameters:\n        node (LNode): current node\n\n    Returns:\n        neighbors (list): neighbors of node\n    \"\"\"\n    neighbors = []\n    for motion in self.motions:\n        n = self.map[(node + motion).current]\n        if n.current not in self.obstacles:\n            neighbors.append(n)\n    return neighbors\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.plan","title":"<code>plan()</code>","text":"<p>LPA* dynamic motion planning function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>_</code> <code>None</code> <p>None</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    LPA* dynamic motion planning function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        _ (None): None\n    \"\"\"\n    self.computeShortestPath()\n    cost, path = self.extractPath()\n    return cost, path, None\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    # static planning\n    cost, path, _ = self.plan()\n\n    # animation\n    self.plot.connect('button_press_event', self.OnPress)\n    self.plot.animation(path, str(self), cost=cost)\n</code></pre>"},{"location":"global_planner/graph_search/lpa_star/LPAStar.html#src.python_motion_planning.global_planner.graph_search.lpa_star.LPAStar.updateVertex","title":"<code>updateVertex(node)</code>","text":"<p>Update the status and the current cost to node and it's neighbor.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>LNode</code> <p>current node</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\lpa_star.py</code> Python<pre><code>def updateVertex(self, node: LNode) -&gt; None:\n    \"\"\"\n    Update the status and the current cost to node and it's neighbor.\n\n    Parameters:\n        node (LNode): current node\n    \"\"\"\n    # greed correction\n    if node != self.start:\n        node.rhs = min([node_n.g + self.cost(node_n, node)\n                    for node_n in self.getNeighbor(node)])\n\n    if node in self.U:\n        self.U.remove(node)\n\n    # Locally unconsistent nodes should be added into OPEN set (set U)\n    if node.g != node.rhs:\n        node.key = self.calculateKey(node)\n        heapq.heappush(self.U, node)\n</code></pre>"},{"location":"global_planner/graph_search/s_theta_star/SThetaStar.html","title":"SThetaStar","text":""},{"location":"global_planner/graph_search/s_theta_star/SThetaStar.html#src.python_motion_planning.global_planner.graph_search.s_theta_star.SThetaStar","title":"<code>src.python_motion_planning.global_planner.graph_search.s_theta_star.SThetaStar</code>","text":"<p>               Bases: <code>ThetaStar</code></p> <p>Class for S-Theta* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.SThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] S-Theta*: low steering path-planning algorithm</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\s_theta_star.py</code> Python<pre><code>class SThetaStar(ThetaStar):\n    \"\"\"\n    Class for S-Theta* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.SThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] S-Theta*: low steering path-planning algorithm\n    \"\"\"\n\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"S-Theta*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        S-Theta* motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): all nodes that planner has searched\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):\n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                # path1\n                node_n.parent = node.current\n                node_n.h = self.h(node_n, self.goal)\n\n                alpha = 0.0\n                node_p = CLOSED.get(node.parent)\n                if node_p:\n                    alpha = self.getAlpha(node_p, node_n)\n                    node_n.g += alpha\n\n                if node_p:\n                    self.updateVertex(node_p, node_n, alpha)\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n\n    def updateVertex(self, node_p: Node, node_c: Node, alpha: float) -&gt; None:\n        \"\"\"\n        Update extend node information with current node's parent node.\n\n        Parameters:\n            node_p (Node): parent node\n            node_c (Node): current node\n            alpha (float): alpha angle\n        \"\"\"\n        # if alpha == 0 or self.lineOfSight(node_c, node_p):    # \"alpha == 0\" will cause the path to penetrate obstacles\n        if self.lineOfSight(node_c, node_p):\n            # path 2\n            new_g = node_p.g + self.dist(node_c, node_p) + alpha\n            if new_g &lt;= node_c.g:\n                node_c.g = new_g\n                node_c.parent = node_p.current\n\n    def getAlpha(self, node_p: Node, node_c: Node):\n        \"\"\"\n        \u03b1(t) represents the deviation in the trajectory to reach the goal node g\n        through the node t in relation to the straight-line distance between the parent of its\n        predecessor (t \u2208 succ(p) and parent(p) = q) and the goal node.\n\n        Parameters:\n            node_p (Node): parent node\n            node_c (Node): current node\n\n        Returns:\n            alpha (float): alpha angle\n        \"\"\"\n        d_qt = self.dist(node_p, node_c)\n        d_qg = self.dist(node_p, self.goal)\n        d_tg = self.dist(node_c, self.goal)\n        value = (d_qt * d_qt + d_qg * d_qg - d_tg * d_tg) / (2.0 * d_qt * d_qg)\n        value = max(-1.0, min(1.0, value))\n        cost = acos(value)\n        return cost\n</code></pre>"},{"location":"global_planner/graph_search/s_theta_star/SThetaStar.html#src.python_motion_planning.global_planner.graph_search.s_theta_star.SThetaStar.getAlpha","title":"<code>getAlpha(node_p, node_c)</code>","text":"<p>\u03b1(t) represents the deviation in the trajectory to reach the goal node g through the node t in relation to the straight-line distance between the parent of its predecessor (t \u2208 succ(p) and parent(p) = q) and the goal node.</p> <p>Parameters:</p> Name Type Description Default <code>node_p</code> <code>Node</code> <p>parent node</p> required <code>node_c</code> <code>Node</code> <p>current node</p> required <p>Returns:</p> Name Type Description <code>alpha</code> <code>float</code> <p>alpha angle</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\s_theta_star.py</code> Python<pre><code>def getAlpha(self, node_p: Node, node_c: Node):\n    \"\"\"\n    \u03b1(t) represents the deviation in the trajectory to reach the goal node g\n    through the node t in relation to the straight-line distance between the parent of its\n    predecessor (t \u2208 succ(p) and parent(p) = q) and the goal node.\n\n    Parameters:\n        node_p (Node): parent node\n        node_c (Node): current node\n\n    Returns:\n        alpha (float): alpha angle\n    \"\"\"\n    d_qt = self.dist(node_p, node_c)\n    d_qg = self.dist(node_p, self.goal)\n    d_tg = self.dist(node_c, self.goal)\n    value = (d_qt * d_qt + d_qg * d_qg - d_tg * d_tg) / (2.0 * d_qt * d_qg)\n    value = max(-1.0, min(1.0, value))\n    cost = acos(value)\n    return cost\n</code></pre>"},{"location":"global_planner/graph_search/s_theta_star/SThetaStar.html#src.python_motion_planning.global_planner.graph_search.s_theta_star.SThetaStar.plan","title":"<code>plan()</code>","text":"<p>S-Theta* motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>all nodes that planner has searched</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\s_theta_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    S-Theta* motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): all nodes that planner has searched\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):\n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            # path1\n            node_n.parent = node.current\n            node_n.h = self.h(node_n, self.goal)\n\n            alpha = 0.0\n            node_p = CLOSED.get(node.parent)\n            if node_p:\n                alpha = self.getAlpha(node_p, node_n)\n                node_n.g += alpha\n\n            if node_p:\n                self.updateVertex(node_p, node_n, alpha)\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/s_theta_star/SThetaStar.html#src.python_motion_planning.global_planner.graph_search.s_theta_star.SThetaStar.updateVertex","title":"<code>updateVertex(node_p, node_c, alpha)</code>","text":"<p>Update extend node information with current node's parent node.</p> <p>Parameters:</p> Name Type Description Default <code>node_p</code> <code>Node</code> <p>parent node</p> required <code>node_c</code> <code>Node</code> <p>current node</p> required <code>alpha</code> <code>float</code> <p>alpha angle</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\s_theta_star.py</code> Python<pre><code>def updateVertex(self, node_p: Node, node_c: Node, alpha: float) -&gt; None:\n    \"\"\"\n    Update extend node information with current node's parent node.\n\n    Parameters:\n        node_p (Node): parent node\n        node_c (Node): current node\n        alpha (float): alpha angle\n    \"\"\"\n    # if alpha == 0 or self.lineOfSight(node_c, node_p):    # \"alpha == 0\" will cause the path to penetrate obstacles\n    if self.lineOfSight(node_c, node_p):\n        # path 2\n        new_g = node_p.g + self.dist(node_c, node_p) + alpha\n        if new_g &lt;= node_c.g:\n            node_c.g = new_g\n            node_c.parent = node_p.current\n</code></pre>"},{"location":"global_planner/graph_search/theta_star/ThetaStar.html","title":"ThetaStar","text":""},{"location":"global_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.global_planner.graph_search.theta_star.ThetaStar","title":"<code>src.python_motion_planning.global_planner.graph_search.theta_star.ThetaStar</code>","text":"<p>               Bases: <code>AStar</code></p> <p>Class for Theta* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.ThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Theta*: Any-Angle Path Planning on Grids [2] Any-angle path planning on non-uniform costmaps</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\theta_star.py</code> Python<pre><code>class ThetaStar(AStar):\n    \"\"\"\n    Class for Theta* motion planning.\n\n    Parameters:\n        start (tuple):\n            start point coordinate\n        goal (tuple):\n            goal point coordinate\n        env (Env):\n            environment\n        heuristic_type (str):\n            heuristic function type\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.ThetaStar((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Theta*: Any-Angle Path Planning on Grids\n        [2] Any-angle path planning on non-uniform costmaps\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\") -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n\n    def __str__(self) -&gt; str:\n        return \"Theta*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Theta* motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): all nodes that planner has searched\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                cost, path = self.extractPath(CLOSED)\n                return cost, path, list(CLOSED.values())\n\n            for node_n in self.getNeighbor(node):                \n                # exists in CLOSED list\n                if node_n.current in CLOSED:\n                    continue\n\n                # path1\n                node_n.parent = node.current\n                node_n.h = self.h(node_n, self.goal)\n\n                node_p = CLOSED.get(node.parent)\n\n                if node_p:\n                    self.updateVertex(node_p, node_n)\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN list\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], [], []\n\n    def updateVertex(self, node_p: Node, node_c: Node) -&gt; None:\n        \"\"\"\n        Update extend node information with current node's parent node.\n\n        Parameters:\n            node_p (Node): parent node\n            node_c (Node): current node\n        \"\"\"\n        if self.lineOfSight(node_c, node_p):\n            # path 2\n            if node_p.g + self.dist(node_c, node_p) &lt;= node_c.g:\n                node_c.g = node_p.g + self.dist(node_c, node_p)\n                node_c.parent = node_p.current\n\n    def lineOfSight(self, node1: Node, node2: Node) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2 using Bresenham.\n\n        Parameters:\n            node1 (Node): start node\n            node2 (Node): end node\n\n        Returns:\n            line_of_sight (bool): True if line of sight exists ( no collision ) else False\n        \"\"\"\n        if node1.current in self.obstacles or node2.current in self.obstacles:\n            return False\n\n        x1, y1 = node1.current\n        x2, y2 = node2.current\n\n        if x1 &lt; 0 or x1 &gt;= self.env.x_range or y1 &lt; 0 or y1 &gt;= self.env.y_range:\n            return False\n        if x2 &lt; 0 or x2 &gt;= self.env.x_range or y2 &lt; 0 or y2 &gt;= self.env.y_range:\n            return False\n\n        d_x = abs(x2 - x1)\n        d_y = abs(y2 - y1)\n        s_x = 0 if (x2 - x1) == 0 else (x2 - x1) / d_x\n        s_y = 0 if (y2 - y1) == 0 else (y2 - y1) / d_y\n        x, y, e = x1, y1, 0\n\n        # check if any obstacle exists between node1 and node2\n        if d_x &gt; d_y:\n            tau = (d_y - d_x) / 2\n            while not x == x2:\n                if e &gt; tau:\n                    x = x + s_x\n                    e = e - d_y\n                elif e &lt; tau:\n                    y = y + s_y\n                    e = e + d_x\n                else:\n                    x = x + s_x\n                    y = y + s_y\n                    e = e + d_x - d_y\n                if (x, y) in self.obstacles:\n                    return False\n        # swap x and y\n        else:\n            tau = (d_x - d_y) / 2\n            while not y == y2:\n                if e &gt; tau:\n                    y = y + s_y\n                    e = e - d_x\n                elif e &lt; tau:\n                    x = x + s_x\n                    e = e + d_y\n                else:\n                    x = x + s_x\n                    y = y + s_y\n                    e = e + d_y - d_x\n                if (x, y) in self.obstacles:\n                    return False\n\n        return True\n</code></pre>"},{"location":"global_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.global_planner.graph_search.theta_star.ThetaStar.lineOfSight","title":"<code>lineOfSight(node1, node2)</code>","text":"<p>Judge collision when moving from node1 to node2 using Bresenham.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>start node</p> required <code>node2</code> <code>Node</code> <p>end node</p> required <p>Returns:</p> Name Type Description <code>line_of_sight</code> <code>bool</code> <p>True if line of sight exists ( no collision ) else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\theta_star.py</code> Python<pre><code>def lineOfSight(self, node1: Node, node2: Node) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2 using Bresenham.\n\n    Parameters:\n        node1 (Node): start node\n        node2 (Node): end node\n\n    Returns:\n        line_of_sight (bool): True if line of sight exists ( no collision ) else False\n    \"\"\"\n    if node1.current in self.obstacles or node2.current in self.obstacles:\n        return False\n\n    x1, y1 = node1.current\n    x2, y2 = node2.current\n\n    if x1 &lt; 0 or x1 &gt;= self.env.x_range or y1 &lt; 0 or y1 &gt;= self.env.y_range:\n        return False\n    if x2 &lt; 0 or x2 &gt;= self.env.x_range or y2 &lt; 0 or y2 &gt;= self.env.y_range:\n        return False\n\n    d_x = abs(x2 - x1)\n    d_y = abs(y2 - y1)\n    s_x = 0 if (x2 - x1) == 0 else (x2 - x1) / d_x\n    s_y = 0 if (y2 - y1) == 0 else (y2 - y1) / d_y\n    x, y, e = x1, y1, 0\n\n    # check if any obstacle exists between node1 and node2\n    if d_x &gt; d_y:\n        tau = (d_y - d_x) / 2\n        while not x == x2:\n            if e &gt; tau:\n                x = x + s_x\n                e = e - d_y\n            elif e &lt; tau:\n                y = y + s_y\n                e = e + d_x\n            else:\n                x = x + s_x\n                y = y + s_y\n                e = e + d_x - d_y\n            if (x, y) in self.obstacles:\n                return False\n    # swap x and y\n    else:\n        tau = (d_x - d_y) / 2\n        while not y == y2:\n            if e &gt; tau:\n                y = y + s_y\n                e = e - d_x\n            elif e &lt; tau:\n                x = x + s_x\n                e = e + d_y\n            else:\n                x = x + s_x\n                y = y + s_y\n                e = e + d_y - d_x\n            if (x, y) in self.obstacles:\n                return False\n\n    return True\n</code></pre>"},{"location":"global_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.global_planner.graph_search.theta_star.ThetaStar.plan","title":"<code>plan()</code>","text":"<p>Theta* motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>all nodes that planner has searched</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\theta_star.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Theta* motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): all nodes that planner has searched\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            cost, path = self.extractPath(CLOSED)\n            return cost, path, list(CLOSED.values())\n\n        for node_n in self.getNeighbor(node):                \n            # exists in CLOSED list\n            if node_n.current in CLOSED:\n                continue\n\n            # path1\n            node_n.parent = node.current\n            node_n.h = self.h(node_n, self.goal)\n\n            node_p = CLOSED.get(node.parent)\n\n            if node_p:\n                self.updateVertex(node_p, node_n)\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN list\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], [], []\n</code></pre>"},{"location":"global_planner/graph_search/theta_star/ThetaStar.html#src.python_motion_planning.global_planner.graph_search.theta_star.ThetaStar.updateVertex","title":"<code>updateVertex(node_p, node_c)</code>","text":"<p>Update extend node information with current node's parent node.</p> <p>Parameters:</p> Name Type Description Default <code>node_p</code> <code>Node</code> <p>parent node</p> required <code>node_c</code> <code>Node</code> <p>current node</p> required Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\theta_star.py</code> Python<pre><code>def updateVertex(self, node_p: Node, node_c: Node) -&gt; None:\n    \"\"\"\n    Update extend node information with current node's parent node.\n\n    Parameters:\n        node_p (Node): parent node\n        node_c (Node): current node\n    \"\"\"\n    if self.lineOfSight(node_c, node_p):\n        # path 2\n        if node_p.g + self.dist(node_c, node_p) &lt;= node_c.g:\n            node_c.g = node_p.g + self.dist(node_c, node_p)\n            node_c.parent = node_p.current\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html","title":"VoronoiPlanner","text":""},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner","title":"<code>src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner</code>","text":"<p>               Bases: <code>GraphSearcher</code></p> <p>Class for Voronoi-based motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type, default is euclidean</p> <code>'euclidean'</code> <code>n_knn</code> <code>int</code> <p>number of edges from one sampled point</p> <code>10</code> <code>max_edge_len</code> <code>float</code> <p>maximum edge length</p> <code>10.0</code> <code>inflation_r</code> <code>float</code> <p>inflation range</p> <code>1.0</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.VoronoiPlanner((5, 5), (45, 25), pmp.Grid(51, 31))\n&gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>class VoronoiPlanner(GraphSearcher):\n    \"\"\"\n    Class for Voronoi-based motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type, default is euclidean\n        n_knn (int): number of edges from one sampled point\n        max_edge_len (float): maximum edge length\n        inflation_r (float): inflation range\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.VoronoiPlanner((5, 5), (45, 25), pmp.Grid(51, 31))\n        &gt;&gt;&gt; cost, path, _ = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", \\\n                 n_knn: int = 10, max_edge_len: float = 10.0, inflation_r: float = 1.0) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type)\n        # number of edges from one sampled point\n        self.n_knn = n_knn\n        # maximum edge length\n        self.max_edge_len = max_edge_len\n        # inflation range\n        self.inflation_r = inflation_r\n\n    def __str__(self) -&gt; str:\n        return \"Voronoi-based Planner\"\n\n    def plan(self):\n        \"\"\"\n        Voronoi-based motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): voronoi sampled nodes\n        \"\"\"\n        # sampling voronoi diagram\n        vor = Voronoi(np.array(list(self.env.obstacles)))\n        vx_list = [ix for [ix, _] in vor.vertices] + [self.start.x, self.goal.x]\n        vy_list = [iy for [_, iy] in vor.vertices] + [self.start.y, self.goal.y]\n        sample_num = len(vx_list)\n        expand = [Node((vx_list[i], vy_list[i])) for i in range(sample_num)]\n\n        # generate road map for voronoi nodes\n        road_map = {}\n        node_tree = cKDTree(np.vstack((vx_list, vy_list)).T)\n\n        for node in expand:\n            edges = []\n            _, index_list = node_tree.query([node.x, node.y], k=sample_num)\n\n            for i in range(1, len(index_list)):\n                node_n = expand[index_list[i]]\n\n                if not self.isCollision(node, node_n):\n                    edges.append(node_n)\n\n                if len(edges) &gt;= self.n_knn:\n                    break\n\n            road_map[node] = edges\n\n        # calculate shortest path using graph search algorithm\n        cost, path = self.getShortestPath(road_map)\n        return cost, path, expand\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        cost, path, expand = self.plan()\n        self.plot.animation(path, str(self), cost, expand)\n\n    def getShortestPath(self, road_map: dict, dijkstra: bool = True) -&gt; list:\n        \"\"\"\n        Calculate shortest path using graph search algorithm(A*, Dijkstra, etc).\n\n        Parameters:\n            road_map (dict): road map for voronoi diagram, which store KNN for one voronoi node\n            dijkstra (bool): using Dijkstra if true, else A*\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n        \"\"\"\n        # OPEN list (priority queue) and CLOSED list (hash table)\n        OPEN = []\n        heapq.heappush(OPEN, self.start)\n        CLOSED = dict()\n\n        while OPEN:\n            node = heapq.heappop(OPEN)\n\n            # exists in CLOSED list\n            if node.current in CLOSED:\n                continue\n\n            # goal found\n            if node == self.goal:\n                CLOSED[node.current] = node\n                return self.extractPath(CLOSED)\n\n            for node_n in road_map[node]:                \n                # exists in CLOSED set\n                if node_n.current in CLOSED:\n                    continue\n\n                node_n.parent = node.current\n                node_n.g = self.dist(node_n, node)\n                if not dijkstra:\n                    node_n.h = self.h(node_n, self.goal)\n\n                # goal found\n                if node_n == self.goal:\n                    heapq.heappush(OPEN, node_n)\n                    break\n\n                # update OPEN set\n                heapq.heappush(OPEN, node_n)\n\n            CLOSED[node.current] = node\n        return [], []\n\n    def extractPath(self, closed_list: dict):\n        \"\"\"\n        Extract the path based on the CLOSED list.\n\n        Parameters:\n            closed_list (dict): CLOSED list\n\n        Returns:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        cost = 0\n        node = closed_list[self.goal.current]\n        path = [node.current]\n        while node != self.start:\n            node_parent = closed_list[node.parent]\n            cost += self.dist(node, node_parent)\n            node = node_parent\n            path.append(node.current)\n        return cost, path\n\n    def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2.\n\n        Parameters:\n            node1 (Node): start node\n            node2 (Node): end node\n\n        Returns:\n            collision (bool): True if collision exists else False\n        \"\"\"\n        if node1.current in self.obstacles or node2.current in self.obstacles:\n            return True\n\n        yaw = self.angle(node1, node2)\n        dist = self.dist(node1, node2)\n\n        if dist &gt;= self.max_edge_len:\n            return True\n\n        d_dist = self.inflation_r\n        n_step = round(dist / d_dist)\n\n        x, y = node1.current\n        for _ in range(n_step):\n            dist_to_obs, _ = self.env.obstacles_tree.query([x, y])\n            if dist_to_obs &lt;= self.inflation_r:\n                return True\n            x += d_dist * math.cos(yaw)\n            y += d_dist * math.sin(yaw)\n\n        # goal point check\n        dist_to_obs, _ = self.env.obstacles_tree.query(node2.current)\n        if dist_to_obs &lt;= self.inflation_r:\n            return True\n\n        return False\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner.extractPath","title":"<code>extractPath(closed_list)</code>","text":"<p>Extract the path based on the CLOSED list.</p> <p>Parameters:</p> Name Type Description Default <code>closed_list</code> <code>dict</code> <p>CLOSED list</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planning path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>def extractPath(self, closed_list: dict):\n    \"\"\"\n    Extract the path based on the CLOSED list.\n\n    Parameters:\n        closed_list (dict): CLOSED list\n\n    Returns:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    cost = 0\n    node = closed_list[self.goal.current]\n    path = [node.current]\n    while node != self.start:\n        node_parent = closed_list[node.parent]\n        cost += self.dist(node, node_parent)\n        node = node_parent\n        path.append(node.current)\n    return cost, path\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner.getShortestPath","title":"<code>getShortestPath(road_map, dijkstra=True)</code>","text":"<p>Calculate shortest path using graph search algorithm(A*, Dijkstra, etc).</p> <p>Parameters:</p> Name Type Description Default <code>road_map</code> <code>dict</code> <p>road map for voronoi diagram, which store KNN for one voronoi node</p> required <code>dijkstra</code> <code>bool</code> <p>using Dijkstra if true, else A*</p> <code>True</code> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>def getShortestPath(self, road_map: dict, dijkstra: bool = True) -&gt; list:\n    \"\"\"\n    Calculate shortest path using graph search algorithm(A*, Dijkstra, etc).\n\n    Parameters:\n        road_map (dict): road map for voronoi diagram, which store KNN for one voronoi node\n        dijkstra (bool): using Dijkstra if true, else A*\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n    \"\"\"\n    # OPEN list (priority queue) and CLOSED list (hash table)\n    OPEN = []\n    heapq.heappush(OPEN, self.start)\n    CLOSED = dict()\n\n    while OPEN:\n        node = heapq.heappop(OPEN)\n\n        # exists in CLOSED list\n        if node.current in CLOSED:\n            continue\n\n        # goal found\n        if node == self.goal:\n            CLOSED[node.current] = node\n            return self.extractPath(CLOSED)\n\n        for node_n in road_map[node]:                \n            # exists in CLOSED set\n            if node_n.current in CLOSED:\n                continue\n\n            node_n.parent = node.current\n            node_n.g = self.dist(node_n, node)\n            if not dijkstra:\n                node_n.h = self.h(node_n, self.goal)\n\n            # goal found\n            if node_n == self.goal:\n                heapq.heappush(OPEN, node_n)\n                break\n\n            # update OPEN set\n            heapq.heappush(OPEN, node_n)\n\n        CLOSED[node.current] = node\n    return [], []\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner.isCollision","title":"<code>isCollision(node1, node2)</code>","text":"<p>Judge collision when moving from node1 to node2.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>start node</p> required <code>node2</code> <code>Node</code> <p>end node</p> required <p>Returns:</p> Name Type Description <code>collision</code> <code>bool</code> <p>True if collision exists else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2.\n\n    Parameters:\n        node1 (Node): start node\n        node2 (Node): end node\n\n    Returns:\n        collision (bool): True if collision exists else False\n    \"\"\"\n    if node1.current in self.obstacles or node2.current in self.obstacles:\n        return True\n\n    yaw = self.angle(node1, node2)\n    dist = self.dist(node1, node2)\n\n    if dist &gt;= self.max_edge_len:\n        return True\n\n    d_dist = self.inflation_r\n    n_step = round(dist / d_dist)\n\n    x, y = node1.current\n    for _ in range(n_step):\n        dist_to_obs, _ = self.env.obstacles_tree.query([x, y])\n        if dist_to_obs &lt;= self.inflation_r:\n            return True\n        x += d_dist * math.cos(yaw)\n        y += d_dist * math.sin(yaw)\n\n    # goal point check\n    dist_to_obs, _ = self.env.obstacles_tree.query(node2.current)\n    if dist_to_obs &lt;= self.inflation_r:\n        return True\n\n    return False\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner.plan","title":"<code>plan()</code>","text":"<p>Voronoi-based motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>voronoi sampled nodes</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    Voronoi-based motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): voronoi sampled nodes\n    \"\"\"\n    # sampling voronoi diagram\n    vor = Voronoi(np.array(list(self.env.obstacles)))\n    vx_list = [ix for [ix, _] in vor.vertices] + [self.start.x, self.goal.x]\n    vy_list = [iy for [_, iy] in vor.vertices] + [self.start.y, self.goal.y]\n    sample_num = len(vx_list)\n    expand = [Node((vx_list[i], vy_list[i])) for i in range(sample_num)]\n\n    # generate road map for voronoi nodes\n    road_map = {}\n    node_tree = cKDTree(np.vstack((vx_list, vy_list)).T)\n\n    for node in expand:\n        edges = []\n        _, index_list = node_tree.query([node.x, node.y], k=sample_num)\n\n        for i in range(1, len(index_list)):\n            node_n = expand[index_list[i]]\n\n            if not self.isCollision(node, node_n):\n                edges.append(node_n)\n\n            if len(edges) &gt;= self.n_knn:\n                break\n\n        road_map[node] = edges\n\n    # calculate shortest path using graph search algorithm\n    cost, path = self.getShortestPath(road_map)\n    return cost, path, expand\n</code></pre>"},{"location":"global_planner/graph_search/voronoi/VoronoiPlanner.html#src.python_motion_planning.global_planner.graph_search.voronoi.VoronoiPlanner.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\graph_search\\voronoi.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    cost, path, expand = self.plan()\n    self.plot.animation(path, str(self), cost, expand)\n</code></pre>"},{"location":"global_planner/sample_search/informed_rrt/Ellipse.html","title":"Ellipse","text":""},{"location":"global_planner/sample_search/informed_rrt/Ellipse.html#src.python_motion_planning.global_planner.sample_search.informed_rrt.Ellipse","title":"<code>src.python_motion_planning.global_planner.sample_search.informed_rrt.Ellipse</code>","text":"<p>Ellipse sampling.</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\informed_rrt.py</code> Python<pre><code>class Ellipse:\n    \"\"\"\n    Ellipse sampling.\n    \"\"\"\n    @staticmethod\n    def transform(a: float, c: float, p1: tuple, p2: tuple) -&gt; np.ndarray:\n        # center\n        center_x = (p1[0] + p2[0]) / 2\n        center_y = (p1[1] + p2[1]) / 2\n\n        # rotation\n        theta = - np.arctan2(p2[1] - p1[1], p2[0] - p1[0])\n\n        # transform\n        b = np.sqrt(a ** 2 - c ** 2)\n        T = np.array([[ a * np.cos(theta), b * np.sin(theta), center_x],\n                      [-a * np.sin(theta), b * np.cos(theta), center_y],\n                      [                 0,                 0,        1]])\n        return T\n</code></pre>"},{"location":"global_planner/sample_search/informed_rrt/InformedRRT.html","title":"InformedRRT","text":""},{"location":"global_planner/sample_search/informed_rrt/InformedRRT.html#src.python_motion_planning.global_planner.sample_search.informed_rrt.InformedRRT","title":"<code>src.python_motion_planning.global_planner.sample_search.informed_rrt.InformedRRT</code>","text":"<p>               Bases: <code>RRTStar</code></p> <p>Class for Informed RRT* motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>max_dist</code> <code>float</code> <p>Maximum expansion distance one step</p> <code>0.5</code> <code>sample_num</code> <code>int</code> <p>Maximum number of sample points</p> <code>1500</code> <code>r</code> <code>float</code> <p>optimization radius</p> <code>12.0</code> <code>goal_sample_rate</code> <code>float</code> <p>heuristic sample</p> <code>0.05</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.InformedRRT((5, 5), (45, 25), pmp.Map(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Optimal Sampling-based Path Planning Focused via Direct Sampling of an Admissible Ellipsoidal heuristic</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\informed_rrt.py</code> Python<pre><code>class InformedRRT(RRTStar):\n    \"\"\"\n    Class for Informed RRT* motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        max_dist (float): Maximum expansion distance one step\n        sample_num (int): Maximum number of sample points\n        r (float): optimization radius\n        goal_sample_rate (float): heuristic sample\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.InformedRRT((5, 5), (45, 25), pmp.Map(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Optimal Sampling-based Path Planning Focused via Direct Sampling of an Admissible Ellipsoidal heuristic\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, max_dist: float = 0.5,\n                 sample_num: int = 1500, r: float = 12.0, goal_sample_rate: float = 0.05) -&gt; None:\n        super().__init__(start, goal, env, max_dist, sample_num, goal_sample_rate)\n        # optimization radius\n        self.r = r\n        # best planning cost\n        self.c_best = float(\"inf\")\n        # distance between start and goal\n        self.c_min = self.dist(self.start, self.goal)\n        # ellipse sampling\n        self.transform = partial(Ellipse.transform, c=self.c_min / 2, p1=start, p2=goal)\n\n    def __str__(self) -&gt; str:\n        return \"Informed RRT*\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Informed-RRT* motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): expanded (sampled) nodes list\n        \"\"\"\n        # Sampled list\n        sample_list = {self.start.current: self.start}\n\n        best_cost, best_path = float(\"inf\"), None\n\n        # main loop\n        for i in range(self.sample_num):\n            # generate a random node in the map\n            node_rand = self.generateRandomNode()\n\n            # visited\n            if node_rand.current in sample_list:\n                continue\n\n            # generate new node\n            node_new = self.getNearest(list(sample_list.values()), node_rand)\n            if node_new:\n                sample_list[node_new.current] = node_new\n                dist = self.dist(node_new, self.goal)\n                # goal found\n                if dist &lt;= self.max_dist and not self.isCollision(node_new, self.goal):\n                    self.goal.parent = node_new.current\n                    self.goal.g = node_new.g + self.dist(self.goal, node_new)\n                    sample_list[self.goal.current] = self.goal\n                    cost, path = self.extractPath(sample_list)\n                    if path and cost &lt; best_cost:\n                        best_cost, best_path = cost, path\n                        self.c_best = best_cost\n\n        return best_cost, best_path, list(sample_list.values())\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        cost, path, expand = self.plan()\n        t = np.arange(0, 2 * np.pi + 0.1, 0.1)\n        x = [np.cos(it) for it in t]\n        y = [np.sin(it) for it in t]\n        z = [1 for _ in t]\n        fx = self.transform(self.c_best / 2) @ np.array([x, y, z])\n        fx[0, :] += x\n        fx[1, :] += y\n        self.plot.animation(path, str(self), cost, expand, ellipse=fx)\n\n    def generateRandomNode(self) -&gt; Node:\n        \"\"\"\n        Generate a random node to extend exploring tree.\n\n        Returns:\n            node (Node): a random node based on sampling\n        \"\"\"\n        # ellipse sample\n        if self.c_best &lt; float(\"inf\"):\n            while True:\n                # unit ball sample\n                p = np.array([.0, .0, 1.])\n                while True:\n                    x, y = np.random.uniform(-1, 1), np.random.uniform(-1, 1)\n                    if x ** 2 + y ** 2 &lt; 1:\n                        p[0], p[1] = x, y\n                        break\n                # transform to ellipse\n                p_star = self.transform(self.c_best / 2) @ p.T\n                if self.delta &lt;= p_star[0] &lt;= self.env.x_range - self.delta and \\\n                   self.delta &lt;= p_star[1] &lt;= self.env.y_range - self.delta:\n                    return Node((p_star[0], p_star[1]), None, 0, 0)\n        # random sample\n        else:\n            return super().generateRandomNode()\n</code></pre>"},{"location":"global_planner/sample_search/informed_rrt/InformedRRT.html#src.python_motion_planning.global_planner.sample_search.informed_rrt.InformedRRT.generateRandomNode","title":"<code>generateRandomNode()</code>","text":"<p>Generate a random node to extend exploring tree.</p> <p>Returns:</p> Name Type Description <code>node</code> <code>Node</code> <p>a random node based on sampling</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\informed_rrt.py</code> Python<pre><code>def generateRandomNode(self) -&gt; Node:\n    \"\"\"\n    Generate a random node to extend exploring tree.\n\n    Returns:\n        node (Node): a random node based on sampling\n    \"\"\"\n    # ellipse sample\n    if self.c_best &lt; float(\"inf\"):\n        while True:\n            # unit ball sample\n            p = np.array([.0, .0, 1.])\n            while True:\n                x, y = np.random.uniform(-1, 1), np.random.uniform(-1, 1)\n                if x ** 2 + y ** 2 &lt; 1:\n                    p[0], p[1] = x, y\n                    break\n            # transform to ellipse\n            p_star = self.transform(self.c_best / 2) @ p.T\n            if self.delta &lt;= p_star[0] &lt;= self.env.x_range - self.delta and \\\n               self.delta &lt;= p_star[1] &lt;= self.env.y_range - self.delta:\n                return Node((p_star[0], p_star[1]), None, 0, 0)\n    # random sample\n    else:\n        return super().generateRandomNode()\n</code></pre>"},{"location":"global_planner/sample_search/informed_rrt/InformedRRT.html#src.python_motion_planning.global_planner.sample_search.informed_rrt.InformedRRT.plan","title":"<code>plan()</code>","text":"<p>Informed-RRT* motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>expanded (sampled) nodes list</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\informed_rrt.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Informed-RRT* motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): expanded (sampled) nodes list\n    \"\"\"\n    # Sampled list\n    sample_list = {self.start.current: self.start}\n\n    best_cost, best_path = float(\"inf\"), None\n\n    # main loop\n    for i in range(self.sample_num):\n        # generate a random node in the map\n        node_rand = self.generateRandomNode()\n\n        # visited\n        if node_rand.current in sample_list:\n            continue\n\n        # generate new node\n        node_new = self.getNearest(list(sample_list.values()), node_rand)\n        if node_new:\n            sample_list[node_new.current] = node_new\n            dist = self.dist(node_new, self.goal)\n            # goal found\n            if dist &lt;= self.max_dist and not self.isCollision(node_new, self.goal):\n                self.goal.parent = node_new.current\n                self.goal.g = node_new.g + self.dist(self.goal, node_new)\n                sample_list[self.goal.current] = self.goal\n                cost, path = self.extractPath(sample_list)\n                if path and cost &lt; best_cost:\n                    best_cost, best_path = cost, path\n                    self.c_best = best_cost\n\n    return best_cost, best_path, list(sample_list.values())\n</code></pre>"},{"location":"global_planner/sample_search/informed_rrt/InformedRRT.html#src.python_motion_planning.global_planner.sample_search.informed_rrt.InformedRRT.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\informed_rrt.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    cost, path, expand = self.plan()\n    t = np.arange(0, 2 * np.pi + 0.1, 0.1)\n    x = [np.cos(it) for it in t]\n    y = [np.sin(it) for it in t]\n    z = [1 for _ in t]\n    fx = self.transform(self.c_best / 2) @ np.array([x, y, z])\n    fx[0, :] += x\n    fx[1, :] += y\n    self.plot.animation(path, str(self), cost, expand, ellipse=fx)\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html","title":"RRT","text":""},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT","title":"<code>src.python_motion_planning.global_planner.sample_search.rrt.RRT</code>","text":"<p>               Bases: <code>SampleSearcher</code></p> <p>Class for RRT motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>max_dist</code> <code>float</code> <p>Maximum expansion distance one step</p> <code>0.5</code> <code>sample_num</code> <code>int</code> <p>Maximum number of sample points</p> <code>10000</code> <code>goal_sample_rate</code> <code>float</code> <p>heuristic sample</p> <code>0.05</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.RRT((5, 5), (45, 25), pmp.Map(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Rapidly-Exploring Random Trees: A New Tool for Path Planning</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>class RRT(SampleSearcher):\n    \"\"\"\n    Class for RRT motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        max_dist (float): Maximum expansion distance one step\n        sample_num (int): Maximum number of sample points\n        goal_sample_rate (float): heuristic sample\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.RRT((5, 5), (45, 25), pmp.Map(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Rapidly-Exploring Random Trees: A New Tool for Path Planning\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, max_dist: float = 0.5,\n        sample_num: int = 10000, goal_sample_rate: float = 0.05) -&gt; None:\n        super().__init__(start, goal, env)\n        # Maximum expansion distance one step\n        self.max_dist = max_dist\n        # Maximum number of sample points\n        self.sample_num = sample_num\n        # heuristic sample\n        self.goal_sample_rate = goal_sample_rate\n\n    def __str__(self) -&gt; str:\n        return \"Rapidly-exploring Random Tree(RRT)\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        RRT motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): expanded (sampled) nodes list\n        \"\"\"\n        # Sampled list\n        sample_list = {self.start.current: self.start}\n\n        # main loop\n        for _ in range(self.sample_num):\n            # generate a random node in the map\n            node_rand = self.generateRandomNode()\n\n            # visited\n            if node_rand.current in sample_list:\n                continue\n\n            # generate new node\n            node_new = self.getNearest(list(sample_list.values()), node_rand)\n            if node_new:\n                sample_list[node_new.current] = node_new\n                dist = self.dist(node_new, self.goal)\n                # goal found\n                if dist &lt;= self.max_dist and not self.isCollision(node_new, self.goal):\n                    self.goal.parent = node_new.current\n                    self.goal.g = node_new.g + self.dist(self.goal, node_new)\n                    sample_list[self.goal.current] = self.goal\n                    cost, path = self.extractPath(sample_list)\n                    return cost, path, list(sample_list.values())\n\n        return 0, None, list(sample_list.values())\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        cost, path, expand = self.plan()\n        self.plot.animation(path, str(self), cost, expand)\n\n    def generateRandomNode(self) -&gt; Node:\n        \"\"\"\n        Generate a random node to extend exploring tree.\n\n        Returns:\n            node (Node): a random node based on sampling\n        \"\"\"\n        if np.random.random() &gt; self.goal_sample_rate:\n            current = (np.random.uniform(self.delta, self.env.x_range - self.delta),\n                    np.random.uniform(self.delta, self.env.y_range - self.delta))\n            return Node(current, None, 0, 0)\n        return self.goal\n\n    def getNearest(self, node_list: list, node: Node) -&gt; Node:\n        \"\"\"\n        Get the node from `node_list` that is nearest to `node`.\n\n        Parameters:\n            node_list (list): exploring list\n            node (Node): currently generated node\n\n        Returns:\n            node (Node): nearest node\n        \"\"\"\n        # find nearest neighbor\n        dist = [self.dist(node, nd) for nd in node_list]\n        node_near = node_list[int(np.argmin(dist))]\n\n        # regular and generate new node\n        dist, theta = self.dist(node_near, node), self.angle(node_near, node)\n        dist = min(self.max_dist, dist)\n        node_new = Node((node_near.x + dist * math.cos(theta),\n                        (node_near.y + dist * math.sin(theta))),\n                         node_near.current, node_near.g + dist, 0)\n\n        # obstacle check\n        if self.isCollision(node_new, node_near):\n            return None\n        return node_new\n\n    def extractPath(self, closed_list: dict) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED list.\n\n        Parameters:\n            closed_list (dict): CLOSED list\n\n        Returns\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        node = closed_list[self.goal.current]\n        path = [node.current]\n        cost = node.g\n        while node != self.start:\n            node_parent = closed_list[node.parent]\n            node = node_parent\n            path.append(node.current)\n\n        return cost, path\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT.extractPath","title":"<code>extractPath(closed_list)</code>","text":"<p>Extract the path based on the CLOSED list.</p> <p>Parameters:</p> Name Type Description Default <code>closed_list</code> <code>dict</code> <p>CLOSED list</p> required <p>Returns     cost (float): the cost of planning path     path (list): the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>def extractPath(self, closed_list: dict) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED list.\n\n    Parameters:\n        closed_list (dict): CLOSED list\n\n    Returns\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    node = closed_list[self.goal.current]\n    path = [node.current]\n    cost = node.g\n    while node != self.start:\n        node_parent = closed_list[node.parent]\n        node = node_parent\n        path.append(node.current)\n\n    return cost, path\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT.generateRandomNode","title":"<code>generateRandomNode()</code>","text":"<p>Generate a random node to extend exploring tree.</p> <p>Returns:</p> Name Type Description <code>node</code> <code>Node</code> <p>a random node based on sampling</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>def generateRandomNode(self) -&gt; Node:\n    \"\"\"\n    Generate a random node to extend exploring tree.\n\n    Returns:\n        node (Node): a random node based on sampling\n    \"\"\"\n    if np.random.random() &gt; self.goal_sample_rate:\n        current = (np.random.uniform(self.delta, self.env.x_range - self.delta),\n                np.random.uniform(self.delta, self.env.y_range - self.delta))\n        return Node(current, None, 0, 0)\n    return self.goal\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT.getNearest","title":"<code>getNearest(node_list, node)</code>","text":"<p>Get the node from <code>node_list</code> that is nearest to <code>node</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node_list</code> <code>list</code> <p>exploring list</p> required <code>node</code> <code>Node</code> <p>currently generated node</p> required <p>Returns:</p> Name Type Description <code>node</code> <code>Node</code> <p>nearest node</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>def getNearest(self, node_list: list, node: Node) -&gt; Node:\n    \"\"\"\n    Get the node from `node_list` that is nearest to `node`.\n\n    Parameters:\n        node_list (list): exploring list\n        node (Node): currently generated node\n\n    Returns:\n        node (Node): nearest node\n    \"\"\"\n    # find nearest neighbor\n    dist = [self.dist(node, nd) for nd in node_list]\n    node_near = node_list[int(np.argmin(dist))]\n\n    # regular and generate new node\n    dist, theta = self.dist(node_near, node), self.angle(node_near, node)\n    dist = min(self.max_dist, dist)\n    node_new = Node((node_near.x + dist * math.cos(theta),\n                    (node_near.y + dist * math.sin(theta))),\n                     node_near.current, node_near.g + dist, 0)\n\n    # obstacle check\n    if self.isCollision(node_new, node_near):\n        return None\n    return node_new\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT.plan","title":"<code>plan()</code>","text":"<p>RRT motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>expanded (sampled) nodes list</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    RRT motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): expanded (sampled) nodes list\n    \"\"\"\n    # Sampled list\n    sample_list = {self.start.current: self.start}\n\n    # main loop\n    for _ in range(self.sample_num):\n        # generate a random node in the map\n        node_rand = self.generateRandomNode()\n\n        # visited\n        if node_rand.current in sample_list:\n            continue\n\n        # generate new node\n        node_new = self.getNearest(list(sample_list.values()), node_rand)\n        if node_new:\n            sample_list[node_new.current] = node_new\n            dist = self.dist(node_new, self.goal)\n            # goal found\n            if dist &lt;= self.max_dist and not self.isCollision(node_new, self.goal):\n                self.goal.parent = node_new.current\n                self.goal.g = node_new.g + self.dist(self.goal, node_new)\n                sample_list[self.goal.current] = self.goal\n                cost, path = self.extractPath(sample_list)\n                return cost, path, list(sample_list.values())\n\n    return 0, None, list(sample_list.values())\n</code></pre>"},{"location":"global_planner/sample_search/rrt/RRT.html#src.python_motion_planning.global_planner.sample_search.rrt.RRT.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    cost, path, expand = self.plan()\n    self.plot.animation(path, str(self), cost, expand)\n</code></pre>"},{"location":"global_planner/sample_search/rrt_connect/RRTConnect.html","title":"RRTConnect","text":""},{"location":"global_planner/sample_search/rrt_connect/RRTConnect.html#src.python_motion_planning.global_planner.sample_search.rrt_connect.RRTConnect","title":"<code>src.python_motion_planning.global_planner.sample_search.rrt_connect.RRTConnect</code>","text":"<p>               Bases: <code>RRT</code></p> <p>Class for RRT-Connect motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>max_dist</code> <code>float</code> <p>Maximum expansion distance one step</p> <code>0.5</code> <code>sample_num</code> <code>int</code> <p>Maximum number of sample points</p> <code>10000</code> <code>goal_sample_rate</code> <code>float</code> <p>heuristic sample</p> <code>0.05</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.RRTConnect((5, 5), (45, 25), pmp.Map(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] RRT-Connect: An Efficient Approach to Single-Query Path Planning</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_connect.py</code> Python<pre><code>class RRTConnect(RRT):\n    \"\"\"\n    Class for RRT-Connect motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        max_dist (float): Maximum expansion distance one step\n        sample_num (int): Maximum number of sample points\n        goal_sample_rate (float): heuristic sample\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.RRTConnect((5, 5), (45, 25), pmp.Map(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] RRT-Connect: An Efficient Approach to Single-Query Path Planning\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, max_dist: float = 0.5,\n        sample_num: int = 10000, goal_sample_rate: float = 0.05) -&gt; None:\n        super().__init__(start, goal, env, max_dist, sample_num, goal_sample_rate)\n\n    def __str__(self) -&gt; str:\n        return \"RRT-Connect\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        RRT-Connected motion plan function.\n\n        Returns:\n            cost (float): path cost\n            path (list): planning path\n            expand (list): expanded (sampled) nodes list\n        \"\"\"\n        # Sampled list forward\n        sample_list_f = {self.start.current: self.start}\n        # Sampled list backward\n        sample_list_b = {self.goal.current: self.goal}\n\n        for _ in range(self.sample_num):\n            # generate a random node in the map\n            node_rand = self.generateRandomNode()            \n            # generate new node\n            node_new = self.getNearest(list(sample_list_f.values()), node_rand)\n            if node_new:\n                sample_list_f[node_new.current] = node_new\n                # backward exploring\n                node_new_b = self.getNearest(list(sample_list_b.values()), node_new)\n                if node_new_b:\n                    sample_list_b[node_new_b.current] = node_new_b\n\n                    # greedy extending\n                    while True:\n                        if node_new_b == node_new:\n                            cost, path = self.extractPath(node_new, sample_list_b, sample_list_f)\n                            expand = self.getExpand(list(sample_list_b.values()), list(sample_list_f.values()))\n                            return cost, path, expand\n\n                        dist = min(self.max_dist, self.dist(node_new, node_new_b))\n                        theta = self.angle(node_new_b, node_new)\n                        node_new_b2 = Node((node_new_b.x + dist * math.cos(theta),\n                                           (node_new_b.y + dist * math.sin(theta))),\n                                            node_new_b.current, node_new_b.g + dist, 0)\n\n                        if not self.isCollision(node_new_b2, node_new_b):\n                            sample_list_b[node_new_b2.current] = node_new_b2\n                            node_new_b = node_new_b2\n                        else:\n                            break\n\n            if len(sample_list_b) &lt; len(sample_list_f):\n                sample_list_f, sample_list_b = sample_list_b, sample_list_f\n\n        return 0, None, None\n\n    def extractPath(self, boundary: Node, sample_list_b: dict, sample_list_f: dict) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED set.\n\n        Parameters:\n            boundary (Node): the boundary node\n            sample_list_b (dict): Sample list backward\n            sample_list_f (dict): Sample list forward\n\n        Returns:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        if self.start.current in sample_list_b:\n            sample_list_f, sample_list_b = sample_list_b, sample_list_f\n\n        # forward\n        node = sample_list_f[boundary.current]\n        path_f = [node.current]\n        cost = node.g\n        while node != self.start:\n            node_parent = sample_list_f[node.parent]\n            node = node_parent\n            path_f.append(node.current)\n\n        # backward\n        node = sample_list_b[boundary.current]\n        path_b = []\n        cost += node.g\n        while node != self.goal:\n            node_parent = sample_list_b[node.parent]\n            node = node_parent\n            path_b.append(node.current)        \n\n        return cost, list(reversed(path_f)) + path_b\n\n    def getExpand(self, sample_list_b: list, sample_list_f: list) -&gt; list:\n        \"\"\"\n        Get the expand list from sample list.\n\n        Parameters:\n            sample_list_b (list): Sample list backward\n            sample_list_f (list): Sample list forward\n\n        Returns:\n            expand (list): expand list\n        \"\"\"\n        expand = []\n        tree_size = max(len(sample_list_f), len(sample_list_b))\n        for k in range(tree_size):\n            if k &lt; len(sample_list_f):\n                expand.append(sample_list_f[k])\n            if k &lt; len(sample_list_b):\n                expand.append(sample_list_b[k])\n\n        return expand\n</code></pre>"},{"location":"global_planner/sample_search/rrt_connect/RRTConnect.html#src.python_motion_planning.global_planner.sample_search.rrt_connect.RRTConnect.extractPath","title":"<code>extractPath(boundary, sample_list_b, sample_list_f)</code>","text":"<p>Extract the path based on the CLOSED set.</p> <p>Parameters:</p> Name Type Description Default <code>boundary</code> <code>Node</code> <p>the boundary node</p> required <code>sample_list_b</code> <code>dict</code> <p>Sample list backward</p> required <code>sample_list_f</code> <code>dict</code> <p>Sample list forward</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planning path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_connect.py</code> Python<pre><code>def extractPath(self, boundary: Node, sample_list_b: dict, sample_list_f: dict) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED set.\n\n    Parameters:\n        boundary (Node): the boundary node\n        sample_list_b (dict): Sample list backward\n        sample_list_f (dict): Sample list forward\n\n    Returns:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    if self.start.current in sample_list_b:\n        sample_list_f, sample_list_b = sample_list_b, sample_list_f\n\n    # forward\n    node = sample_list_f[boundary.current]\n    path_f = [node.current]\n    cost = node.g\n    while node != self.start:\n        node_parent = sample_list_f[node.parent]\n        node = node_parent\n        path_f.append(node.current)\n\n    # backward\n    node = sample_list_b[boundary.current]\n    path_b = []\n    cost += node.g\n    while node != self.goal:\n        node_parent = sample_list_b[node.parent]\n        node = node_parent\n        path_b.append(node.current)        \n\n    return cost, list(reversed(path_f)) + path_b\n</code></pre>"},{"location":"global_planner/sample_search/rrt_connect/RRTConnect.html#src.python_motion_planning.global_planner.sample_search.rrt_connect.RRTConnect.getExpand","title":"<code>getExpand(sample_list_b, sample_list_f)</code>","text":"<p>Get the expand list from sample list.</p> <p>Parameters:</p> Name Type Description Default <code>sample_list_b</code> <code>list</code> <p>Sample list backward</p> required <code>sample_list_f</code> <code>list</code> <p>Sample list forward</p> required <p>Returns:</p> Name Type Description <code>expand</code> <code>list</code> <p>expand list</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_connect.py</code> Python<pre><code>def getExpand(self, sample_list_b: list, sample_list_f: list) -&gt; list:\n    \"\"\"\n    Get the expand list from sample list.\n\n    Parameters:\n        sample_list_b (list): Sample list backward\n        sample_list_f (list): Sample list forward\n\n    Returns:\n        expand (list): expand list\n    \"\"\"\n    expand = []\n    tree_size = max(len(sample_list_f), len(sample_list_b))\n    for k in range(tree_size):\n        if k &lt; len(sample_list_f):\n            expand.append(sample_list_f[k])\n        if k &lt; len(sample_list_b):\n            expand.append(sample_list_b[k])\n\n    return expand\n</code></pre>"},{"location":"global_planner/sample_search/rrt_connect/RRTConnect.html#src.python_motion_planning.global_planner.sample_search.rrt_connect.RRTConnect.plan","title":"<code>plan()</code>","text":"<p>RRT-Connected motion plan function.</p> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>path cost</p> <code>path</code> <code>list</code> <p>planning path</p> <code>expand</code> <code>list</code> <p>expanded (sampled) nodes list</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_connect.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    RRT-Connected motion plan function.\n\n    Returns:\n        cost (float): path cost\n        path (list): planning path\n        expand (list): expanded (sampled) nodes list\n    \"\"\"\n    # Sampled list forward\n    sample_list_f = {self.start.current: self.start}\n    # Sampled list backward\n    sample_list_b = {self.goal.current: self.goal}\n\n    for _ in range(self.sample_num):\n        # generate a random node in the map\n        node_rand = self.generateRandomNode()            \n        # generate new node\n        node_new = self.getNearest(list(sample_list_f.values()), node_rand)\n        if node_new:\n            sample_list_f[node_new.current] = node_new\n            # backward exploring\n            node_new_b = self.getNearest(list(sample_list_b.values()), node_new)\n            if node_new_b:\n                sample_list_b[node_new_b.current] = node_new_b\n\n                # greedy extending\n                while True:\n                    if node_new_b == node_new:\n                        cost, path = self.extractPath(node_new, sample_list_b, sample_list_f)\n                        expand = self.getExpand(list(sample_list_b.values()), list(sample_list_f.values()))\n                        return cost, path, expand\n\n                    dist = min(self.max_dist, self.dist(node_new, node_new_b))\n                    theta = self.angle(node_new_b, node_new)\n                    node_new_b2 = Node((node_new_b.x + dist * math.cos(theta),\n                                       (node_new_b.y + dist * math.sin(theta))),\n                                        node_new_b.current, node_new_b.g + dist, 0)\n\n                    if not self.isCollision(node_new_b2, node_new_b):\n                        sample_list_b[node_new_b2.current] = node_new_b2\n                        node_new_b = node_new_b2\n                    else:\n                        break\n\n        if len(sample_list_b) &lt; len(sample_list_f):\n            sample_list_f, sample_list_b = sample_list_b, sample_list_f\n\n    return 0, None, None\n</code></pre>"},{"location":"global_planner/sample_search/rrt_star/RRTStar.html","title":"RRTStar","text":""},{"location":"global_planner/sample_search/rrt_star/RRTStar.html#src.python_motion_planning.global_planner.sample_search.rrt_star.RRTStar","title":"<code>src.python_motion_planning.global_planner.sample_search.rrt_star.RRTStar</code>","text":"<p>               Bases: <code>RRT</code></p> <p>Class for RRT-Star motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>max_dist</code> <code>float</code> <p>Maximum expansion distance one step</p> <code>0.5</code> <code>sample_num</code> <code>int</code> <p>Maximum number of sample points</p> <code>10000</code> <code>r</code> <code>float</code> <p>optimization radius</p> <code>10.0</code> <code>goal_sample_rate</code> <code>float</code> <p>heuristic sample</p> <code>0.05</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; import python_motion_planning as pmp\n&gt;&gt;&gt; planner = pmp.RRTStar((5, 5), (45, 25), pmp.Map(51, 31))\n&gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n&gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n&gt;&gt;&gt; planner.run()       # run both planning and animation\n</code></pre> References <p>[1] Sampling-based algorithms for optimal motion planning</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_star.py</code> Python<pre><code>class RRTStar(RRT):\n    \"\"\"\n    Class for RRT-Star motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        max_dist (float): Maximum expansion distance one step\n        sample_num (int): Maximum number of sample points\n        r (float): optimization radius\n        goal_sample_rate (float): heuristic sample\n\n    Examples:\n        &gt;&gt;&gt; import python_motion_planning as pmp\n        &gt;&gt;&gt; planner = pmp.RRTStar((5, 5), (45, 25), pmp.Map(51, 31))\n        &gt;&gt;&gt; cost, path, expand = planner.plan()     # planning results only\n        &gt;&gt;&gt; planner.plot.animation(path, str(planner), cost, expand)  # animation\n        &gt;&gt;&gt; planner.run()       # run both planning and animation\n\n    References:\n        [1] Sampling-based algorithms for optimal motion planning\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, max_dist: float = 0.5,\n                 sample_num: int = 10000, r: float = 10.0, goal_sample_rate: float = 0.05) -&gt; None:\n        super().__init__(start, goal, env, max_dist, sample_num, goal_sample_rate)\n        # optimization radius\n        self.r = r\n\n    def __str__(self) -&gt; str:\n        return \"RRT*\"\n\n    def getNearest(self, node_list: list, node: Node) -&gt; Node:\n        \"\"\"\n        Get the node from `node_list` that is nearest to `node` with optimization.\n\n        Parameters:\n            node_list (list): exploring list\n            node (Node): currently generated node\n\n        Returns:\n            node (Node): nearest node\n        \"\"\"\n        node_new = super().getNearest(node_list, node)\n        if node_new:\n            #  rewire optimization\n            for node_n in node_list:\n                #  inside the optimization circle\n                new_dist = self.dist(node_n, node_new)\n                if new_dist &lt; self.r:\n                    cost = node_n.g + new_dist\n                    #  update new sample node's cost and parent\n                    if node_new.g &gt; cost and not self.isCollision(node_n, node_new):\n                        node_new.parent = node_n.current\n                        node_new.g = cost\n                    else:\n                        #  update nodes' cost inside the radius\n                        cost = node_new.g + new_dist\n                        if node_n.g &gt; cost and not self.isCollision(node_n, node_new):\n                            node_n.parent = node_new.current\n                            node_n.g = cost\n                else:\n                    continue\n            return node_new\n        else:\n            return None \n</code></pre>"},{"location":"global_planner/sample_search/rrt_star/RRTStar.html#src.python_motion_planning.global_planner.sample_search.rrt_star.RRTStar.getNearest","title":"<code>getNearest(node_list, node)</code>","text":"<p>Get the node from <code>node_list</code> that is nearest to <code>node</code> with optimization.</p> <p>Parameters:</p> Name Type Description Default <code>node_list</code> <code>list</code> <p>exploring list</p> required <code>node</code> <code>Node</code> <p>currently generated node</p> required <p>Returns:</p> Name Type Description <code>node</code> <code>Node</code> <p>nearest node</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\rrt_star.py</code> Python<pre><code>def getNearest(self, node_list: list, node: Node) -&gt; Node:\n    \"\"\"\n    Get the node from `node_list` that is nearest to `node` with optimization.\n\n    Parameters:\n        node_list (list): exploring list\n        node (Node): currently generated node\n\n    Returns:\n        node (Node): nearest node\n    \"\"\"\n    node_new = super().getNearest(node_list, node)\n    if node_new:\n        #  rewire optimization\n        for node_n in node_list:\n            #  inside the optimization circle\n            new_dist = self.dist(node_n, node_new)\n            if new_dist &lt; self.r:\n                cost = node_n.g + new_dist\n                #  update new sample node's cost and parent\n                if node_new.g &gt; cost and not self.isCollision(node_n, node_new):\n                    node_new.parent = node_n.current\n                    node_new.g = cost\n                else:\n                    #  update nodes' cost inside the radius\n                    cost = node_new.g + new_dist\n                    if node_n.g &gt; cost and not self.isCollision(node_n, node_new):\n                        node_n.parent = node_new.current\n                        node_n.g = cost\n            else:\n                continue\n        return node_new\n    else:\n        return None \n</code></pre>"},{"location":"global_planner/sample_search/sample_search/SampleSearcher.html","title":"SampleSearcher","text":""},{"location":"global_planner/sample_search/sample_search/SampleSearcher.html#src.python_motion_planning.global_planner.sample_search.sample_search.SampleSearcher","title":"<code>src.python_motion_planning.global_planner.sample_search.sample_search.SampleSearcher</code>","text":"<p>               Bases: <code>Planner</code></p> <p>Base class for planner based on sample searching.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\sample_search.py</code> Python<pre><code>class SampleSearcher(Planner):\n    \"\"\"\n    Base class for planner based on sample searching.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, delta: float=0.5) -&gt; None:\n        super().__init__(start, goal, env)\n        # inflation bias\n        self.delta = delta\n\n    def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n        \"\"\"\n        Judge collision when moving from node1 to node2.\n\n        Parameters:\n            node1 (Node): node 1\n            node2 (Node): node 2\n\n        Returns:\n            collision (bool): True if collision exists else False\n        \"\"\"\n        if self.isInsideObs(node1) or self.isInsideObs(node2):\n            return True\n\n        for rect in self.env.obs_rect:\n            if self.isInterRect(node1, node2, rect):\n                return True\n\n        for circle in self.env.obs_circ:\n            if self.isInterCircle(node1, node2, circle):\n                return True\n\n        return False\n\n    def isInsideObs(self, node: Node) -&gt; bool:\n        \"\"\"\n        Judge whether a node inside tht obstacles or not.\n\n        Parameters:\n            node (Node): node\n\n        Returns:\n            inside (bool): True if inside the obstacles else False\n        \"\"\"\n        x, y = node.current\n\n        for (ox, oy, r) in self.env.obs_circ:\n            if math.hypot(x - ox, y - oy) &lt;= r + self.delta:\n                return True\n\n        for (ox, oy, w, h) in self.env.obs_rect:\n            if 0 &lt;= x - (ox - self.delta) &lt;= w + 2 * self.delta \\\n                and 0 &lt;= y - (oy - self.delta) &lt;= h + 2 * self.delta:\n                return True\n\n        for (ox, oy, w, h) in self.env.boundary:\n            if 0 &lt;= x - (ox - self.delta) &lt;= w + 2 * self.delta \\\n                and 0 &lt;= y - (oy - self.delta) &lt;= h + 2 * self.delta:\n                return True\n\n        return False\n\n    def isInterRect(self, node1: Node, node2: Node, rect: list) -&gt; bool:\n        # obstacle and it's vertex\n        ox, oy, w, h = rect\n        vertex = [[ox - self.delta, oy - self.delta],\n                  [ox + w + self.delta, oy - self.delta],\n                  [ox + w + self.delta, oy + h + self.delta],\n                  [ox - self.delta, oy + h + self.delta]]\n\n        # node\n        x1, y1 = node1.current\n        x2, y2 = node2.current\n\n        def cross(p1, p2, p3):\n            x1 = p2[0] - p1[0]\n            y1 = p2[1] - p1[1]\n            x2 = p3[0] - p1[0]\n            y2 = p3[1] - p1[1]\n            return x1 * y2 - x2 * y1\n\n        for v1, v2 in combinations(vertex, 2):\n            # rapid repulsion\n            if  max(x1, x2) &gt;= min(v1[0], v2[0]) and \\\n                min(x1, x2) &lt;= max(v1[0], v2[0]) and \\\n                max(y1, y2) &gt;= min(v1[1], v2[1]) and \\\n                min(y1, y2) &lt;= max(v1[1], v2[1]): \n                # cross\n                if cross(v1, v2, node1.current) * cross(v1, v2, node2.current) &lt;= 0 and \\\n                   cross(node1.current, node2.current, v1) * cross(node1.current, node2.current, v2) &lt;= 0:\n                    return True\n\n        return False\n\n    def isInterCircle(self, node1: Node, node2: Node, circle: list) -&gt; bool:\n        # obstacle\n        ox, oy, r = circle\n\n        # origin\n        x, y = node1.current\n\n        # direction\n        dx = node2.x - node1.x\n        dy = node2.y - node1.y\n        d  = [dx, dy]\n        d2 = np.dot(d, d)\n\n        if d2 == 0:\n            return False\n\n        # projection\n        t = np.dot([ox - x, oy - y], d) / d2\n        if 0 &lt;= t &lt;= 1:\n            shot = Node((x + t * dx, y + t * dy), None, None, None)\n            center = Node((ox, oy), None, None, None)\n            if self.dist(shot, center) &lt;= r + self.delta:\n                return True\n\n        return False\n</code></pre>"},{"location":"global_planner/sample_search/sample_search/SampleSearcher.html#src.python_motion_planning.global_planner.sample_search.sample_search.SampleSearcher.isCollision","title":"<code>isCollision(node1, node2)</code>","text":"<p>Judge collision when moving from node1 to node2.</p> <p>Parameters:</p> Name Type Description Default <code>node1</code> <code>Node</code> <p>node 1</p> required <code>node2</code> <code>Node</code> <p>node 2</p> required <p>Returns:</p> Name Type Description <code>collision</code> <code>bool</code> <p>True if collision exists else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\sample_search.py</code> Python<pre><code>def isCollision(self, node1: Node, node2: Node) -&gt; bool:\n    \"\"\"\n    Judge collision when moving from node1 to node2.\n\n    Parameters:\n        node1 (Node): node 1\n        node2 (Node): node 2\n\n    Returns:\n        collision (bool): True if collision exists else False\n    \"\"\"\n    if self.isInsideObs(node1) or self.isInsideObs(node2):\n        return True\n\n    for rect in self.env.obs_rect:\n        if self.isInterRect(node1, node2, rect):\n            return True\n\n    for circle in self.env.obs_circ:\n        if self.isInterCircle(node1, node2, circle):\n            return True\n\n    return False\n</code></pre>"},{"location":"global_planner/sample_search/sample_search/SampleSearcher.html#src.python_motion_planning.global_planner.sample_search.sample_search.SampleSearcher.isInsideObs","title":"<code>isInsideObs(node)</code>","text":"<p>Judge whether a node inside tht obstacles or not.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>node</p> required <p>Returns:</p> Name Type Description <code>inside</code> <code>bool</code> <p>True if inside the obstacles else False</p> Source code in <code>src\\python_motion_planning\\global_planner\\sample_search\\sample_search.py</code> Python<pre><code>def isInsideObs(self, node: Node) -&gt; bool:\n    \"\"\"\n    Judge whether a node inside tht obstacles or not.\n\n    Parameters:\n        node (Node): node\n\n    Returns:\n        inside (bool): True if inside the obstacles else False\n    \"\"\"\n    x, y = node.current\n\n    for (ox, oy, r) in self.env.obs_circ:\n        if math.hypot(x - ox, y - oy) &lt;= r + self.delta:\n            return True\n\n    for (ox, oy, w, h) in self.env.obs_rect:\n        if 0 &lt;= x - (ox - self.delta) &lt;= w + 2 * self.delta \\\n            and 0 &lt;= y - (oy - self.delta) &lt;= h + 2 * self.delta:\n            return True\n\n    for (ox, oy, w, h) in self.env.boundary:\n        if 0 &lt;= x - (ox - self.delta) &lt;= w + 2 * self.delta \\\n            and 0 &lt;= y - (oy - self.delta) &lt;= h + 2 * self.delta:\n            return True\n\n    return False\n</code></pre>"},{"location":"local_planner/apf/APF.html","title":"APF","text":""},{"location":"local_planner/apf/APF.html#src.python_motion_planning.local_planner.apf.APF","title":"<code>src.python_motion_planning.local_planner.apf.APF</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for Artificial Potential Field(APF) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import APF\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = APF(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> Source code in <code>src\\python_motion_planning\\local_planner\\apf.py</code> Python<pre><code>class APF(LocalPlanner):\n    \"\"\"\n    Class for Artificial Potential Field(APF) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import APF\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = APF(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, **params)\n        # APF parameters\n        self.zeta = 1.0\n        self.eta = 1.0\n        self.d_0 = 1.0\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"Artificial Potential Field(APF)\"\n\n    def plan(self):\n        \"\"\"\n        APF motion plan function.\n\n        Returns:\n            flag (bool): planning successful if true else failed\n            pose_list (list): history poses of robot\n        \"\"\"\n        dt = self.params[\"TIME_STEP\"]\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, self.robot.history_pose\n\n            # compute the tatget pose and force at the current step\n            lookahead_pt, _, _ = self.getLookaheadPoint()\n            rep_force = self.getRepulsiveForce()\n            attr_force = self.getAttractiveForce(np.array(self.robot.position), np.array(lookahead_pt))\n            net_force = self.zeta * attr_force + self.eta * rep_force\n\n            # compute desired velocity\n            v, theta = self.robot.v, self.robot.theta\n            new_v = np.array([v * math.cos(theta), v * math.sin(theta)]) + net_force\n            new_v /= np.linalg.norm(new_v)\n            new_v *= self.params[\"MAX_V\"]\n            theta_d = math.atan2(new_v[1], new_v[0])\n\n            # calculate velocity command\n            e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n            if not self.shouldMoveToGoal(self.robot.position, self.goal):\n                if not self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [0]])\n                else:\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                e_theta = self.regularizeAngle(theta_d - self.robot.theta)\n                if self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n                else:\n                    v_d = np.linalg.norm(new_v)\n                    u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(e_theta / dt)]])\n\n            # feed into robotic kinematic\n            self.robot.kinematic(u, dt)\n\n        return False, None\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_pose = self.plan()\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose)\n\n    def getRepulsiveForce(self) -&gt; np.ndarray:\n        \"\"\"\n        Get the repulsive force of APF.\n\n        Returns:\n            rep_force (np.ndarray): repulsive force of APF\n        \"\"\"\n        obstacles = np.array(list(self.obstacles))\n        cur_pos = np.array([[self.robot.px, self.robot.py]])\n        D = cdist(obstacles, cur_pos)\n        rep_force = (1 / D - 1 / self.d_0) * (1 / D) ** 2 * (cur_pos - obstacles)\n        valid_mask = np.argwhere((1 / D - 1 / self.d_0) &gt; 0)[:, 0]\n        rep_force = np.sum(rep_force[valid_mask, :], axis=0)\n\n        if not np.all(rep_force == 0):\n            rep_force = rep_force / np.linalg.norm(rep_force)\n\n        return rep_force\n\n    def getAttractiveForce(self, cur_pos: np.ndarray, tgt_pos: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Get the attractive force of APF.\n\n        Parameters:\n            cur_pos (np.ndarray): current position of robot\n            tgt_pos (np.ndarray): target position of robot\n\n        Returns\n            attr_force (np.ndarray): attractive force\n        \"\"\"\n        attr_force = tgt_pos - cur_pos\n        if not np.all(attr_force == 0):\n            attr_force = attr_force / np.linalg.norm(attr_force)\n\n        return attr_force\n</code></pre>"},{"location":"local_planner/apf/APF.html#src.python_motion_planning.local_planner.apf.APF.getAttractiveForce","title":"<code>getAttractiveForce(cur_pos, tgt_pos)</code>","text":"<p>Get the attractive force of APF.</p> <p>Parameters:</p> Name Type Description Default <code>cur_pos</code> <code>ndarray</code> <p>current position of robot</p> required <code>tgt_pos</code> <code>ndarray</code> <p>target position of robot</p> required <p>Returns     attr_force (np.ndarray): attractive force</p> Source code in <code>src\\python_motion_planning\\local_planner\\apf.py</code> Python<pre><code>def getAttractiveForce(self, cur_pos: np.ndarray, tgt_pos: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Get the attractive force of APF.\n\n    Parameters:\n        cur_pos (np.ndarray): current position of robot\n        tgt_pos (np.ndarray): target position of robot\n\n    Returns\n        attr_force (np.ndarray): attractive force\n    \"\"\"\n    attr_force = tgt_pos - cur_pos\n    if not np.all(attr_force == 0):\n        attr_force = attr_force / np.linalg.norm(attr_force)\n\n    return attr_force\n</code></pre>"},{"location":"local_planner/apf/APF.html#src.python_motion_planning.local_planner.apf.APF.getRepulsiveForce","title":"<code>getRepulsiveForce()</code>","text":"<p>Get the repulsive force of APF.</p> <p>Returns:</p> Name Type Description <code>rep_force</code> <code>ndarray</code> <p>repulsive force of APF</p> Source code in <code>src\\python_motion_planning\\local_planner\\apf.py</code> Python<pre><code>def getRepulsiveForce(self) -&gt; np.ndarray:\n    \"\"\"\n    Get the repulsive force of APF.\n\n    Returns:\n        rep_force (np.ndarray): repulsive force of APF\n    \"\"\"\n    obstacles = np.array(list(self.obstacles))\n    cur_pos = np.array([[self.robot.px, self.robot.py]])\n    D = cdist(obstacles, cur_pos)\n    rep_force = (1 / D - 1 / self.d_0) * (1 / D) ** 2 * (cur_pos - obstacles)\n    valid_mask = np.argwhere((1 / D - 1 / self.d_0) &gt; 0)[:, 0]\n    rep_force = np.sum(rep_force[valid_mask, :], axis=0)\n\n    if not np.all(rep_force == 0):\n        rep_force = rep_force / np.linalg.norm(rep_force)\n\n    return rep_force\n</code></pre>"},{"location":"local_planner/apf/APF.html#src.python_motion_planning.local_planner.apf.APF.plan","title":"<code>plan()</code>","text":"<p>APF motion plan function.</p> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>planning successful if true else failed</p> <code>pose_list</code> <code>list</code> <p>history poses of robot</p> Source code in <code>src\\python_motion_planning\\local_planner\\apf.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    APF motion plan function.\n\n    Returns:\n        flag (bool): planning successful if true else failed\n        pose_list (list): history poses of robot\n    \"\"\"\n    dt = self.params[\"TIME_STEP\"]\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, self.robot.history_pose\n\n        # compute the tatget pose and force at the current step\n        lookahead_pt, _, _ = self.getLookaheadPoint()\n        rep_force = self.getRepulsiveForce()\n        attr_force = self.getAttractiveForce(np.array(self.robot.position), np.array(lookahead_pt))\n        net_force = self.zeta * attr_force + self.eta * rep_force\n\n        # compute desired velocity\n        v, theta = self.robot.v, self.robot.theta\n        new_v = np.array([v * math.cos(theta), v * math.sin(theta)]) + net_force\n        new_v /= np.linalg.norm(new_v)\n        new_v *= self.params[\"MAX_V\"]\n        theta_d = math.atan2(new_v[1], new_v[0])\n\n        # calculate velocity command\n        e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n        if not self.shouldMoveToGoal(self.robot.position, self.goal):\n            if not self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [0]])\n            else:\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n        else:\n            e_theta = self.regularizeAngle(theta_d - self.robot.theta)\n            if self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                v_d = np.linalg.norm(new_v)\n                u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(e_theta / dt)]])\n\n        # feed into robotic kinematic\n        self.robot.kinematic(u, dt)\n\n    return False, None\n</code></pre>"},{"location":"local_planner/apf/APF.html#src.python_motion_planning.local_planner.apf.APF.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\apf.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_pose = self.plan()\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose)\n</code></pre>"},{"location":"local_planner/dwa/DWA.html","title":"DWA","text":""},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA","title":"<code>src.python_motion_planning.local_planner.dwa.DWA</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for Dynamic Window Approach(DWA) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>heading_weight</code> <code>float</code> <p>weight for heading cost</p> <code>0.2</code> <code>obstacle_weight</code> <code>float</code> <p>weight for obstacle cost</p> <code>0.1</code> <code>velocity_weight</code> <code>float</code> <p>weight for velocity cost</p> <code>0.05</code> <code>predict_time</code> <code>float</code> <p>predict time for trajectory</p> <code>1.5</code> <code>obstacle_inflation_radius</code> <code>float</code> <p>inflation radius for obstacles</p> <code>1.0</code> <code>v_resolution</code> <code>float</code> <p>velocity resolution in evaulation</p> <code>0.05</code> <code>w_resolution</code> <code>float</code> <p>angular velocity resolution in evaulation</p> <code>0.05</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import DWA\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = DWA(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> References <p>[1] The Dynamic Window Approach to Collision Avoidance.</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>class DWA(LocalPlanner):\n    \"\"\"\n    Class for Dynamic Window Approach(DWA) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        heading_weight (float): weight for heading cost\n        obstacle_weight (float): weight for obstacle cost\n        velocity_weight (float): weight for velocity cost\n        predict_time (float): predict time for trajectory\n        obstacle_inflation_radius (float): inflation radius for obstacles\n        v_resolution (float): velocity resolution in evaulation\n        w_resolution (float): angular velocity resolution in evaulation\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import DWA\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = DWA(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n\n    References:\n        [1] The Dynamic Window Approach to Collision Avoidance.\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\",\n                 heading_weight: float = 0.2, obstacle_weight: float = 0.1, velocity_weight: float = 0.05,\n                 predict_time: float = 1.5, obstacle_inflation_radius: float = 1.0,\n                 v_resolution: float = 0.05, w_resolution: float = 0.05, **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, **params)\n        self.heading_weight = heading_weight\n        self.obstacle_weight = obstacle_weight\n        self.velocity_weight = velocity_weight\n        self.predict_time = predict_time\n        self.obstacle_inflation_radius = obstacle_inflation_radius\n        self.v_resolution = v_resolution\n        self.w_resolution = w_resolution\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"Dynamic Window Approach(DWA)\"\n\n    def plan(self) -&gt; tuple:\n        \"\"\"\n        Dynamic Window Approach(DWA) motion plan function.\n        \"\"\"\n        history_traj = []\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, history_traj, self.robot.history_pose\n\n            # get the particular point on the path at the lookahead distance to track\n            lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n            # dynamic configure\n            vr = self.calDynamicWin()\n            eval_win, traj_win = self.evaluation(vr, lookahead_pt)\n\n            # failed\n            if not len(eval_win):\n                break\n\n            # update\n            max_index = np.argmax(eval_win[:, -1])\n            u = np.expand_dims(eval_win[max_index, 0:-1], axis=1)\n\n            self.robot.kinematic(u, self.params[\"TIME_STEP\"])\n            history_traj.append(traj_win[max_index])\n\n        return False, None, None\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_traj, history_pose = self.plan()\n\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose, predict_path=history_traj)\n\n    def calDynamicWin(self) -&gt; list:\n        \"\"\"\n        Calculate dynamic window.\n\n        Returns:\n            v_reference (list): reference velocity\n        \"\"\"\n        # hard margin\n        vs = (self.params[\"MIN_V\"], self.params[\"MAX_V\"], self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n        # predict margin\n        vd = (\n            self.robot.v + self.params[\"MIN_V_INC\"] * self.params[\"TIME_STEP\"],\n            self.robot.v + self.params[\"MAX_V_INC\"] * self.params[\"TIME_STEP\"],\n            self.robot.w +self.params[\"MIN_W_INC\"] * self.params[\"TIME_STEP\"],\n            self.robot.w + self.params[\"MAX_W_INC\"] * self.params[\"TIME_STEP\"]\n        )\n\n        # dynamic window\n        v_tmp = np.array([vs, vd])\n        # reference velocity\n        vr = [\n            float(np.max(v_tmp[:, 0])), float(np.min(v_tmp[:, 1])), \n            float(np.max(v_tmp[:, 2])), float(np.min(v_tmp[:, 3]))\n        ]\n        return vr\n\n    def evaluation(self, vr: list, goal: tuple) -&gt; tuple:\n        \"\"\"\n        Extract the path based on the CLOSED set.\n\n        Parameters:\n            closed_set (list): CLOSED set\n            goal (tuple): goal point coordinate\n\n        Returns:\n            cost (float): the cost of planning path\n            path (list): the planning path\n        \"\"\"\n        v_start, v_end, w_start, w_end = vr\n        v = np.linspace(v_start, v_end, num=int((v_end - v_start) / self.v_resolution)).tolist()\n        w = np.linspace(w_start, w_end, num=int((w_end - w_start) / self.w_resolution)).tolist()\n\n        eval_win, traj_win = [], []\n        for v_, w_ in product(v, w):\n            # trajectory prediction, consistent of poses\n            traj = self.generateTraj(v_, w_)\n            end_state = traj[-1].squeeze().tolist()\n\n            # heading evaluation\n            theta = self.angle((end_state[0], end_state[1]), goal)\n            heading = np.pi - abs(theta - end_state[2])\n\n            # obstacle evaluation\n            D = cdist(np.array(tuple(self.obstacles)), traj[:, 0:2])\n            min_D = np.min(D)\n            obstacle = min(min_D, self.obstacle_inflation_radius)\n\n            # velocity evaluation\n            velocity = abs(v_)\n\n            eval_win.append((v_, w_, heading, obstacle, velocity))\n            traj_win.append(traj)\n\n        # normalization\n        eval_win = np.array(eval_win)\n        if np.sum(eval_win[:, 2]) != 0:\n            eval_win[:, 2] = eval_win[:, 2] / np.sum(eval_win[:, 2])\n        if np.sum(eval_win[:, 3]) != 0:\n            eval_win[:, 3] = eval_win[:, 3] / np.sum(eval_win[:, 3])\n        if np.sum(eval_win[:, 4]) != 0:\n            eval_win[:, 4] = eval_win[:, 4] / np.sum(eval_win[:, 4])\n\n        # evaluation\n        factor = np.array([[1, 0,                    0],\n                           [0, 1,                    0],\n                           [0, 0, self.heading_weight ],\n                           [0, 0, self.obstacle_weight],\n                           [0, 0, self.velocity_weight]])\n\n        return eval_win @ factor, traj_win\n\n    def generateTraj(self, v: float, w: float) -&gt; np.ndarray:\n        \"\"\"\n        Generate predict trajectory.\n\n        Parameters:\n            v (float): velocity\n            w (float): angular velocity\n\n        Returns:\n            v_reference (np.ndarray): reference velocity\n        \"\"\"\n        u = np.array([[v], [w]])\n        state = self.robot.state\n        time_steps = int(self.predict_time / self.params[\"TIME_STEP\"])\n\n        traj = []\n        for _ in range(time_steps):\n            state = self.robot.lookforward(state, u, self.params[\"TIME_STEP\"])\n            traj.append(state)\n\n        return np.array(traj).squeeze()\n</code></pre>"},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA.calDynamicWin","title":"<code>calDynamicWin()</code>","text":"<p>Calculate dynamic window.</p> <p>Returns:</p> Name Type Description <code>v_reference</code> <code>list</code> <p>reference velocity</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>def calDynamicWin(self) -&gt; list:\n    \"\"\"\n    Calculate dynamic window.\n\n    Returns:\n        v_reference (list): reference velocity\n    \"\"\"\n    # hard margin\n    vs = (self.params[\"MIN_V\"], self.params[\"MAX_V\"], self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n    # predict margin\n    vd = (\n        self.robot.v + self.params[\"MIN_V_INC\"] * self.params[\"TIME_STEP\"],\n        self.robot.v + self.params[\"MAX_V_INC\"] * self.params[\"TIME_STEP\"],\n        self.robot.w +self.params[\"MIN_W_INC\"] * self.params[\"TIME_STEP\"],\n        self.robot.w + self.params[\"MAX_W_INC\"] * self.params[\"TIME_STEP\"]\n    )\n\n    # dynamic window\n    v_tmp = np.array([vs, vd])\n    # reference velocity\n    vr = [\n        float(np.max(v_tmp[:, 0])), float(np.min(v_tmp[:, 1])), \n        float(np.max(v_tmp[:, 2])), float(np.min(v_tmp[:, 3]))\n    ]\n    return vr\n</code></pre>"},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA.evaluation","title":"<code>evaluation(vr, goal)</code>","text":"<p>Extract the path based on the CLOSED set.</p> <p>Parameters:</p> Name Type Description Default <code>closed_set</code> <code>list</code> <p>CLOSED set</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>the cost of planning path</p> <code>path</code> <code>list</code> <p>the planning path</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>def evaluation(self, vr: list, goal: tuple) -&gt; tuple:\n    \"\"\"\n    Extract the path based on the CLOSED set.\n\n    Parameters:\n        closed_set (list): CLOSED set\n        goal (tuple): goal point coordinate\n\n    Returns:\n        cost (float): the cost of planning path\n        path (list): the planning path\n    \"\"\"\n    v_start, v_end, w_start, w_end = vr\n    v = np.linspace(v_start, v_end, num=int((v_end - v_start) / self.v_resolution)).tolist()\n    w = np.linspace(w_start, w_end, num=int((w_end - w_start) / self.w_resolution)).tolist()\n\n    eval_win, traj_win = [], []\n    for v_, w_ in product(v, w):\n        # trajectory prediction, consistent of poses\n        traj = self.generateTraj(v_, w_)\n        end_state = traj[-1].squeeze().tolist()\n\n        # heading evaluation\n        theta = self.angle((end_state[0], end_state[1]), goal)\n        heading = np.pi - abs(theta - end_state[2])\n\n        # obstacle evaluation\n        D = cdist(np.array(tuple(self.obstacles)), traj[:, 0:2])\n        min_D = np.min(D)\n        obstacle = min(min_D, self.obstacle_inflation_radius)\n\n        # velocity evaluation\n        velocity = abs(v_)\n\n        eval_win.append((v_, w_, heading, obstacle, velocity))\n        traj_win.append(traj)\n\n    # normalization\n    eval_win = np.array(eval_win)\n    if np.sum(eval_win[:, 2]) != 0:\n        eval_win[:, 2] = eval_win[:, 2] / np.sum(eval_win[:, 2])\n    if np.sum(eval_win[:, 3]) != 0:\n        eval_win[:, 3] = eval_win[:, 3] / np.sum(eval_win[:, 3])\n    if np.sum(eval_win[:, 4]) != 0:\n        eval_win[:, 4] = eval_win[:, 4] / np.sum(eval_win[:, 4])\n\n    # evaluation\n    factor = np.array([[1, 0,                    0],\n                       [0, 1,                    0],\n                       [0, 0, self.heading_weight ],\n                       [0, 0, self.obstacle_weight],\n                       [0, 0, self.velocity_weight]])\n\n    return eval_win @ factor, traj_win\n</code></pre>"},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA.generateTraj","title":"<code>generateTraj(v, w)</code>","text":"<p>Generate predict trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>float</code> <p>velocity</p> required <code>w</code> <code>float</code> <p>angular velocity</p> required <p>Returns:</p> Name Type Description <code>v_reference</code> <code>ndarray</code> <p>reference velocity</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>def generateTraj(self, v: float, w: float) -&gt; np.ndarray:\n    \"\"\"\n    Generate predict trajectory.\n\n    Parameters:\n        v (float): velocity\n        w (float): angular velocity\n\n    Returns:\n        v_reference (np.ndarray): reference velocity\n    \"\"\"\n    u = np.array([[v], [w]])\n    state = self.robot.state\n    time_steps = int(self.predict_time / self.params[\"TIME_STEP\"])\n\n    traj = []\n    for _ in range(time_steps):\n        state = self.robot.lookforward(state, u, self.params[\"TIME_STEP\"])\n        traj.append(state)\n\n    return np.array(traj).squeeze()\n</code></pre>"},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA.plan","title":"<code>plan()</code>","text":"<p>Dynamic Window Approach(DWA) motion plan function.</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>def plan(self) -&gt; tuple:\n    \"\"\"\n    Dynamic Window Approach(DWA) motion plan function.\n    \"\"\"\n    history_traj = []\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, history_traj, self.robot.history_pose\n\n        # get the particular point on the path at the lookahead distance to track\n        lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n        # dynamic configure\n        vr = self.calDynamicWin()\n        eval_win, traj_win = self.evaluation(vr, lookahead_pt)\n\n        # failed\n        if not len(eval_win):\n            break\n\n        # update\n        max_index = np.argmax(eval_win[:, -1])\n        u = np.expand_dims(eval_win[max_index, 0:-1], axis=1)\n\n        self.robot.kinematic(u, self.params[\"TIME_STEP\"])\n        history_traj.append(traj_win[max_index])\n\n    return False, None, None\n</code></pre>"},{"location":"local_planner/dwa/DWA.html#src.python_motion_planning.local_planner.dwa.DWA.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\dwa.py</code> Python<pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_traj, history_pose = self.plan()\n\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose, predict_path=history_traj)\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html","title":"LocalPlanner","text":""},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner","title":"<code>src.python_motion_planning.local_planner.local_planner.LocalPlanner</code>","text":"<p>               Bases: <code>Planner</code></p> <p>Base class for local planner.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters</p> <code>{}</code> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>class LocalPlanner(Planner):\n    \"\"\"\n    Base class for local planner.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str=\"euclidean\", **params) -&gt; None:\n        # start and goal pose\n        assert len(start) == 3 and len(goal) == 3, \\\n            \"Start and goal parameters must be (x, y, theta)\"\n        self.start, self.goal = start, goal\n        # heuristic type\n        self.heuristic_type = heuristic_type\n        # environment\n        self.env = env\n        # obstacles\n        self.obstacles = self.env.obstacles\n        # graph handler\n        self.plot = Plot(start, goal, env)\n        # robot\n        self.robot = Robot(start[0], start[1], start[2], 0, 0)\n\n        # parameters and default value\n        self.params = {}\n        self.params[\"TIME_STEP\"] = params[\"TIME_STEP\"] if \"TIME_STEP\" in params.keys() else 0.1\n        self.params[\"MAX_ITERATION\"] = params[\"MAX_ITERATION\"] if \"MAX_ITERATION\" in params.keys() else 1500\n        self.params[\"LOOKAHEAD_TIME\"] = params[\"LOOKAHEAD_TIME\"] if \"LOOKAHEAD_TIME\" in params.keys() else 1.0\n        self.params[\"MAX_LOOKAHEAD_DIST\"] = params[\"MAX_LOOKAHEAD_DIST\"] if \"MAX_LOOKAHEAD_DIST\" in params.keys() else 2.5\n        self.params[\"MIN_LOOKAHEAD_DIST\"] = params[\"MIN_LOOKAHEAD_DIST\"] if \"MIN_LOOKAHEAD_DIST\" in params.keys() else 1.0\n        self.params[\"MAX_V_INC\"] = params[\"MAX_V_INC\"] if \"MAX_V_INC\" in params.keys() else 1.0\n        self.params[\"MIN_V_INC\"] = params[\"MIN_V_INC\"] if \"MIN_V_INC\" in params.keys() else -1.0\n        self.params[\"MAX_V\"] = params[\"MAX_V\"] if \"MAX_V\" in params.keys() else 0.5\n        self.params[\"MIN_V\"] = params[\"MIN_V\"] if \"MIN_V\" in params.keys() else 0.0\n        self.params[\"MAX_W_INC\"] = params[\"MAX_W_INC\"] if \"MAX_W_INC\" in params.keys() else math.pi\n        self.params[\"MIN_W_INC\"] = params[\"MIN_W_INC\"] if \"MIN_W_INC\" in params.keys() else -math.pi\n        self.params[\"MAX_W\"] = params[\"MAX_W\"] if \"MAX_W\" in params.keys() else math.pi / 2\n        self.params[\"MIN_W\"] = params[\"MIN_W\"] if \"MIN_W\" in params.keys() else -math.pi / 2\n        self.params[\"GOAL_DIST_TOL\"] = params[\"GOAL_DIST_TOL\"] if \"GOAL_DIST_TOL\" in params.keys() else 0.5\n        self.params[\"ROTATE_TOL\"] = params[\"ROTATE_TOL\"] if \"ROTATE_TOL\" in params.keys() else 0.5\n\n        # global planner\n        self.g_planner_ = None\n        # global path\n        self.path = None\n        # search factory\n        self.search_factory_ = SearchFactory()\n\n    @property\n    def g_planner(self):\n        return str(self.g_planner_)\n\n    @g_planner.setter\n    def g_planner(self, config):\n        if \"planner_name\" in config:\n            self.g_planner_ = self.search_factory_(**config)\n        else:\n            raise RuntimeError(\"Please set planner name!\")\n\n    @property\n    def g_path(self):\n        \"\"\"\n        [property]Global path.\n        \"\"\"\n        if self.g_planner_ is None:\n            raise AttributeError(\"Global path searcher is None, please set it first!\")\n\n        cost, path, _ = self.g_planner_.plan()\n        return path\n\n    @property\n    def lookahead_dist(self):\n        return MathHelper.clamp(\n            abs(self.robot.v) * self.params[\"LOOKAHEAD_TIME\"],\n            self.params[\"MIN_LOOKAHEAD_DIST\"],\n            self.params[\"MAX_LOOKAHEAD_DIST\"]\n        )\n\n    def dist(self, start: tuple, end: tuple) -&gt; float:\n        return math.hypot(end[0] - start[0], end[1] - start[1])\n\n    def angle(self, start: tuple, end: tuple) -&gt; float:\n        return math.atan2(end[1] - start[1], end[0] - start[0])\n\n    def regularizeAngle(self, angle: float):\n        return angle - 2.0 * math.pi * math.floor((angle + math.pi) / (2.0 * math.pi))\n\n    def getLookaheadPoint(self):\n        \"\"\"\n        Find the point on the path that is exactly the lookahead distance away from the robot\n\n        Returns:\n            lookahead_pt (tuple): lookahead point\n            theta (float): the angle on trajectory\n            kappa (float): the curvature on trajectory\n        \"\"\"\n        if self.path is None:\n            assert RuntimeError(\"Please plan the path using g_planner!\")\n\n        # Find the first pose which is at a distance greater than the lookahead distance\n        dist_to_robot = [self.dist(p, (self.robot.px, self.robot.py)) for p in self.path]\n        idx_closest = dist_to_robot.index(min(dist_to_robot))\n        idx_goal = len(self.path) - 1\n        idx_prev = idx_goal - 1\n        for i in range(idx_closest, len(self.path)):\n            if self.dist(self.path[i], (self.robot.px, self.robot.py)) &gt;= self.lookahead_dist:\n                idx_goal = i\n                break\n\n        pt_x, pt_y = None, None\n        if idx_goal == len(self.path) - 1:\n            # If the no pose is not far enough, take the last pose\n            pt_x = self.path[idx_goal][0]\n            pt_y = self.path[idx_goal][1]\n        else:\n            if idx_goal == 0:\n                idx_goal = idx_goal + 1\n            #  find the point on the line segment between the two poses\n            #  that is exactly the lookahead distance away from the robot pose (the origin)\n            #  This can be found with a closed form for the intersection of a segment and a circle\n            idx_prev = idx_goal - 1\n            px, py = self.path[idx_prev][0], self.path[idx_prev][1]\n            gx, gy = self.path[idx_goal][0], self.path[idx_goal][1]\n\n            # transform to the robot frame so that the circle centers at (0,0)\n            prev_p = (px - self.robot.px, py - self.robot.py)\n            goal_p = (gx - self.robot.px, gy - self.robot.py)\n            i_points = MathHelper.circleSegmentIntersection(prev_p, goal_p, self.lookahead_dist)\n            if len(i_points) == 0:\n                # If there is no intersection, take the closest intersection point (foot of a perpendicular)\n                # between the current position and the line segment\n                i_points.append(MathHelper.closestPointOnLine(prev_p, goal_p))\n            pt_x = i_points[0][0] + self.robot.px\n            pt_y = i_points[0][1] + self.robot.py\n\n        # calculate the angle on trajectory\n        theta = self.angle(self.path[idx_prev], self.path[idx_goal])\n\n        # calculate the curvature on trajectory\n        if idx_goal == 1:\n            idx_goal = idx_goal + 1\n        idx_prev = idx_goal - 1\n        idx_pprev = idx_prev - 1\n        a = self.dist(self.path[idx_prev], self.path[idx_goal])\n        b = self.dist(self.path[idx_pprev], self.path[idx_goal])\n        c = self.dist(self.path[idx_pprev], self.path[idx_prev])\n        cosB = (a * a + c * c - b * b) / (2 * a * c)\n        sinB = math.sin(math.acos(cosB))\n        cross = (self.path[idx_prev][0] - self.path[idx_pprev][0]) * \\\n                (self.path[idx_goal][1] - self.path[idx_pprev][1]) - \\\n                (self.path[idx_prev][1] - self.path[idx_pprev][1]) * \\\n                (self.path[idx_goal][0] - self.path[idx_pprev][0])\n        kappa = math.copysign(2 * sinB / b, cross)\n\n        return (pt_x, pt_y), theta, kappa\n\n    def linearRegularization(self, v_d: float) -&gt; float:\n        \"\"\"\n        Linear velocity regularization\n\n        Parameters:\n            v_d (float): reference velocity input\n\n        Returns:\n            v (float): control velocity output\n        \"\"\"\n        v_inc = v_d - self.robot.v\n        v_inc = MathHelper.clamp(v_inc, self.params[\"MIN_V_INC\"], self.params[\"MAX_V_INC\"])\n\n        v = self.robot.v + v_inc\n        v = MathHelper.clamp(v, self.params[\"MIN_V\"], self.params[\"MAX_V\"])\n\n        return v\n\n    def angularRegularization(self, w_d: float) -&gt; float:\n        \"\"\"\n        Angular velocity regularization\n\n        Parameters:\n            w_d (float): reference angular velocity input\n\n        Returns:\n            w (float): control angular velocity output\n        \"\"\"\n        w_inc = w_d - self.robot.w\n        w_inc = MathHelper.clamp(w_inc, self.params[\"MIN_W_INC\"], self.params[\"MAX_W_INC\"])\n\n        w = self.robot.w + w_inc\n        w = MathHelper.clamp(w, self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n\n        return w\n\n    def shouldMoveToGoal(self, cur: tuple, goal: tuple) -&gt; bool:\n        \"\"\"\n        Whether to move to the goal pose\n\n        Parameters:\n            cur (tuple): current pose of robot\n            goal (tuple): goal pose of robot\n\n        Returns:\n            flag (bool): true if robot should perform movement\n        \"\"\"\n        return self.dist(cur, goal) &gt; self.params[\"GOAL_DIST_TOL\"]\n\n    def shouldRotateToPath(self, angle_to_path: float) -&gt; bool:\n        \"\"\"\n        Whether to correct the tracking path with rotation operation\n\n        Parameters:\n            angle_to_path (float): the angle deviation\n\n        Returns:\n            flag (bool): true if robot should perform rotation\n        \"\"\"\n        return angle_to_path &gt; self.params[\"ROTATE_TOL\"]\n\n    def reachGoal(self, cur: tuple, goal: tuple) -&gt; bool:\n        \"\"\"\n        Whether the robot has reached the goal pose\n\n        Parameters:\n            cur (tuple): current pose of robot\n            goal (tuple): goal pose of robot\n\n        Returns:\n            flag (bool): true if robot has reached the goal\n        \"\"\"\n        e_theta = self.regularizeAngle(cur[2] - goal[2])\n        return not (self.shouldMoveToGoal((cur[0], cur[1]), (goal[0], goal[1]))\n                    or self.shouldRotateToPath(abs(e_theta)))\n\n    def isCollision(self, cur_pos: tuple):\n        \"\"\"\n        Whether the robot is in collision with obstacles\n\n        Parameters:\n            cur_pos (tuple): current position of robot\n\n        Returns:\n            flag (bool): true if robot is in collision\n        \"\"\"\n        obstacles = self.obstacles\n        for obs in obstacles:\n            if abs(cur_pos[0] - obs[0]) &lt; 0.5 and abs(cur_pos[1] - obs[1]) &lt; 0.5:\n                return True\n        return False\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.g_path","title":"<code>g_path</code>  <code>property</code>","text":"<p>[property]Global path.</p>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.angularRegularization","title":"<code>angularRegularization(w_d)</code>","text":"<p>Angular velocity regularization</p> <p>Parameters:</p> Name Type Description Default <code>w_d</code> <code>float</code> <p>reference angular velocity input</p> required <p>Returns:</p> Name Type Description <code>w</code> <code>float</code> <p>control angular velocity output</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def angularRegularization(self, w_d: float) -&gt; float:\n    \"\"\"\n    Angular velocity regularization\n\n    Parameters:\n        w_d (float): reference angular velocity input\n\n    Returns:\n        w (float): control angular velocity output\n    \"\"\"\n    w_inc = w_d - self.robot.w\n    w_inc = MathHelper.clamp(w_inc, self.params[\"MIN_W_INC\"], self.params[\"MAX_W_INC\"])\n\n    w = self.robot.w + w_inc\n    w = MathHelper.clamp(w, self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n\n    return w\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.getLookaheadPoint","title":"<code>getLookaheadPoint()</code>","text":"<p>Find the point on the path that is exactly the lookahead distance away from the robot</p> <p>Returns:</p> Name Type Description <code>lookahead_pt</code> <code>tuple</code> <p>lookahead point</p> <code>theta</code> <code>float</code> <p>the angle on trajectory</p> <code>kappa</code> <code>float</code> <p>the curvature on trajectory</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def getLookaheadPoint(self):\n    \"\"\"\n    Find the point on the path that is exactly the lookahead distance away from the robot\n\n    Returns:\n        lookahead_pt (tuple): lookahead point\n        theta (float): the angle on trajectory\n        kappa (float): the curvature on trajectory\n    \"\"\"\n    if self.path is None:\n        assert RuntimeError(\"Please plan the path using g_planner!\")\n\n    # Find the first pose which is at a distance greater than the lookahead distance\n    dist_to_robot = [self.dist(p, (self.robot.px, self.robot.py)) for p in self.path]\n    idx_closest = dist_to_robot.index(min(dist_to_robot))\n    idx_goal = len(self.path) - 1\n    idx_prev = idx_goal - 1\n    for i in range(idx_closest, len(self.path)):\n        if self.dist(self.path[i], (self.robot.px, self.robot.py)) &gt;= self.lookahead_dist:\n            idx_goal = i\n            break\n\n    pt_x, pt_y = None, None\n    if idx_goal == len(self.path) - 1:\n        # If the no pose is not far enough, take the last pose\n        pt_x = self.path[idx_goal][0]\n        pt_y = self.path[idx_goal][1]\n    else:\n        if idx_goal == 0:\n            idx_goal = idx_goal + 1\n        #  find the point on the line segment between the two poses\n        #  that is exactly the lookahead distance away from the robot pose (the origin)\n        #  This can be found with a closed form for the intersection of a segment and a circle\n        idx_prev = idx_goal - 1\n        px, py = self.path[idx_prev][0], self.path[idx_prev][1]\n        gx, gy = self.path[idx_goal][0], self.path[idx_goal][1]\n\n        # transform to the robot frame so that the circle centers at (0,0)\n        prev_p = (px - self.robot.px, py - self.robot.py)\n        goal_p = (gx - self.robot.px, gy - self.robot.py)\n        i_points = MathHelper.circleSegmentIntersection(prev_p, goal_p, self.lookahead_dist)\n        if len(i_points) == 0:\n            # If there is no intersection, take the closest intersection point (foot of a perpendicular)\n            # between the current position and the line segment\n            i_points.append(MathHelper.closestPointOnLine(prev_p, goal_p))\n        pt_x = i_points[0][0] + self.robot.px\n        pt_y = i_points[0][1] + self.robot.py\n\n    # calculate the angle on trajectory\n    theta = self.angle(self.path[idx_prev], self.path[idx_goal])\n\n    # calculate the curvature on trajectory\n    if idx_goal == 1:\n        idx_goal = idx_goal + 1\n    idx_prev = idx_goal - 1\n    idx_pprev = idx_prev - 1\n    a = self.dist(self.path[idx_prev], self.path[idx_goal])\n    b = self.dist(self.path[idx_pprev], self.path[idx_goal])\n    c = self.dist(self.path[idx_pprev], self.path[idx_prev])\n    cosB = (a * a + c * c - b * b) / (2 * a * c)\n    sinB = math.sin(math.acos(cosB))\n    cross = (self.path[idx_prev][0] - self.path[idx_pprev][0]) * \\\n            (self.path[idx_goal][1] - self.path[idx_pprev][1]) - \\\n            (self.path[idx_prev][1] - self.path[idx_pprev][1]) * \\\n            (self.path[idx_goal][0] - self.path[idx_pprev][0])\n    kappa = math.copysign(2 * sinB / b, cross)\n\n    return (pt_x, pt_y), theta, kappa\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.isCollision","title":"<code>isCollision(cur_pos)</code>","text":"<p>Whether the robot is in collision with obstacles</p> <p>Parameters:</p> Name Type Description Default <code>cur_pos</code> <code>tuple</code> <p>current position of robot</p> required <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>true if robot is in collision</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def isCollision(self, cur_pos: tuple):\n    \"\"\"\n    Whether the robot is in collision with obstacles\n\n    Parameters:\n        cur_pos (tuple): current position of robot\n\n    Returns:\n        flag (bool): true if robot is in collision\n    \"\"\"\n    obstacles = self.obstacles\n    for obs in obstacles:\n        if abs(cur_pos[0] - obs[0]) &lt; 0.5 and abs(cur_pos[1] - obs[1]) &lt; 0.5:\n            return True\n    return False\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.linearRegularization","title":"<code>linearRegularization(v_d)</code>","text":"<p>Linear velocity regularization</p> <p>Parameters:</p> Name Type Description Default <code>v_d</code> <code>float</code> <p>reference velocity input</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>float</code> <p>control velocity output</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def linearRegularization(self, v_d: float) -&gt; float:\n    \"\"\"\n    Linear velocity regularization\n\n    Parameters:\n        v_d (float): reference velocity input\n\n    Returns:\n        v (float): control velocity output\n    \"\"\"\n    v_inc = v_d - self.robot.v\n    v_inc = MathHelper.clamp(v_inc, self.params[\"MIN_V_INC\"], self.params[\"MAX_V_INC\"])\n\n    v = self.robot.v + v_inc\n    v = MathHelper.clamp(v, self.params[\"MIN_V\"], self.params[\"MAX_V\"])\n\n    return v\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.reachGoal","title":"<code>reachGoal(cur, goal)</code>","text":"<p>Whether the robot has reached the goal pose</p> <p>Parameters:</p> Name Type Description Default <code>cur</code> <code>tuple</code> <p>current pose of robot</p> required <code>goal</code> <code>tuple</code> <p>goal pose of robot</p> required <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>true if robot has reached the goal</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def reachGoal(self, cur: tuple, goal: tuple) -&gt; bool:\n    \"\"\"\n    Whether the robot has reached the goal pose\n\n    Parameters:\n        cur (tuple): current pose of robot\n        goal (tuple): goal pose of robot\n\n    Returns:\n        flag (bool): true if robot has reached the goal\n    \"\"\"\n    e_theta = self.regularizeAngle(cur[2] - goal[2])\n    return not (self.shouldMoveToGoal((cur[0], cur[1]), (goal[0], goal[1]))\n                or self.shouldRotateToPath(abs(e_theta)))\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.shouldMoveToGoal","title":"<code>shouldMoveToGoal(cur, goal)</code>","text":"<p>Whether to move to the goal pose</p> <p>Parameters:</p> Name Type Description Default <code>cur</code> <code>tuple</code> <p>current pose of robot</p> required <code>goal</code> <code>tuple</code> <p>goal pose of robot</p> required <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>true if robot should perform movement</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def shouldMoveToGoal(self, cur: tuple, goal: tuple) -&gt; bool:\n    \"\"\"\n    Whether to move to the goal pose\n\n    Parameters:\n        cur (tuple): current pose of robot\n        goal (tuple): goal pose of robot\n\n    Returns:\n        flag (bool): true if robot should perform movement\n    \"\"\"\n    return self.dist(cur, goal) &gt; self.params[\"GOAL_DIST_TOL\"]\n</code></pre>"},{"location":"local_planner/local_planner/LocalPlanner.html#src.python_motion_planning.local_planner.local_planner.LocalPlanner.shouldRotateToPath","title":"<code>shouldRotateToPath(angle_to_path)</code>","text":"<p>Whether to correct the tracking path with rotation operation</p> <p>Parameters:</p> Name Type Description Default <code>angle_to_path</code> <code>float</code> <p>the angle deviation</p> required <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>true if robot should perform rotation</p> Source code in <code>src\\python_motion_planning\\local_planner\\local_planner.py</code> Python<pre><code>def shouldRotateToPath(self, angle_to_path: float) -&gt; bool:\n    \"\"\"\n    Whether to correct the tracking path with rotation operation\n\n    Parameters:\n        angle_to_path (float): the angle deviation\n\n    Returns:\n        flag (bool): true if robot should perform rotation\n    \"\"\"\n    return angle_to_path &gt; self.params[\"ROTATE_TOL\"]\n</code></pre>"},{"location":"local_planner/lqr/LQR.html","title":"LQR","text":""},{"location":"local_planner/lqr/LQR.html#src.python_motion_planning.local_planner.lqr.LQR","title":"<code>src.python_motion_planning.local_planner.lqr.LQR</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for Linear Quadratic Regulator(LQR) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import LQR\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = LQR(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> Source code in <code>src\\python_motion_planning\\local_planner\\lqr.py</code> Python<pre><code>class LQR(LocalPlanner):\n    \"\"\"\n    Class for Linear Quadratic Regulator(LQR) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import LQR\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = LQR(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, **params)\n        # LQR parameters\n        self.Q = np.diag([1, 1, 1])\n        self.R = np.diag([1, 1])\n        self.lqr_iteration = 100\n        self.eps_iter = 1e-1\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"Linear Quadratic Regulator (LQR)\"\n\n    def plan(self):\n        \"\"\"\n        LQR motion plan function.\n\n        Returns:\n            flag (bool): planning successful if true else failed\n            pose_list (list): history poses of robot\n        \"\"\"\n        dt = self.params[\"TIME_STEP\"]\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, self.robot.history_pose\n\n            # get the particular point on the path at the lookahead distance\n            lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n            # calculate velocity command\n            e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n            if not self.shouldMoveToGoal(self.robot.position, self.goal):\n                if not self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [0]])\n                else:\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                e_theta = self.regularizeAngle(\n                    self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n                )\n                if self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n                else:\n                    s = (self.robot.px, self.robot.py, self.robot.theta) # current state\n                    s_d = (lookahead_pt[0], lookahead_pt[1], theta_trj)  # desired state\n                    u_r = (self.robot.v, self.robot.v * kappa)           # refered input\n                    u = self.lqrControl(s, s_d, u_r)\n\n            # feed into robotic kinematic\n            self.robot.kinematic(u, dt)\n\n        return False, None\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_pose = self.plan()\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose)\n\n    def lqrControl(self, s: tuple, s_d: tuple, u_r: tuple) -&gt; np.ndarray:\n        \"\"\"\n        Execute LQR control process.\n\n        Parameters:\n            s (tuple): current state\n            s_d (tuple): desired state\n            u_r (tuple): refered control\n\n        Returns:\n            u (np.ndarray): control vector\n        \"\"\"\n        dt = self.params[\"TIME_STEP\"]\n\n        # state equation on error\n        A = np.identity(3)\n        A[0, 2] = -u_r[0] * np.sin(s_d[2]) * dt\n        A[1, 2] = u_r[0] * np.cos(s_d[2]) * dt\n\n        B = np.zeros((3, 2))\n        B[0, 0] = np.cos(s_d[2]) * dt\n        B[1, 0] = np.sin(s_d[2]) * dt\n        B[2, 1] = dt\n\n        # discrete iteration Ricatti equation\n        P, P_ = np.zeros((3, 3)), np.zeros((3, 3))\n        P = self.Q\n\n        # iteration\n        for _ in range(self.lqr_iteration):\n            P_ = self.Q + A.T @ P @ A - A.T @ P @ B @ np.linalg.inv(self.R + B.T @ P @ B) @ B.T @ P @ A\n            if np.max(P - P_) &lt; self.eps_iter:\n                break\n            P = P_\n\n        # feedback\n        K = -np.linalg.inv(self.R + B.T @ P_ @ B) @ B.T @ P_ @ A\n        e = np.array([[s[0] - s_d[0]], [s[1] - s_d[1]], [self.regularizeAngle(s[2] - s_d[2])]])\n        u = np.array([[u_r[0]], [u_r[1]]]) + K @ e\n\n        return np.array([\n            [self.linearRegularization(float(u[0]))], \n            [self.angularRegularization(float(u[1]))]\n        ])\n</code></pre>"},{"location":"local_planner/lqr/LQR.html#src.python_motion_planning.local_planner.lqr.LQR.lqrControl","title":"<code>lqrControl(s, s_d, u_r)</code>","text":"<p>Execute LQR control process.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>tuple</code> <p>current state</p> required <code>s_d</code> <code>tuple</code> <p>desired state</p> required <code>u_r</code> <code>tuple</code> <p>refered control</p> required <p>Returns:</p> Name Type Description <code>u</code> <code>ndarray</code> <p>control vector</p> Source code in <code>src\\python_motion_planning\\local_planner\\lqr.py</code> Python<pre><code>def lqrControl(self, s: tuple, s_d: tuple, u_r: tuple) -&gt; np.ndarray:\n    \"\"\"\n    Execute LQR control process.\n\n    Parameters:\n        s (tuple): current state\n        s_d (tuple): desired state\n        u_r (tuple): refered control\n\n    Returns:\n        u (np.ndarray): control vector\n    \"\"\"\n    dt = self.params[\"TIME_STEP\"]\n\n    # state equation on error\n    A = np.identity(3)\n    A[0, 2] = -u_r[0] * np.sin(s_d[2]) * dt\n    A[1, 2] = u_r[0] * np.cos(s_d[2]) * dt\n\n    B = np.zeros((3, 2))\n    B[0, 0] = np.cos(s_d[2]) * dt\n    B[1, 0] = np.sin(s_d[2]) * dt\n    B[2, 1] = dt\n\n    # discrete iteration Ricatti equation\n    P, P_ = np.zeros((3, 3)), np.zeros((3, 3))\n    P = self.Q\n\n    # iteration\n    for _ in range(self.lqr_iteration):\n        P_ = self.Q + A.T @ P @ A - A.T @ P @ B @ np.linalg.inv(self.R + B.T @ P @ B) @ B.T @ P @ A\n        if np.max(P - P_) &lt; self.eps_iter:\n            break\n        P = P_\n\n    # feedback\n    K = -np.linalg.inv(self.R + B.T @ P_ @ B) @ B.T @ P_ @ A\n    e = np.array([[s[0] - s_d[0]], [s[1] - s_d[1]], [self.regularizeAngle(s[2] - s_d[2])]])\n    u = np.array([[u_r[0]], [u_r[1]]]) + K @ e\n\n    return np.array([\n        [self.linearRegularization(float(u[0]))], \n        [self.angularRegularization(float(u[1]))]\n    ])\n</code></pre>"},{"location":"local_planner/lqr/LQR.html#src.python_motion_planning.local_planner.lqr.LQR.plan","title":"<code>plan()</code>","text":"<p>LQR motion plan function.</p> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>planning successful if true else failed</p> <code>pose_list</code> <code>list</code> <p>history poses of robot</p> Source code in <code>src\\python_motion_planning\\local_planner\\lqr.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    LQR motion plan function.\n\n    Returns:\n        flag (bool): planning successful if true else failed\n        pose_list (list): history poses of robot\n    \"\"\"\n    dt = self.params[\"TIME_STEP\"]\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, self.robot.history_pose\n\n        # get the particular point on the path at the lookahead distance\n        lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n        # calculate velocity command\n        e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n        if not self.shouldMoveToGoal(self.robot.position, self.goal):\n            if not self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [0]])\n            else:\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n        else:\n            e_theta = self.regularizeAngle(\n                self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n            )\n            if self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                s = (self.robot.px, self.robot.py, self.robot.theta) # current state\n                s_d = (lookahead_pt[0], lookahead_pt[1], theta_trj)  # desired state\n                u_r = (self.robot.v, self.robot.v * kappa)           # refered input\n                u = self.lqrControl(s, s_d, u_r)\n\n        # feed into robotic kinematic\n        self.robot.kinematic(u, dt)\n\n    return False, None\n</code></pre>"},{"location":"local_planner/lqr/LQR.html#src.python_motion_planning.local_planner.lqr.LQR.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\lqr.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_pose = self.plan()\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose)\n</code></pre>"},{"location":"local_planner/mpc/MPC.html","title":"MPC","text":""},{"location":"local_planner/mpc/MPC.html#src.python_motion_planning.local_planner.mpc.MPC","title":"<code>src.python_motion_planning.local_planner.mpc.MPC</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for Model Predicted Control (MPC) motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import MPC\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = MPC(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> Source code in <code>src\\python_motion_planning\\local_planner\\mpc.py</code> Python<pre><code>class MPC(LocalPlanner):\n    \"\"\"\n    Class for Model Predicted Control (MPC) motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import MPC\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = MPC(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, **params)\n        # MPC parameters\n        self.p = 12\n        self.m = 8\n        self.Q = np.diag([0.8, 0.8, 0.5])\n        self.R = np.diag([2, 2])\n        self.u_min = np.array([[self.params[\"MIN_V\"]], [self.params[\"MIN_W\"]]])\n        self.u_max = np.array([[self.params[\"MAX_V\"]], [self.params[\"MAX_W\"]]])\n        # self.du_min = np.array([[self.params[\"MIN_V\"]], [self.params[\"MIN_W\"]]])\n        self.du_min = np.array([[self.params[\"MIN_V_INC\"]], [self.params[\"MIN_W_INC\"]]])\n        self.du_max = np.array([[self.params[\"MAX_V_INC\"]], [self.params[\"MAX_W_INC\"]]])\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"Model Predicted Control (MPC)\"\n\n    def plan(self):\n        \"\"\"\n        MPC motion plan function.\n\n        Returns:\n            flag (bool): planning successful if true else failed\n            pose_list (list): history poses of robot\n        \"\"\"\n        dt = self.params[\"TIME_STEP\"]\n        u_p = (0, 0)\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, self.robot.history_pose\n\n            # get the particular point on the path at the lookahead distance\n            lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n            # calculate velocity command\n            e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n            if not self.shouldMoveToGoal(self.robot.position, self.goal):\n                if not self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [0]])\n                else:\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                e_theta = self.regularizeAngle(\n                    self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n                )\n                if self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n                else:\n                    s = (self.robot.px, self.robot.py, self.robot.theta) # current state\n                    s_d = (lookahead_pt[0], lookahead_pt[1], theta_trj)  # desired state\n                    u_r = (self.robot.v, self.robot.v * kappa)           # refered input\n                    u, u_p = self.mpcControl(s, s_d, u_r, u_p)\n\n            # feed into robotic kinematic\n            self.robot.kinematic(u, dt)\n\n        return False, None\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_pose = self.plan()\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose)\n\n    def mpcControl(self, s: tuple, s_d: tuple, u_r: tuple, u_p: tuple) -&gt; np.ndarray:\n        \"\"\"\n        Execute MPC control process.\n\n        Parameters:\n            s (tuple): current state\n            s_d (tuple): desired state\n            u_r (tuple): refered control\n            u_p (tuple): previous control error\n\n        Returns:\n            u (np.ndarray): control vector\n        \"\"\"\n        dim_u, dim_x = 2, 3\n        dt = self.params[\"TIME_STEP\"]\n\n        # state vector (5 x 1)\n        x = np.array([\n            [s[0] - s_d[0]],\n            [s[1] - s_d[1]],\n            [s[2] - s_d[2]],\n            [u_p[0]],\n            [u_p[1]],\n        ])\n\n        # original state matrix\n        A = np.identity(3)\n        A[0, 2] = -u_r[0] * np.sin(s_d[2]) * dt\n        A[1, 2] = u_r[0] * np.cos(s_d[2]) * dt\n\n        # original control matrix\n        B = np.zeros((3, 2))\n        B[0, 0] = np.cos(s_d[2]) * dt\n        B[1, 0] = np.sin(s_d[2]) * dt\n        B[2, 1] = dt\n\n        # state matrix (5 x 5)\n        A = np.concatenate((A, B), axis=1)\n        temp = np.concatenate((np.zeros((dim_u, dim_x)), np.identity(dim_u)), axis=1)\n        A = np.concatenate((A, temp), axis=0)\n\n        # control matrix (5 x 2)\n        B = np.concatenate((B, np.identity(dim_u)), axis=0)\n\n        # output matrix (3 x 5)\n        C = np.concatenate((np.identity(dim_x), np.zeros((dim_x, dim_u))), axis=1)\n\n        # mpc state matrix (3p x 5)\n        S_x = C @ A\n        for i in range(1, self.p):\n            S_x = np.concatenate((S_x, C @ np.linalg.matrix_power(A, i + 1)), axis=0)\n\n        # mpc control matrix (3p x 2m)\n        S_u_rows = []\n        for i in range(self.p):\n            S_u_row = C @ np.linalg.matrix_power(A, i) @ B\n            for j in range(1, self.m):\n                if j &lt;= i:\n                    S_u_row = np.concatenate((\n                        S_u_row, C @ np.linalg.matrix_power(A, i - j) @ B\n                    ), axis=1)\n                else:\n                    S_u_row = np.concatenate((S_u_row, np.zeros((dim_x, dim_u))), axis=1)\n            S_u_rows.append(S_u_row)\n        S_u = np.vstack(S_u_rows)\n\n        # optimization\n        Yr = np.zeros((3 * self.p, 1))              # (3p x 1)\n        Q = np.kron(np.identity(self.p), self.Q)    # (3p x 3p)\n        R = np.kron(np.identity(self.m), self.R)    # (2m x 2m)\n        H = S_u.T @ Q @ S_u + R                     # (2m x 2m)\n        g = S_u.T @ Q @ (S_x @ x - Yr)              # (2m x 1)\n\n        # constriants\n        I = np.eye(2 * self.m)\n        A_I = np.kron(np.tril(np.ones((self.m, self.m))), np.diag([1, 1]))\n        U_min = np.kron(np.ones((self.m, 1)), self.u_min)\n        U_max = np.kron(np.ones((self.m, 1)), self.u_max)\n        U_k_1 = np.kron(np.ones((self.m, 1)), np.array([[u_p[0]], [u_p[1]]]))\n\n        # boundary\n        dU_min = np.kron(np.ones((self.m, 1)), self.du_min)\n        dU_max = np.kron(np.ones((self.m, 1)), self.du_max)\n\n        # solve\n        solver = osqp.OSQP()\n        H = sparse.csc_matrix(H)\n        A = sparse.csc_matrix(np.vstack([A_I, I]))\n        l = np.vstack([U_min - U_k_1, dU_min])\n        u = np.vstack([U_max - U_k_1, dU_max])\n        solver.setup(H, g, A, l, u, verbose=False)\n        res = solver.solve()\n        dU_opt = res.x[:, None]\n\n        # first element\n        du = dU_opt[0:2]\n\n        # real control\n        u = du + np.array([[u_p[0]], [u_p[1]]]) + np.array([[u_r[0]], [u_r[1]]])\n\n        return np.array([\n            [self.linearRegularization(float(u[0]))], \n            [self.angularRegularization(float(u[1]))]\n        ]), (float(u[0]) - u_r[0], float(u[1]) - u_r[1])\n</code></pre>"},{"location":"local_planner/mpc/MPC.html#src.python_motion_planning.local_planner.mpc.MPC.mpcControl","title":"<code>mpcControl(s, s_d, u_r, u_p)</code>","text":"<p>Execute MPC control process.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>tuple</code> <p>current state</p> required <code>s_d</code> <code>tuple</code> <p>desired state</p> required <code>u_r</code> <code>tuple</code> <p>refered control</p> required <code>u_p</code> <code>tuple</code> <p>previous control error</p> required <p>Returns:</p> Name Type Description <code>u</code> <code>ndarray</code> <p>control vector</p> Source code in <code>src\\python_motion_planning\\local_planner\\mpc.py</code> Python<pre><code>def mpcControl(self, s: tuple, s_d: tuple, u_r: tuple, u_p: tuple) -&gt; np.ndarray:\n    \"\"\"\n    Execute MPC control process.\n\n    Parameters:\n        s (tuple): current state\n        s_d (tuple): desired state\n        u_r (tuple): refered control\n        u_p (tuple): previous control error\n\n    Returns:\n        u (np.ndarray): control vector\n    \"\"\"\n    dim_u, dim_x = 2, 3\n    dt = self.params[\"TIME_STEP\"]\n\n    # state vector (5 x 1)\n    x = np.array([\n        [s[0] - s_d[0]],\n        [s[1] - s_d[1]],\n        [s[2] - s_d[2]],\n        [u_p[0]],\n        [u_p[1]],\n    ])\n\n    # original state matrix\n    A = np.identity(3)\n    A[0, 2] = -u_r[0] * np.sin(s_d[2]) * dt\n    A[1, 2] = u_r[0] * np.cos(s_d[2]) * dt\n\n    # original control matrix\n    B = np.zeros((3, 2))\n    B[0, 0] = np.cos(s_d[2]) * dt\n    B[1, 0] = np.sin(s_d[2]) * dt\n    B[2, 1] = dt\n\n    # state matrix (5 x 5)\n    A = np.concatenate((A, B), axis=1)\n    temp = np.concatenate((np.zeros((dim_u, dim_x)), np.identity(dim_u)), axis=1)\n    A = np.concatenate((A, temp), axis=0)\n\n    # control matrix (5 x 2)\n    B = np.concatenate((B, np.identity(dim_u)), axis=0)\n\n    # output matrix (3 x 5)\n    C = np.concatenate((np.identity(dim_x), np.zeros((dim_x, dim_u))), axis=1)\n\n    # mpc state matrix (3p x 5)\n    S_x = C @ A\n    for i in range(1, self.p):\n        S_x = np.concatenate((S_x, C @ np.linalg.matrix_power(A, i + 1)), axis=0)\n\n    # mpc control matrix (3p x 2m)\n    S_u_rows = []\n    for i in range(self.p):\n        S_u_row = C @ np.linalg.matrix_power(A, i) @ B\n        for j in range(1, self.m):\n            if j &lt;= i:\n                S_u_row = np.concatenate((\n                    S_u_row, C @ np.linalg.matrix_power(A, i - j) @ B\n                ), axis=1)\n            else:\n                S_u_row = np.concatenate((S_u_row, np.zeros((dim_x, dim_u))), axis=1)\n        S_u_rows.append(S_u_row)\n    S_u = np.vstack(S_u_rows)\n\n    # optimization\n    Yr = np.zeros((3 * self.p, 1))              # (3p x 1)\n    Q = np.kron(np.identity(self.p), self.Q)    # (3p x 3p)\n    R = np.kron(np.identity(self.m), self.R)    # (2m x 2m)\n    H = S_u.T @ Q @ S_u + R                     # (2m x 2m)\n    g = S_u.T @ Q @ (S_x @ x - Yr)              # (2m x 1)\n\n    # constriants\n    I = np.eye(2 * self.m)\n    A_I = np.kron(np.tril(np.ones((self.m, self.m))), np.diag([1, 1]))\n    U_min = np.kron(np.ones((self.m, 1)), self.u_min)\n    U_max = np.kron(np.ones((self.m, 1)), self.u_max)\n    U_k_1 = np.kron(np.ones((self.m, 1)), np.array([[u_p[0]], [u_p[1]]]))\n\n    # boundary\n    dU_min = np.kron(np.ones((self.m, 1)), self.du_min)\n    dU_max = np.kron(np.ones((self.m, 1)), self.du_max)\n\n    # solve\n    solver = osqp.OSQP()\n    H = sparse.csc_matrix(H)\n    A = sparse.csc_matrix(np.vstack([A_I, I]))\n    l = np.vstack([U_min - U_k_1, dU_min])\n    u = np.vstack([U_max - U_k_1, dU_max])\n    solver.setup(H, g, A, l, u, verbose=False)\n    res = solver.solve()\n    dU_opt = res.x[:, None]\n\n    # first element\n    du = dU_opt[0:2]\n\n    # real control\n    u = du + np.array([[u_p[0]], [u_p[1]]]) + np.array([[u_r[0]], [u_r[1]]])\n\n    return np.array([\n        [self.linearRegularization(float(u[0]))], \n        [self.angularRegularization(float(u[1]))]\n    ]), (float(u[0]) - u_r[0], float(u[1]) - u_r[1])\n</code></pre>"},{"location":"local_planner/mpc/MPC.html#src.python_motion_planning.local_planner.mpc.MPC.plan","title":"<code>plan()</code>","text":"<p>MPC motion plan function.</p> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>planning successful if true else failed</p> <code>pose_list</code> <code>list</code> <p>history poses of robot</p> Source code in <code>src\\python_motion_planning\\local_planner\\mpc.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    MPC motion plan function.\n\n    Returns:\n        flag (bool): planning successful if true else failed\n        pose_list (list): history poses of robot\n    \"\"\"\n    dt = self.params[\"TIME_STEP\"]\n    u_p = (0, 0)\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, self.robot.history_pose\n\n        # get the particular point on the path at the lookahead distance\n        lookahead_pt, theta_trj, kappa = self.getLookaheadPoint()\n\n        # calculate velocity command\n        e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n        if not self.shouldMoveToGoal(self.robot.position, self.goal):\n            if not self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [0]])\n            else:\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n        else:\n            e_theta = self.regularizeAngle(\n                self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n            )\n            if self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                s = (self.robot.px, self.robot.py, self.robot.theta) # current state\n                s_d = (lookahead_pt[0], lookahead_pt[1], theta_trj)  # desired state\n                u_r = (self.robot.v, self.robot.v * kappa)           # refered input\n                u, u_p = self.mpcControl(s, s_d, u_r, u_p)\n\n        # feed into robotic kinematic\n        self.robot.kinematic(u, dt)\n\n    return False, None\n</code></pre>"},{"location":"local_planner/mpc/MPC.html#src.python_motion_planning.local_planner.mpc.MPC.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\mpc.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_pose = self.plan()\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose)\n</code></pre>"},{"location":"local_planner/pid/PID.html","title":"PID","text":""},{"location":"local_planner/pid/PID.html#src.python_motion_planning.local_planner.pid.PID","title":"<code>src.python_motion_planning.local_planner.pid.PID</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for PID motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import PID\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = PID(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> Source code in <code>src\\python_motion_planning\\local_planner\\pid.py</code> Python<pre><code>class PID(LocalPlanner):\n    \"\"\"\n    Class for PID motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import PID\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = PID(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\",\n                 k_v_p: float = 1.00, k_v_i: float = 0.10, k_v_d: float = 0.10,\n                 k_w_p: float = 1.00, k_w_i: float = 0.10, k_w_d: float = 0.10,\n                 k_theta: float = 0.75, **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, MIN_LOOKAHEAD_DIST=0.75, **params)\n        # PID parameters\n        self.e_w, self.i_w = 0.0, 0.0\n        self.e_v, self.i_v = 0.0, 0.0\n        self.k_v_p, self.k_v_i, self.k_v_d = k_v_p, k_v_i, k_v_d\n        self.k_w_p, self.k_w_i, self.k_w_d = k_w_p, k_w_i, k_w_d\n        self.k_theta = k_theta\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"PID Planner\"\n\n    def plan(self):\n        \"\"\"\n        PID motion plan function.\n\n        Returns:\n            flag (bool): planning successful if true else failed\n            pose_list (list): history poses of robot\n        \"\"\"\n        dt = self.params[\"TIME_STEP\"]\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, self.robot.history_pose\n\n            # find next tracking point\n            lookahead_pt, theta_trj, _ = self.getLookaheadPoint()\n\n            # desired angle\n            theta_err = self.angle(self.robot.position, lookahead_pt)\n            if abs(theta_err - theta_trj) &gt; np.pi:\n                if theta_err &gt; theta_trj:\n                    theta_trj += 2 * np.pi\n                else:\n                    theta_err += 2 * np.pi\n            theta_d = self.k_theta * theta_err + (1 - self.k_theta) * theta_trj\n\n            # calculate velocity command\n            e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n            if not self.shouldMoveToGoal(self.robot.position, self.goal):\n                if not self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [0]])\n                else:\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                e_theta = self.regularizeAngle(theta_d - self.robot.theta)\n                if self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n                else:\n                    v_d = self.dist(lookahead_pt, self.robot.position) / dt\n                    u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(e_theta / dt)]])\n\n            # feed into robotic kinematic\n            self.robot.kinematic(u, dt)\n\n        return False, None\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_pose = self.plan()\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose)\n\n    def linearRegularization(self, v_d: float) -&gt; float:\n        \"\"\"\n        Linear velocity controller with pid.\n\n        Parameters:\n            v_d (float): reference velocity input\n\n        Returns:\n            v (float): control velocity output\n        \"\"\"\n        e_v = v_d - self.robot.v\n        self.i_v += e_v * self.params[\"TIME_STEP\"]\n        d_v = (e_v - self.e_v) / self.params[\"TIME_STEP\"]\n        self.e_v = e_v\n\n        v_inc = self.k_v_p * e_v + self.k_v_i * self.i_v + self.k_v_d * d_v\n        v_inc = MathHelper.clamp(v_inc, self.params[\"MIN_V_INC\"], self.params[\"MAX_V_INC\"])\n\n        v = self.robot.v + v_inc\n        v = MathHelper.clamp(v, self.params[\"MIN_V\"], self.params[\"MAX_V\"])\n\n        return v\n\n    def angularRegularization(self, w_d: float) -&gt; float:\n        \"\"\"\n        Angular velocity controller with pid.\n\n        Parameters:\n            w_d (float): reference angular input\n\n        Returns:\n            w (float): control angular velocity output\n        \"\"\"\n        e_w = w_d - self.robot.w\n        self.i_w += e_w * self.params[\"TIME_STEP\"]\n        d_w = (e_w - self.e_w) / self.params[\"TIME_STEP\"]\n        self.e_w = e_w\n\n        w_inc = self.k_w_p * e_w + self.k_w_i * self.i_w + self.k_w_d * d_w\n        w_inc = MathHelper.clamp(w_inc, self.params[\"MIN_W_INC\"], self.params[\"MAX_W_INC\"])\n\n        w = self.robot.w + w_inc\n        w = MathHelper.clamp(w, self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n\n        return w\n</code></pre>"},{"location":"local_planner/pid/PID.html#src.python_motion_planning.local_planner.pid.PID.angularRegularization","title":"<code>angularRegularization(w_d)</code>","text":"<p>Angular velocity controller with pid.</p> <p>Parameters:</p> Name Type Description Default <code>w_d</code> <code>float</code> <p>reference angular input</p> required <p>Returns:</p> Name Type Description <code>w</code> <code>float</code> <p>control angular velocity output</p> Source code in <code>src\\python_motion_planning\\local_planner\\pid.py</code> Python<pre><code>def angularRegularization(self, w_d: float) -&gt; float:\n    \"\"\"\n    Angular velocity controller with pid.\n\n    Parameters:\n        w_d (float): reference angular input\n\n    Returns:\n        w (float): control angular velocity output\n    \"\"\"\n    e_w = w_d - self.robot.w\n    self.i_w += e_w * self.params[\"TIME_STEP\"]\n    d_w = (e_w - self.e_w) / self.params[\"TIME_STEP\"]\n    self.e_w = e_w\n\n    w_inc = self.k_w_p * e_w + self.k_w_i * self.i_w + self.k_w_d * d_w\n    w_inc = MathHelper.clamp(w_inc, self.params[\"MIN_W_INC\"], self.params[\"MAX_W_INC\"])\n\n    w = self.robot.w + w_inc\n    w = MathHelper.clamp(w, self.params[\"MIN_W\"], self.params[\"MAX_W\"])\n\n    return w\n</code></pre>"},{"location":"local_planner/pid/PID.html#src.python_motion_planning.local_planner.pid.PID.linearRegularization","title":"<code>linearRegularization(v_d)</code>","text":"<p>Linear velocity controller with pid.</p> <p>Parameters:</p> Name Type Description Default <code>v_d</code> <code>float</code> <p>reference velocity input</p> required <p>Returns:</p> Name Type Description <code>v</code> <code>float</code> <p>control velocity output</p> Source code in <code>src\\python_motion_planning\\local_planner\\pid.py</code> Python<pre><code>def linearRegularization(self, v_d: float) -&gt; float:\n    \"\"\"\n    Linear velocity controller with pid.\n\n    Parameters:\n        v_d (float): reference velocity input\n\n    Returns:\n        v (float): control velocity output\n    \"\"\"\n    e_v = v_d - self.robot.v\n    self.i_v += e_v * self.params[\"TIME_STEP\"]\n    d_v = (e_v - self.e_v) / self.params[\"TIME_STEP\"]\n    self.e_v = e_v\n\n    v_inc = self.k_v_p * e_v + self.k_v_i * self.i_v + self.k_v_d * d_v\n    v_inc = MathHelper.clamp(v_inc, self.params[\"MIN_V_INC\"], self.params[\"MAX_V_INC\"])\n\n    v = self.robot.v + v_inc\n    v = MathHelper.clamp(v, self.params[\"MIN_V\"], self.params[\"MAX_V\"])\n\n    return v\n</code></pre>"},{"location":"local_planner/pid/PID.html#src.python_motion_planning.local_planner.pid.PID.plan","title":"<code>plan()</code>","text":"<p>PID motion plan function.</p> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>planning successful if true else failed</p> <code>pose_list</code> <code>list</code> <p>history poses of robot</p> Source code in <code>src\\python_motion_planning\\local_planner\\pid.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    PID motion plan function.\n\n    Returns:\n        flag (bool): planning successful if true else failed\n        pose_list (list): history poses of robot\n    \"\"\"\n    dt = self.params[\"TIME_STEP\"]\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, self.robot.history_pose\n\n        # find next tracking point\n        lookahead_pt, theta_trj, _ = self.getLookaheadPoint()\n\n        # desired angle\n        theta_err = self.angle(self.robot.position, lookahead_pt)\n        if abs(theta_err - theta_trj) &gt; np.pi:\n            if theta_err &gt; theta_trj:\n                theta_trj += 2 * np.pi\n            else:\n                theta_err += 2 * np.pi\n        theta_d = self.k_theta * theta_err + (1 - self.k_theta) * theta_trj\n\n        # calculate velocity command\n        e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n        if not self.shouldMoveToGoal(self.robot.position, self.goal):\n            if not self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [0]])\n            else:\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n        else:\n            e_theta = self.regularizeAngle(theta_d - self.robot.theta)\n            if self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                v_d = self.dist(lookahead_pt, self.robot.position) / dt\n                u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(e_theta / dt)]])\n\n        # feed into robotic kinematic\n        self.robot.kinematic(u, dt)\n\n    return False, None\n</code></pre>"},{"location":"local_planner/pid/PID.html#src.python_motion_planning.local_planner.pid.PID.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\pid.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_pose = self.plan()\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose)\n</code></pre>"},{"location":"local_planner/rpp/RPP.html","title":"RPP","text":""},{"location":"local_planner/rpp/RPP.html#src.python_motion_planning.local_planner.rpp.RPP","title":"<code>src.python_motion_planning.local_planner.rpp.RPP</code>","text":"<p>               Bases: <code>LocalPlanner</code></p> <p>Class for RPP motion planning.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>tuple</code> <p>start point coordinate</p> required <code>goal</code> <code>tuple</code> <p>goal point coordinate</p> required <code>env</code> <code>Env</code> <p>environment</p> required <code>heuristic_type</code> <code>str</code> <p>heuristic function type</p> <code>'euclidean'</code> <code>**params</code> <p>other parameters can be found in the parent class LocalPlanner</p> <code>{}</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Grid\n&gt;&gt;&gt; from python_motion_planning.local_planner import RPP\n&gt;&gt;&gt; start = (5, 5, 0)\n&gt;&gt;&gt; goal = (45, 25, 0)\n&gt;&gt;&gt; env = Grid(51, 31)\n&gt;&gt;&gt; planner = RPP(start, goal, env)\n&gt;&gt;&gt; planner.run()\n</code></pre> Source code in <code>src\\python_motion_planning\\local_planner\\rpp.py</code> Python<pre><code>class RPP(LocalPlanner):\n    \"\"\"\n    Class for RPP motion planning.\n\n    Parameters:\n        start (tuple): start point coordinate\n        goal (tuple): goal point coordinate\n        env (Env): environment\n        heuristic_type (str): heuristic function type\n        **params: other parameters can be found in the parent class LocalPlanner\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Grid\n        &gt;&gt;&gt; from python_motion_planning.local_planner import RPP\n        &gt;&gt;&gt; start = (5, 5, 0)\n        &gt;&gt;&gt; goal = (45, 25, 0)\n        &gt;&gt;&gt; env = Grid(51, 31)\n        &gt;&gt;&gt; planner = RPP(start, goal, env)\n        &gt;&gt;&gt; planner.run()\n    \"\"\"\n    def __init__(self, start: tuple, goal: tuple, env: Env, heuristic_type: str = \"euclidean\", **params) -&gt; None:\n        super().__init__(start, goal, env, heuristic_type, **params)\n        # RPP parameters\n        self.regulated_radius_min = 0.9\n        self.scaling_dist = 0.6\n        self.scaling_gain = 1.0\n\n        # global planner\n        g_start = (start[0], start[1])\n        g_goal  = (goal[0], goal[1])\n        self.g_planner = {\"planner_name\": \"a_star\", \"start\": g_start, \"goal\": g_goal, \"env\": env}\n        self.path = self.g_path[::-1]\n\n    def __str__(self) -&gt; str:\n        return \"Regulated Pure Pursuit (RPP)\"\n\n    def plan(self):\n        \"\"\"\n        RPP motion plan function.\n\n        Returns:\n            flag (bool): planning successful if true else failed\n            pose_list (list): history poses of robot\n            lookahead_pts (list): history lookahead points\n        \"\"\"\n        lookahead_pts = []\n        dt = self.params[\"TIME_STEP\"]\n        for _ in range(self.params[\"MAX_ITERATION\"]):\n            # break until goal reached\n            if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n                return True, self.robot.history_pose, lookahead_pts\n\n            # get the particular point on the path at the lookahead distance\n            lookahead_pt, _, _ = self.getLookaheadPoint()\n\n            # get the tracking curvature with goalahead point\n            lookahead_k = 2 * math.sin(\n                self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n            ) / self.lookahead_dist\n\n            # calculate velocity command\n            e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n            if not self.shouldMoveToGoal(self.robot.position, self.goal):\n                if not self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [0]])\n                else:\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                e_theta = self.regularizeAngle(self.angle(self.robot.position, lookahead_pt) - self.robot.theta)\n                if self.shouldRotateToPath(abs(e_theta)):\n                    u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n                else:\n                    # apply constraints\n                    curv_vel = self.applyCurvatureConstraint(self.params[\"MAX_V\"], lookahead_k)\n                    cost_vel = self.applyObstacleConstraint(self.params[\"MAX_V\"])\n                    v_d = min(curv_vel, cost_vel)\n                    u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(v_d * lookahead_k)]])\n\n            # update lookahead points\n            lookahead_pts.append(lookahead_pt)\n\n            # feed into robotic kinematic\n            self.robot.kinematic(u, dt)\n\n        return False, None, None\n\n    def run(self):\n        \"\"\"\n        Running both plannig and animation.\n        \"\"\"\n        _, history_pose, lookahead_pts = self.plan()\n        if not history_pose:\n            raise ValueError(\"Path not found and planning failed!\")\n\n        path = np.array(history_pose)[:, 0:2]\n        cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n        self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n        self.plot.animation(path, str(self), cost, history_pose=history_pose, lookahead_pts=lookahead_pts)\n\n    def applyCurvatureConstraint(self, raw_linear_vel: float, curvature: float) -&gt; float:\n        \"\"\"\n        Applying curvature constraints to regularize the speed of robot turning.\n\n        Parameters:\n            raw_linear_vel (float): the raw linear velocity of robot\n            curvature (float): the tracking curvature\n\n        Returns:\n            reg_vel (float): the regulated velocity\n        \"\"\"\n        radius = abs(1.0 / curvature)\n        if radius &lt; self.regulated_radius_min:\n            return raw_linear_vel * (radius / self.regulated_radius_min)\n        else:\n            return raw_linear_vel\n\n    def applyObstacleConstraint(self, raw_linear_vel: float) -&gt; float:\n        \"\"\"\n        Applying obstacle constraints to regularize the speed of robot approaching obstacles.\n\n        Parameters:\n            raw_linear_vel (float): the raw linear velocity of robot\n\n        Returns:\n            reg_vel (float): the regulated velocity\n        \"\"\"\n        obstacles = np.array(list(self.obstacles))\n        D = cdist(obstacles, np.array([[self.robot.px, self.robot.py]]))\n        obs_dist = np.min(D)\n        if obs_dist &lt; self.scaling_dist:\n            return raw_linear_vel * self.scaling_gain * obs_dist / self.scaling_dist\n        else:\n            return raw_linear_vel\n</code></pre>"},{"location":"local_planner/rpp/RPP.html#src.python_motion_planning.local_planner.rpp.RPP.applyCurvatureConstraint","title":"<code>applyCurvatureConstraint(raw_linear_vel, curvature)</code>","text":"<p>Applying curvature constraints to regularize the speed of robot turning.</p> <p>Parameters:</p> Name Type Description Default <code>raw_linear_vel</code> <code>float</code> <p>the raw linear velocity of robot</p> required <code>curvature</code> <code>float</code> <p>the tracking curvature</p> required <p>Returns:</p> Name Type Description <code>reg_vel</code> <code>float</code> <p>the regulated velocity</p> Source code in <code>src\\python_motion_planning\\local_planner\\rpp.py</code> Python<pre><code>def applyCurvatureConstraint(self, raw_linear_vel: float, curvature: float) -&gt; float:\n    \"\"\"\n    Applying curvature constraints to regularize the speed of robot turning.\n\n    Parameters:\n        raw_linear_vel (float): the raw linear velocity of robot\n        curvature (float): the tracking curvature\n\n    Returns:\n        reg_vel (float): the regulated velocity\n    \"\"\"\n    radius = abs(1.0 / curvature)\n    if radius &lt; self.regulated_radius_min:\n        return raw_linear_vel * (radius / self.regulated_radius_min)\n    else:\n        return raw_linear_vel\n</code></pre>"},{"location":"local_planner/rpp/RPP.html#src.python_motion_planning.local_planner.rpp.RPP.applyObstacleConstraint","title":"<code>applyObstacleConstraint(raw_linear_vel)</code>","text":"<p>Applying obstacle constraints to regularize the speed of robot approaching obstacles.</p> <p>Parameters:</p> Name Type Description Default <code>raw_linear_vel</code> <code>float</code> <p>the raw linear velocity of robot</p> required <p>Returns:</p> Name Type Description <code>reg_vel</code> <code>float</code> <p>the regulated velocity</p> Source code in <code>src\\python_motion_planning\\local_planner\\rpp.py</code> Python<pre><code>def applyObstacleConstraint(self, raw_linear_vel: float) -&gt; float:\n    \"\"\"\n    Applying obstacle constraints to regularize the speed of robot approaching obstacles.\n\n    Parameters:\n        raw_linear_vel (float): the raw linear velocity of robot\n\n    Returns:\n        reg_vel (float): the regulated velocity\n    \"\"\"\n    obstacles = np.array(list(self.obstacles))\n    D = cdist(obstacles, np.array([[self.robot.px, self.robot.py]]))\n    obs_dist = np.min(D)\n    if obs_dist &lt; self.scaling_dist:\n        return raw_linear_vel * self.scaling_gain * obs_dist / self.scaling_dist\n    else:\n        return raw_linear_vel\n</code></pre>"},{"location":"local_planner/rpp/RPP.html#src.python_motion_planning.local_planner.rpp.RPP.plan","title":"<code>plan()</code>","text":"<p>RPP motion plan function.</p> <p>Returns:</p> Name Type Description <code>flag</code> <code>bool</code> <p>planning successful if true else failed</p> <code>pose_list</code> <code>list</code> <p>history poses of robot</p> <code>lookahead_pts</code> <code>list</code> <p>history lookahead points</p> Source code in <code>src\\python_motion_planning\\local_planner\\rpp.py</code> Python<pre><code>def plan(self):\n    \"\"\"\n    RPP motion plan function.\n\n    Returns:\n        flag (bool): planning successful if true else failed\n        pose_list (list): history poses of robot\n        lookahead_pts (list): history lookahead points\n    \"\"\"\n    lookahead_pts = []\n    dt = self.params[\"TIME_STEP\"]\n    for _ in range(self.params[\"MAX_ITERATION\"]):\n        # break until goal reached\n        if self.reachGoal(tuple(self.robot.state.squeeze(axis=1)[0:3]), self.goal):\n            return True, self.robot.history_pose, lookahead_pts\n\n        # get the particular point on the path at the lookahead distance\n        lookahead_pt, _, _ = self.getLookaheadPoint()\n\n        # get the tracking curvature with goalahead point\n        lookahead_k = 2 * math.sin(\n            self.angle(self.robot.position, lookahead_pt) - self.robot.theta\n        ) / self.lookahead_dist\n\n        # calculate velocity command\n        e_theta = self.regularizeAngle(self.robot.theta - self.goal[2])\n        if not self.shouldMoveToGoal(self.robot.position, self.goal):\n            if not self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [0]])\n            else:\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n        else:\n            e_theta = self.regularizeAngle(self.angle(self.robot.position, lookahead_pt) - self.robot.theta)\n            if self.shouldRotateToPath(abs(e_theta)):\n                u = np.array([[0], [self.angularRegularization(e_theta / dt)]])\n            else:\n                # apply constraints\n                curv_vel = self.applyCurvatureConstraint(self.params[\"MAX_V\"], lookahead_k)\n                cost_vel = self.applyObstacleConstraint(self.params[\"MAX_V\"])\n                v_d = min(curv_vel, cost_vel)\n                u = np.array([[self.linearRegularization(v_d)], [self.angularRegularization(v_d * lookahead_k)]])\n\n        # update lookahead points\n        lookahead_pts.append(lookahead_pt)\n\n        # feed into robotic kinematic\n        self.robot.kinematic(u, dt)\n\n    return False, None, None\n</code></pre>"},{"location":"local_planner/rpp/RPP.html#src.python_motion_planning.local_planner.rpp.RPP.run","title":"<code>run()</code>","text":"<p>Running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\local_planner\\rpp.py</code> Python<pre><code>def run(self):\n    \"\"\"\n    Running both plannig and animation.\n    \"\"\"\n    _, history_pose, lookahead_pts = self.plan()\n    if not history_pose:\n        raise ValueError(\"Path not found and planning failed!\")\n\n    path = np.array(history_pose)[:, 0:2]\n    cost = np.sum(np.sqrt(np.sum(np.diff(path, axis=0)**2, axis=1, keepdims=True)))\n    self.plot.plotPath(self.path, path_color=\"r\", path_style=\"--\")\n    self.plot.animation(path, str(self), cost, history_pose=history_pose, lookahead_pts=lookahead_pts)\n</code></pre>"},{"location":"utils/agent/agent/Agent.html","title":"Agent","text":""},{"location":"utils/agent/agent/Agent.html#src.python_motion_planning.utils.agent.agent.Agent","title":"<code>src.python_motion_planning.utils.agent.agent.Agent</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for agent.</p> <p>Parameters:</p> Name Type Description Default <code>px</code> <code>float</code> <p>initial x-position</p> required <code>py</code> <code>float</code> <p>initial y-position</p> required <code>theta</code> <code>float</code> <p>initial pose angle</p> required Source code in <code>src\\python_motion_planning\\utils\\agent\\agent.py</code> Python<pre><code>class Agent(ABC):\n    \"\"\"\n    Abstract class for agent.\n\n    Parameters:\n        px (float): initial x-position\n        py (float): initial y-position\n        theta (float): initial pose angle\n    \"\"\"\n    def __init__(self, px, py, theta) -&gt; None:\n        self.px = px\n        self.py = py\n        self.theta = theta\n        self.parameters = None\n\n    def setParameters(self, **parameters) -&gt; None:\n        # other customer parameters\n        self.parameters = parameters\n        for param, val in parameters.items():\n            setattr(self, param, val)\n\n    @property\n    def position(self):\n        return (self.px, self.py)\n\n    @abstractmethod\n    def kinematic(self, u, dt):\n        pass\n\n    @property\n    @abstractmethod\n    def state(self):\n        pass\n</code></pre>"},{"location":"utils/agent/agent/Robot.html","title":"Robot","text":""},{"location":"utils/agent/agent/Robot.html#src.python_motion_planning.utils.agent.agent.Robot","title":"<code>src.python_motion_planning.utils.agent.agent.Robot</code>","text":"<p>               Bases: <code>Agent</code></p> <p>Class for robot.</p> <p>Parameters:</p> Name Type Description Default <code>px</code> <code>float</code> <p>initial x-position</p> required <code>py</code> <code>float</code> <p>initial y-position</p> required <code>theta</code> <code>float</code> <p>initial pose angle</p> required <code>v</code> <code>float</code> <p>linear velocity</p> required <code>w</code> <code>float</code> <p>angular velocity</p> required Source code in <code>src\\python_motion_planning\\utils\\agent\\agent.py</code> Python<pre><code>class Robot(Agent):\n    \"\"\"\n    Class for robot.\n\n    Parameters:\n        px (float): initial x-position\n        py (float): initial y-position\n        theta (float): initial pose angle\n        v (float): linear velocity\n        w (float): angular velocity\n    \"\"\"\n    def __init__(self, px, py, theta, v, w) -&gt; None:\n        super().__init__(px, py, theta)\n        # velocity\n        self.v = v\n        self.w = w\n        # history\n        self.history_pose = []\n\n    def __str__(self) -&gt; str:\n        return \"Robot\"\n\n    def kinematic(self, u: np.ndarray, dt: float, replace: bool = True):\n        \"\"\"\n        Run robot kinematic once.\n\n        Parameters:\n            u (np.ndarray): control command with [v, w]\n            dt (float): simulation time\n            replace (bool): update-self if true else return a new Robot object\n\n        Returns:\n            robot (Robot): a new robot object\n        \"\"\"\n        new_state = self.lookforward(self.state, u, dt).squeeze().tolist()\n        if replace:\n            self.history_pose.append((self.px, self.py, self.theta))\n            self.px, self.py, self.theta = new_state[0], new_state[1], new_state[2]\n            self.v, self.w = new_state[3], new_state[4]\n        else:\n            new_robot = Robot(new_state[0], new_state[1], new_state[2], \n                new_state[3], new_state[4])\n            new_robot.setParameters(self.parameters)\n            return new_robot\n\n    def lookforward(self, state: np.ndarray, u: np.ndarray, dt: float) -&gt; np.ndarray:\n        \"\"\"\n        Run robot kinematic once but do not update.\n\n        Parameters:\n            state (np.ndarray): robot state with [x, y, theta, v, w]\n            u (np.ndarray): control command with [v, w]\n            dt (float): simulation time\n            obstacles (set): set of obstacles with (x, y)\n\n        Returns:\n            new_state (np.ndarray (5x1)): new robot state with [x, y, theta, v, w]\n        \"\"\"\n        F = np.array([[1, 0, 0, 0, 0],\n                      [0, 1, 0, 0, 0],\n                      [0, 0, 1, 0, 0],\n                      [0, 0, 0, 0, 0],\n                      [0, 0, 0, 0, 0]])\n        B = np.array([[dt * math.cos(state[2]),  0],\n                      [dt * math.sin(state[2]),  0],\n                      [                      0, dt],\n                      [                      1,  0],\n                      [                      0,  1]])\n        new_state = F @ state + B @ u\n\n        return new_state\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Reset the state.\n        \"\"\"\n        self.v = 0\n        self.w = 0\n        self.history_pose = []\n\n    @property\n    def state(self) -&gt; None:\n        \"\"\"\n        Get the state.\n\n        Returns:\n            state (np.ndarray (5x1)): robot state with [x, y, theta, v, w]\n        \"\"\"\n        state = np.array([[self.px], [self.py], [self.theta], [self.v], [self.w]]) \n        return state\n</code></pre>"},{"location":"utils/agent/agent/Robot.html#src.python_motion_planning.utils.agent.agent.Robot.state","title":"<code>state: None</code>  <code>property</code>","text":"<p>Get the state.</p> <p>Returns:</p> Name Type Description <code>state</code> <code>np.ndarray (5x1)</code> <p>robot state with [x, y, theta, v, w]</p>"},{"location":"utils/agent/agent/Robot.html#src.python_motion_planning.utils.agent.agent.Robot.kinematic","title":"<code>kinematic(u, dt, replace=True)</code>","text":"<p>Run robot kinematic once.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray</code> <p>control command with [v, w]</p> required <code>dt</code> <code>float</code> <p>simulation time</p> required <code>replace</code> <code>bool</code> <p>update-self if true else return a new Robot object</p> <code>True</code> <p>Returns:</p> Name Type Description <code>robot</code> <code>Robot</code> <p>a new robot object</p> Source code in <code>src\\python_motion_planning\\utils\\agent\\agent.py</code> Python<pre><code>def kinematic(self, u: np.ndarray, dt: float, replace: bool = True):\n    \"\"\"\n    Run robot kinematic once.\n\n    Parameters:\n        u (np.ndarray): control command with [v, w]\n        dt (float): simulation time\n        replace (bool): update-self if true else return a new Robot object\n\n    Returns:\n        robot (Robot): a new robot object\n    \"\"\"\n    new_state = self.lookforward(self.state, u, dt).squeeze().tolist()\n    if replace:\n        self.history_pose.append((self.px, self.py, self.theta))\n        self.px, self.py, self.theta = new_state[0], new_state[1], new_state[2]\n        self.v, self.w = new_state[3], new_state[4]\n    else:\n        new_robot = Robot(new_state[0], new_state[1], new_state[2], \n            new_state[3], new_state[4])\n        new_robot.setParameters(self.parameters)\n        return new_robot\n</code></pre>"},{"location":"utils/agent/agent/Robot.html#src.python_motion_planning.utils.agent.agent.Robot.lookforward","title":"<code>lookforward(state, u, dt)</code>","text":"<p>Run robot kinematic once but do not update.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray</code> <p>robot state with [x, y, theta, v, w]</p> required <code>u</code> <code>ndarray</code> <p>control command with [v, w]</p> required <code>dt</code> <code>float</code> <p>simulation time</p> required <code>obstacles</code> <code>set</code> <p>set of obstacles with (x, y)</p> required <p>Returns:</p> Name Type Description <code>new_state</code> <code>np.ndarray (5x1)</code> <p>new robot state with [x, y, theta, v, w]</p> Source code in <code>src\\python_motion_planning\\utils\\agent\\agent.py</code> Python<pre><code>def lookforward(self, state: np.ndarray, u: np.ndarray, dt: float) -&gt; np.ndarray:\n    \"\"\"\n    Run robot kinematic once but do not update.\n\n    Parameters:\n        state (np.ndarray): robot state with [x, y, theta, v, w]\n        u (np.ndarray): control command with [v, w]\n        dt (float): simulation time\n        obstacles (set): set of obstacles with (x, y)\n\n    Returns:\n        new_state (np.ndarray (5x1)): new robot state with [x, y, theta, v, w]\n    \"\"\"\n    F = np.array([[1, 0, 0, 0, 0],\n                  [0, 1, 0, 0, 0],\n                  [0, 0, 1, 0, 0],\n                  [0, 0, 0, 0, 0],\n                  [0, 0, 0, 0, 0]])\n    B = np.array([[dt * math.cos(state[2]),  0],\n                  [dt * math.sin(state[2]),  0],\n                  [                      0, dt],\n                  [                      1,  0],\n                  [                      0,  1]])\n    new_state = F @ state + B @ u\n\n    return new_state\n</code></pre>"},{"location":"utils/agent/agent/Robot.html#src.python_motion_planning.utils.agent.agent.Robot.reset","title":"<code>reset()</code>","text":"<p>Reset the state.</p> Source code in <code>src\\python_motion_planning\\utils\\agent\\agent.py</code> Python<pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset the state.\n    \"\"\"\n    self.v = 0\n    self.w = 0\n    self.history_pose = []\n</code></pre>"},{"location":"utils/environment/env/Env.html","title":"Env","text":""},{"location":"utils/environment/env/Env.html#src.python_motion_planning.utils.environment.env.Env","title":"<code>src.python_motion_planning.utils.environment.env.Env</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Class for building 2-d workspace of robots.</p> <p>Parameters:</p> Name Type Description Default <code>x_range</code> <code>int</code> <p>x-axis range of enviroment</p> required <code>y_range</code> <code>int</code> <p>y-axis range of environmet</p> required <code>eps</code> <code>float</code> <p>tolerance for float comparison</p> <code>1e-06</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning.utils import Env\n&gt;&gt;&gt; env = Env(30, 40)\n</code></pre> Source code in <code>src\\python_motion_planning\\utils\\environment\\env.py</code> Python<pre><code>class Env(ABC):\n    \"\"\"\n    Class for building 2-d workspace of robots.\n\n    Parameters:\n        x_range (int): x-axis range of enviroment\n        y_range (int): y-axis range of environmet\n        eps (float): tolerance for float comparison\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning.utils import Env\n        &gt;&gt;&gt; env = Env(30, 40)\n    \"\"\"\n    def __init__(self, x_range: int, y_range: int, eps: float = 1e-6) -&gt; None:\n        # size of environment\n        self.x_range = x_range  \n        self.y_range = y_range\n        self.eps = eps\n\n    @property\n    def grid_map(self) -&gt; set:\n        return {(i, j) for i in range(self.x_range) for j in range(self.y_range)}\n\n    @abstractmethod\n    def init(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"utils/environment/env/Grid.html","title":"Grid","text":""},{"location":"utils/environment/env/Grid.html#src.python_motion_planning.utils.environment.env.Grid","title":"<code>src.python_motion_planning.utils.environment.env.Grid</code>","text":"<p>               Bases: <code>Env</code></p> <p>Class for discrete 2-d grid map.</p> Source code in <code>src\\python_motion_planning\\utils\\environment\\env.py</code> Python<pre><code>class Grid(Env):\n    \"\"\"\n    Class for discrete 2-d grid map.\n    \"\"\"\n    def __init__(self, x_range: int, y_range: int) -&gt; None:\n        super().__init__(x_range, y_range)\n        # allowed motions\n        self.motions = [Node((-1, 0), None, 1, None), Node((-1, 1),  None, sqrt(2), None),\n                        Node((0, 1),  None, 1, None), Node((1, 1),   None, sqrt(2), None),\n                        Node((1, 0),  None, 1, None), Node((1, -1),  None, sqrt(2), None),\n                        Node((0, -1), None, 1, None), Node((-1, -1), None, sqrt(2), None)]\n        # obstacles\n        self.obstacles = None\n        self.obstacles_tree = None\n        self.init()\n\n    def init(self) -&gt; None:\n        \"\"\"\n        Initialize grid map.\n        \"\"\"\n        x, y = self.x_range, self.y_range\n        obstacles = set()\n\n        # boundary of environment\n        for i in range(x):\n            obstacles.add((i, 0))\n            obstacles.add((i, y - 1))\n        for i in range(y):\n            obstacles.add((0, i))\n            obstacles.add((x - 1, i))\n\n        # user-defined obstacles        \n        for i in range(10, 21):\n            obstacles.add((i, 15))\n        for i in range(15):\n            obstacles.add((20, i))\n        for i in range(15, 30):\n            obstacles.add((30, i))\n        for i in range(16):\n            obstacles.add((40, i))\n\n        self.obstacles = obstacles\n        self.obstacles_tree = cKDTree(np.array(list(obstacles)))\n\n    def update(self, obstacles):\n        self.obstacles = obstacles \n        self.obstacles_tree = cKDTree(np.array(list(obstacles)))\n</code></pre>"},{"location":"utils/environment/env/Grid.html#src.python_motion_planning.utils.environment.env.Grid.init","title":"<code>init()</code>","text":"<p>Initialize grid map.</p> Source code in <code>src\\python_motion_planning\\utils\\environment\\env.py</code> Python<pre><code>def init(self) -&gt; None:\n    \"\"\"\n    Initialize grid map.\n    \"\"\"\n    x, y = self.x_range, self.y_range\n    obstacles = set()\n\n    # boundary of environment\n    for i in range(x):\n        obstacles.add((i, 0))\n        obstacles.add((i, y - 1))\n    for i in range(y):\n        obstacles.add((0, i))\n        obstacles.add((x - 1, i))\n\n    # user-defined obstacles        \n    for i in range(10, 21):\n        obstacles.add((i, 15))\n    for i in range(15):\n        obstacles.add((20, i))\n    for i in range(15, 30):\n        obstacles.add((30, i))\n    for i in range(16):\n        obstacles.add((40, i))\n\n    self.obstacles = obstacles\n    self.obstacles_tree = cKDTree(np.array(list(obstacles)))\n</code></pre>"},{"location":"utils/environment/env/Map.html","title":"Map","text":""},{"location":"utils/environment/env/Map.html#src.python_motion_planning.utils.environment.env.Map","title":"<code>src.python_motion_planning.utils.environment.env.Map</code>","text":"<p>               Bases: <code>Env</code></p> <p>Class for continuous 2-d map.</p> Source code in <code>src\\python_motion_planning\\utils\\environment\\env.py</code> Python<pre><code>class Map(Env):\n    \"\"\"\n    Class for continuous 2-d map.\n    \"\"\"\n    def __init__(self, x_range: int, y_range: int) -&gt; None:\n        super().__init__(x_range, y_range)\n        self.boundary = None\n        self.obs_circ = None\n        self.obs_rect = None\n        self.init()\n\n    def init(self):\n        \"\"\"\n        Initialize map.\n        \"\"\"\n        x, y = self.x_range, self.y_range\n\n        # boundary of environment\n        self.boundary = [\n            [0, 0, 1, y],\n            [0, y, x, 1],\n            [1, 0, x, 1],\n            [x, 1, 1, y]\n        ]\n\n        # user-defined obstacles\n        self.obs_rect = [\n            [14, 12, 8, 2],\n            [18, 22, 8, 3],\n            [26, 7, 2, 12],\n            [32, 14, 10, 2]\n        ]\n\n        self.obs_circ = [\n            [7, 12, 3],\n            [46, 20, 2],\n            [15, 5, 2],\n            [37, 7, 3],\n            [37, 23, 3]\n        ]\n\n    def update(self, boundary, obs_circ, obs_rect):\n        self.boundary = boundary if boundary else self.boundary\n        self.obs_circ = obs_circ if obs_circ else self.obs_circ\n        self.obs_rect = obs_rect if obs_rect else self.obs_rect\n</code></pre>"},{"location":"utils/environment/env/Map.html#src.python_motion_planning.utils.environment.env.Map.init","title":"<code>init()</code>","text":"<p>Initialize map.</p> Source code in <code>src\\python_motion_planning\\utils\\environment\\env.py</code> Python<pre><code>def init(self):\n    \"\"\"\n    Initialize map.\n    \"\"\"\n    x, y = self.x_range, self.y_range\n\n    # boundary of environment\n    self.boundary = [\n        [0, 0, 1, y],\n        [0, y, x, 1],\n        [1, 0, x, 1],\n        [x, 1, 1, y]\n    ]\n\n    # user-defined obstacles\n    self.obs_rect = [\n        [14, 12, 8, 2],\n        [18, 22, 8, 3],\n        [26, 7, 2, 12],\n        [32, 14, 10, 2]\n    ]\n\n    self.obs_circ = [\n        [7, 12, 3],\n        [46, 20, 2],\n        [15, 5, 2],\n        [37, 7, 3],\n        [37, 23, 3]\n    ]\n</code></pre>"},{"location":"utils/environment/node/Node.html","title":"Node","text":""},{"location":"utils/environment/node/Node.html#src.python_motion_planning.utils.environment.node.Node","title":"<code>src.python_motion_planning.utils.environment.node.Node</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for searching nodes.</p> <p>Parameters:</p> Name Type Description Default <code>current</code> <code>tuple</code> <p>current coordinate</p> required <code>parent</code> <code>tuple</code> <p>coordinate of parent node</p> <code>None</code> <code>g</code> <code>float</code> <p>path cost</p> <code>0</code> <code>h</code> <code>float</code> <p>heuristic cost</p> <code>0</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from env import Node\n&gt;&gt;&gt; node1 = Node((1, 0), (2, 3), 1, 2)\n&gt;&gt;&gt; node2 = Node((1, 0), (2, 5), 2, 8)\n&gt;&gt;&gt; node3 = Node((2, 0), (1, 6), 3, 1)\n...\n&gt;&gt;&gt; node1 + node2\n&gt;&gt;&gt; Node((2, 0), (2, 3), 3, 2)\n...\n&gt;&gt;&gt; node1 == node2\n&gt;&gt;&gt; True\n...\n&gt;&gt;&gt; node1 != node3\n&gt;&gt;&gt; True\n</code></pre> Source code in <code>src\\python_motion_planning\\utils\\environment\\node.py</code> Python<pre><code>class Node(object):\n    \"\"\"\n    Class for searching nodes.\n\n    Parameters:\n        current (tuple): current coordinate\n        parent (tuple): coordinate of parent node\n        g (float): path cost\n        h (float): heuristic cost\n\n    Examples:\n        &gt;&gt;&gt; from env import Node\n        &gt;&gt;&gt; node1 = Node((1, 0), (2, 3), 1, 2)\n        &gt;&gt;&gt; node2 = Node((1, 0), (2, 5), 2, 8)\n        &gt;&gt;&gt; node3 = Node((2, 0), (1, 6), 3, 1)\n        ...\n        &gt;&gt;&gt; node1 + node2\n        &gt;&gt;&gt; Node((2, 0), (2, 3), 3, 2)\n        ...\n        &gt;&gt;&gt; node1 == node2\n        &gt;&gt;&gt; True\n        ...\n        &gt;&gt;&gt; node1 != node3\n        &gt;&gt;&gt; True\n    \"\"\"\n    def __init__(self, current: tuple, parent: tuple = None, g: float = 0, h: float = 0) -&gt; None:\n        self.current = current\n        self.parent = parent\n        self.g = g\n        self.h = h\n\n    def __add__(self, node):\n        assert isinstance(node, Node)\n        return Node((self.x + node.x, self.y + node.y), self.parent, self.g + node.g, self.h)\n\n    def __eq__(self, node) -&gt; bool:\n        if not isinstance(node, Node):\n            return False\n        return self.current == node.current\n\n    def __ne__(self, node) -&gt; bool:\n        return not self.__eq__(node)\n\n    def __lt__(self, node) -&gt; bool:\n        assert isinstance(node, Node)\n        return self.g + self.h &lt; node.g + node.h or \\\n                (self.g + self.h == node.g + node.h and self.h &lt; node.h)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.current)\n\n    def __str__(self) -&gt; str:\n        return \"Node({}, {}, {}, {})\".format(self.current, self.parent, self.g, self.h)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    @property\n    def x(self) -&gt; float:\n        return self.current[0]\n\n    @property\n    def y(self) -&gt; float:\n        return self.current[1]\n\n    @property\n    def px(self) -&gt; float:\n        if self.parent:\n            return self.parent[0]\n        else:\n            return None\n\n    @property\n    def py(self) -&gt; float:\n        if self.parent:\n            return self.parent[1]\n        else:\n            return None\n</code></pre>"},{"location":"utils/environment/point2d/Point2D.html","title":"Point2D","text":""},{"location":"utils/environment/point2d/Point2D.html#src.python_motion_planning.utils.environment.point2d.Point2D","title":"<code>src.python_motion_planning.utils.environment.point2d.Point2D</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for searching and manipulating 2-dimensional points.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x-coordinate of the 2d point</p> required <code>y</code> <code>float</code> <p>y-coordinate of the 2d point</p> required <code>eps</code> <code>float</code> <p>tolerance for float comparison</p> <code>1e-06</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning import Point2D\n&gt;&gt;&gt; p1 = Point2D(1, 2)\n&gt;&gt;&gt; p2 = Point2D(3, 4)\n...\n&gt;&gt;&gt; p1\n&gt;&gt;&gt; Point2D(1, 2)\n...\n&gt;&gt;&gt; p1 + p2\n&gt;&gt;&gt; Point2D(4, 6)\n...\n&gt;&gt;&gt; p1 - p2\n&gt;&gt;&gt; Point2D(-2, -2)\n...\n&gt;&gt;&gt; p1 == p2\n&gt;&gt;&gt; False\n...\n&gt;&gt;&gt; p1!= p2\n&gt;&gt;&gt; True\n...\n&gt;&gt;&gt; p1.dist(p2)\n&gt;&gt;&gt; 2.8284271247461903\n...\n&gt;&gt;&gt; p1.angle(p2)\n&gt;&gt;&gt; 0.7853981633974483\n</code></pre> Source code in <code>src\\python_motion_planning\\utils\\environment\\point2d.py</code> Python<pre><code>class Point2D(object):\n    \"\"\"\n    Class for searching and manipulating 2-dimensional points.\n\n    Parameters:\n        x: x-coordinate of the 2d point\n        y: y-coordinate of the 2d point\n        eps: tolerance for float comparison\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning import Point2D\n        &gt;&gt;&gt; p1 = Point2D(1, 2)\n        &gt;&gt;&gt; p2 = Point2D(3, 4)\n        ...\n        &gt;&gt;&gt; p1\n        &gt;&gt;&gt; Point2D(1, 2)\n        ...\n        &gt;&gt;&gt; p1 + p2\n        &gt;&gt;&gt; Point2D(4, 6)\n        ...\n        &gt;&gt;&gt; p1 - p2\n        &gt;&gt;&gt; Point2D(-2, -2)\n        ...\n        &gt;&gt;&gt; p1 == p2\n        &gt;&gt;&gt; False\n        ...\n        &gt;&gt;&gt; p1!= p2\n        &gt;&gt;&gt; True\n        ...\n        &gt;&gt;&gt; p1.dist(p2)\n        &gt;&gt;&gt; 2.8284271247461903\n        ...\n        &gt;&gt;&gt; p1.angle(p2)\n        &gt;&gt;&gt; 0.7853981633974483\n    \"\"\"\n\n    def __init__(self, x: float, y: float, eps: float = 1e-6) -&gt; None:\n        self.x = x\n        self.y = y\n        self.eps = eps\n\n        if abs(self.x - round(self.x)) &lt; self.eps:\n            self.x = round(self.x)\n\n        if abs(self.y - round(self.y)) &lt; self.eps:\n            self.y = round(self.y)\n\n    def __add__(self, point):\n        assert isinstance(point, Point2D)\n        return Point2D(self.x + point.x, self.y + point.y)\n\n    def __sub__(self, point):\n        assert isinstance(point, Point2D)\n        return Point2D(self.x - point.x, self.y - point.y)\n\n    def __eq__(self, point) -&gt; bool:\n        if not isinstance(point, Point2D):\n            return False\n        return abs(self.x - point.x) &lt; self.eps and abs(self.y - point.y) &lt; self.eps\n\n    def __ne__(self, point) -&gt; bool:\n        return not self.__eq__(point)\n\n    def __hash__(self) -&gt; int:\n        return hash((self.x, self.y))\n\n    def __str__(self) -&gt; str:\n        return \"Point2D({}, {})\".format(self.x, self.y)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    @staticmethod\n    def from_tuple(point: tuple):\n        return Point2D(point[0], point[1])\n\n    @property\n    def to_tuple(self) -&gt; tuple:\n        return int(self.x), int(self.y)\n\n    def dist(self, point) -&gt; float:\n        assert isinstance(point, Point2D)\n        return math.hypot(self.x - point.x, self.y - point.y)\n\n    def angle(self, point) -&gt; float:\n        assert isinstance(point, Point2D)\n        return math.atan2(point.y - self.y, point.x - self.x)\n</code></pre>"},{"location":"utils/environment/pose2d/Pose2D.html","title":"Pose2D","text":""},{"location":"utils/environment/pose2d/Pose2D.html#src.python_motion_planning.utils.environment.pose2d.Pose2D","title":"<code>src.python_motion_planning.utils.environment.pose2d.Pose2D</code>","text":"<p>               Bases: <code>object</code></p> <p>Class for searching and manipulating 2-dimensional poses.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x-coordinate of the 2d pose</p> required <code>y</code> <code>float</code> <p>y-coordinate of the 2d pose</p> required <code>theta</code> <code>float</code> <p>orientation of the 2d pose in radians</p> <code>0</code> <code>eps</code> <code>float</code> <p>tolerance for float comparison</p> <code>1e-06</code> <p>Examples:</p> Python Console Session<pre><code>&gt;&gt;&gt; from python_motion_planning import Pose2D\n&gt;&gt;&gt; p1 = Pose2D(1, 2)\n&gt;&gt;&gt; p2 = Pose2D(3, 4, 1)\n...\n&gt;&gt;&gt; p1\n&gt;&gt;&gt; Pose2D(1, 2, 0)\n...\n&gt;&gt;&gt; p2\n&gt;&gt;&gt; Pose2D(3, 4, 1)\n...\n&gt;&gt;&gt; p1 + p2\n&gt;&gt;&gt; Pose2D(4, 6, 1)\n...\n&gt;&gt;&gt; p1 - p2\n&gt;&gt;&gt; Pose2D(-2, -2, -1)\n...\n&gt;&gt;&gt; p1 == p2\n&gt;&gt;&gt; False\n...\n&gt;&gt;&gt; p1!= p2\n&gt;&gt;&gt; True\n</code></pre> Source code in <code>src\\python_motion_planning\\utils\\environment\\pose2d.py</code> Python<pre><code>class Pose2D(object):\n    \"\"\"\n    Class for searching and manipulating 2-dimensional poses.\n\n    Parameters:\n        x: x-coordinate of the 2d pose\n        y: y-coordinate of the 2d pose\n        theta: orientation of the 2d pose in radians\n        eps: tolerance for float comparison\n\n    Examples:\n        &gt;&gt;&gt; from python_motion_planning import Pose2D\n        &gt;&gt;&gt; p1 = Pose2D(1, 2)\n        &gt;&gt;&gt; p2 = Pose2D(3, 4, 1)\n        ...\n        &gt;&gt;&gt; p1\n        &gt;&gt;&gt; Pose2D(1, 2, 0)\n        ...\n        &gt;&gt;&gt; p2\n        &gt;&gt;&gt; Pose2D(3, 4, 1)\n        ...\n        &gt;&gt;&gt; p1 + p2\n        &gt;&gt;&gt; Pose2D(4, 6, 1)\n        ...\n        &gt;&gt;&gt; p1 - p2\n        &gt;&gt;&gt; Pose2D(-2, -2, -1)\n        ...\n        &gt;&gt;&gt; p1 == p2\n        &gt;&gt;&gt; False\n        ...\n        &gt;&gt;&gt; p1!= p2\n        &gt;&gt;&gt; True\n    \"\"\"\n\n    def __init__(self, x: float, y: float, theta: float = 0, eps: float = 1e-6) -&gt; None:\n        self.x = x\n        self.y = y\n        self.theta = theta\n        self.eps = eps\n\n        if abs(self.x - round(self.x)) &lt; self.eps:\n            self.x = round(self.x)\n\n        if abs(self.y - round(self.y)) &lt; self.eps:\n            self.y = round(self.y)\n\n        if abs(self.theta - round(self.theta)) &lt; self.eps:\n            self.theta = round(self.theta)\n\n    def __add__(self, pose):\n        assert isinstance(pose, Pose2D)\n        return Pose2D(self.x + pose.x, self.y + pose.y, self.theta + pose.theta)\n\n    def __sub__(self, pose):\n        assert isinstance(pose, Pose2D)\n        return Pose2D(self.x - pose.x, self.y - pose.y, self.theta - pose.theta)\n\n    def __eq__(self, pose) -&gt; bool:\n        if not isinstance(pose, Pose2D):\n            return False\n        return (abs(self.x - pose.x) &lt; self.eps and abs(self.y - pose.y) &lt; self.eps\n                and abs(self.theta - pose.theta) &lt; self.eps)\n\n    def __ne__(self, pose) -&gt; bool:\n        return not self.__eq__(pose)\n\n    def __hash__(self) -&gt; int:\n        return hash((self.x, self.y, self.theta))\n\n    def __str__(self) -&gt; str:\n        return \"Pose2D({}, {}, {})\".format(self.x, self.y, self.theta)\n\n    def __repr__(self) -&gt; str:\n        return self.__str__()\n\n    @staticmethod\n    def from_tuple(pose: tuple):\n        return Pose2D(pose[0], pose[1], pose[2])\n\n    @property\n    def to_tuple(self) -&gt; tuple:\n        return self.x, self.y, self.theta\n</code></pre>"},{"location":"utils/helper/math_helper/MathHelper.html","title":"MathHelper","text":""},{"location":"utils/helper/math_helper/MathHelper.html#src.python_motion_planning.utils.helper.math_helper.MathHelper","title":"<code>src.python_motion_planning.utils.helper.math_helper.MathHelper</code>","text":"Source code in <code>src\\python_motion_planning\\utils\\helper\\math_helper.py</code> Python<pre><code>class MathHelper:\n    @staticmethod\n    def circleSegmentIntersection(p1: tuple, p2: tuple, r: float) -&gt; list:\n        x1, x2 = p1[0], p2[0]\n        y1, y2 = p1[1], p2[1]\n\n        dx, dy = x2 - x1, y2 - y1\n        dr2 = dx * dx + dy * dy\n        D = x1 * y2 - x2 * y1\n\n        # the first element is the point within segment\n        d1 = x1 * x1 + y1 * y1\n        d2 = x2 * x2 + y2 * y2\n        dd = d2 - d1\n\n        delta_2 = r * r * dr2 - D * D\n        if delta_2 &lt; 0:  # no intersection\n            return []\n\n        delta = math.sqrt(delta_2)\n        if (delta == 0):\n            return [(D * dy / dr2, -D * dx / dr2)]\n        else:   # delta &gt; 0\n            return [\n                ((D * dy + math.copysign(1.0, dd) * dx * delta) / dr2,\n                (-D * dx + math.copysign(1.0, dd) * dy * delta) / dr2),\n                ((D * dy - math.copysign(1.0, dd) * dx * delta) / dr2,\n                (-D * dx - math.copysign(1.0, dd) * dy * delta) / dr2)\n            ]\n\n    @staticmethod\n    def closestPointOnLine(a: tuple, b: tuple, p: tuple = (0.0, 0.0)) -&gt; tuple:\n        \"\"\"\n        Find the closest intersection point (foot of a perpendicular) between point p and the line ab.\n\n        Parameters:\n            a (tuple): point a of the line\n            b (tuple): point b of the line\n            p (tuple): point p to find the closest intersection point\n\n        References:\n            [1] method 2 of https://www.youtube.com/watch?v=TPDgB6136ZE\n        \"\"\"\n        ap = (p[0] - a[0], p[1] - a[1])\n        ab = (b[0] - a[0], b[1] - a[1])\n        af_coef = (ap[0] * ab[0] + ap[1] * ab[1]) / (ab[0] ** 2 + ab[1] ** 2)\n        af = (af_coef * ab[0], af_coef * ab[1])\n        f = (a[0] + af[0], a[1] + af[1])\n        return f\n\n    @staticmethod\n    def clamp(val: float, min_val: float, max_val: float) -&gt; float:\n        if val &lt; min_val:\n            val = min_val\n        if val &gt; max_val :\n            val = max_val\n        return val\n</code></pre>"},{"location":"utils/helper/math_helper/MathHelper.html#src.python_motion_planning.utils.helper.math_helper.MathHelper.closestPointOnLine","title":"<code>closestPointOnLine(a, b, p=(0.0, 0.0))</code>  <code>staticmethod</code>","text":"<p>Find the closest intersection point (foot of a perpendicular) between point p and the line ab.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>tuple</code> <p>point a of the line</p> required <code>b</code> <code>tuple</code> <p>point b of the line</p> required <code>p</code> <code>tuple</code> <p>point p to find the closest intersection point</p> <code>(0.0, 0.0)</code> References <p>[1] method 2 of https://www.youtube.com/watch?v=TPDgB6136ZE</p> Source code in <code>src\\python_motion_planning\\utils\\helper\\math_helper.py</code> Python<pre><code>@staticmethod\ndef closestPointOnLine(a: tuple, b: tuple, p: tuple = (0.0, 0.0)) -&gt; tuple:\n    \"\"\"\n    Find the closest intersection point (foot of a perpendicular) between point p and the line ab.\n\n    Parameters:\n        a (tuple): point a of the line\n        b (tuple): point b of the line\n        p (tuple): point p to find the closest intersection point\n\n    References:\n        [1] method 2 of https://www.youtube.com/watch?v=TPDgB6136ZE\n    \"\"\"\n    ap = (p[0] - a[0], p[1] - a[1])\n    ab = (b[0] - a[0], b[1] - a[1])\n    af_coef = (ap[0] * ab[0] + ap[1] * ab[1]) / (ab[0] ** 2 + ab[1] ** 2)\n    af = (af_coef * ab[0], af_coef * ab[1])\n    f = (a[0] + af[0], a[1] + af[1])\n    return f\n</code></pre>"},{"location":"utils/planner/control_factory/ControlFactory.html","title":"ControlFactory","text":""},{"location":"utils/planner/control_factory/ControlFactory.html#src.python_motion_planning.utils.planner.control_factory.ControlFactory","title":"<code>src.python_motion_planning.utils.planner.control_factory.ControlFactory</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>src\\python_motion_planning\\utils\\planner\\control_factory.py</code> Python<pre><code>class ControlFactory(object):\n    def __init__(self) -&gt; None:\n        pass\n\n    def __call__(self, planner_name, **config):\n        if planner_name == \"dwa\":\n            return DWA(**config)\n        elif planner_name == \"pid\":\n            return PID(**config)\n        elif planner_name == \"apf\":\n            return APF(**config)\n        elif planner_name == \"rpp\":\n            return RPP(**config)\n        elif planner_name == \"lqr\":\n            return LQR(**config)\n        elif planner_name == \"mpc\":\n            return MPC(**config)\n        else:\n            raise ValueError(\"The `planner_name` must be set correctly.\")\n</code></pre>"},{"location":"utils/planner/curve_factory/CurveFactory.html","title":"CurveFactory","text":""},{"location":"utils/planner/curve_factory/CurveFactory.html#src.python_motion_planning.utils.planner.curve_factory.CurveFactory","title":"<code>src.python_motion_planning.utils.planner.curve_factory.CurveFactory</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>src\\python_motion_planning\\utils\\planner\\curve_factory.py</code> Python<pre><code>class CurveFactory(object):\n    def __init__(self) -&gt; None:\n        pass\n\n    def __call__(self, curve_name, **config):\n        if curve_name == \"dubins\":\n            return Dubins(**config)\n        elif curve_name == \"bezier\":\n            return Bezier(**config)\n        elif curve_name == \"polynomial\":\n            return Polynomial(**config)\n        elif curve_name == \"reeds_shepp\":\n            return ReedsShepp(**config)\n        elif curve_name == \"cubic_spline\":\n            return CubicSpline(**config)\n        elif curve_name == \"bspline\":\n            return BSpline(**config)\n        elif curve_name == \"fem_pos_smoother\":\n            return FemPosSmoother(**config)\n        else:\n            raise ValueError(\"The `curve_name` must be set correctly.\")\n</code></pre>"},{"location":"utils/planner/planner/Planner.html","title":"Planner","text":""},{"location":"utils/planner/planner/Planner.html#src.python_motion_planning.utils.planner.planner.Planner","title":"<code>src.python_motion_planning.utils.planner.planner.Planner</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src\\python_motion_planning\\utils\\planner\\planner.py</code> Python<pre><code>class Planner(ABC):\n    def __init__(self, start: tuple, goal: tuple, env: Env) -&gt; None:\n        # plannig start and goal\n        self.start = Node(start, start, 0, 0)\n        self.goal = Node(goal, goal, 0, 0)\n        # environment\n        self.env = env\n        # graph handler\n        self.plot = Plot(start, goal, env)\n\n    def dist(self, node1: Node, node2: Node) -&gt; float:\n        return math.hypot(node2.x - node1.x, node2.y - node1.y)\n\n    def angle(self, node1: Node, node2: Node) -&gt; float:\n        return math.atan2(node2.y - node1.y, node2.x - node1.x)\n\n    @abstractmethod\n    def plan(self):\n        '''\n        Interface for planning.\n        '''\n        pass\n\n    @abstractmethod\n    def run(self):\n        '''\n        Interface for running both plannig and animation.\n        '''\n        pass\n</code></pre>"},{"location":"utils/planner/planner/Planner.html#src.python_motion_planning.utils.planner.planner.Planner.plan","title":"<code>plan()</code>  <code>abstractmethod</code>","text":"<p>Interface for planning.</p> Source code in <code>src\\python_motion_planning\\utils\\planner\\planner.py</code> Python<pre><code>@abstractmethod\ndef plan(self):\n    '''\n    Interface for planning.\n    '''\n    pass\n</code></pre>"},{"location":"utils/planner/planner/Planner.html#src.python_motion_planning.utils.planner.planner.Planner.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Interface for running both plannig and animation.</p> Source code in <code>src\\python_motion_planning\\utils\\planner\\planner.py</code> Python<pre><code>@abstractmethod\ndef run(self):\n    '''\n    Interface for running both plannig and animation.\n    '''\n    pass\n</code></pre>"},{"location":"utils/planner/search_factory/SearchFactory.html","title":"SearchFactory","text":""},{"location":"utils/planner/search_factory/SearchFactory.html#src.python_motion_planning.utils.planner.search_factory.SearchFactory","title":"<code>src.python_motion_planning.utils.planner.search_factory.SearchFactory</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>src\\python_motion_planning\\utils\\planner\\search_factory.py</code> Python<pre><code>class SearchFactory(object):\n    def __init__(self) -&gt; None:\n        pass\n\n    def __call__(self, planner_name, **config):\n        if planner_name == \"a_star\":\n            return AStar(**config)\n        elif planner_name == \"dijkstra\":\n            return Dijkstra(**config)\n        elif planner_name == \"gbfs\":\n            return GBFS(**config)\n        elif planner_name == \"jps\":\n            return JPS(**config)\n        elif planner_name == \"d_star\":\n            return DStar(**config)\n        elif planner_name == \"lpa_star\":\n            return LPAStar(**config)\n        elif planner_name == \"d_star_lite\":\n            return DStarLite(**config)\n        elif planner_name == \"voronoi\":\n            return VoronoiPlanner(**config)\n        elif planner_name == \"theta_star\":\n            return ThetaStar(**config)\n        elif planner_name == \"lazy_theta_star\":\n            return LazyThetaStar(**config)\n        elif planner_name == \"s_theta_star\":\n            return SThetaStar(**config)\n        elif planner_name == \"anya\":\n            return Anya(**config)\n        elif planner_name == \"rrt\":\n            return RRT(**config)\n        elif planner_name == \"rrt_connect\":\n            return RRTConnect(**config)\n        elif planner_name == \"rrt_star\":\n            return RRTStar(**config)\n        elif planner_name == \"informed_rrt\":\n            return InformedRRT(**config)\n        elif planner_name == \"aco\":\n            return ACO(**config)\n        elif planner_name == \"pso\":\n            return PSO(**config)\n        else:\n            raise ValueError(\"The `planner_name` must be set correctly.\")\n</code></pre>"},{"location":"utils/plot/plot/Plot.html","title":"Plot","text":""},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot","title":"<code>src.python_motion_planning.utils.plot.plot.Plot</code>","text":"Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>class Plot:\n    def __init__(self, start, goal, env: Env):\n        self.start = Node(start, start, 0, 0)\n        self.goal = Node(goal, goal, 0, 0)\n        self.env = env\n        self.fig = plt.figure(\"planning\")\n        self.ax = self.fig.add_subplot()\n\n    def animation(self, path: list, name: str, cost: float = None, expand: list = None, history_pose: list = None,\n                  predict_path: list = None, lookahead_pts: list = None, cost_curve: list = None,\n                  ellipse: np.ndarray = None) -&gt; None:\n        name = name + \"\\ncost: \" + str(cost) if cost else name\n        self.plotEnv(name)\n        if expand is not None:\n            self.plotExpand(expand)\n        if history_pose is not None:\n            self.plotHistoryPose(history_pose, predict_path, lookahead_pts)\n        if path is not None:\n            self.plotPath(path)\n\n        if cost_curve:\n            plt.figure(\"cost curve\")\n            self.plotCostCurve(cost_curve, name)\n\n        if ellipse is not None:\n            self.plotEllipse(ellipse)\n\n        plt.show()\n\n    def plotEnv(self, name: str) -&gt; None:\n        '''\n        Plot environment with static obstacles.\n\n        Parameters\n        ----------\n        name: Algorithm name or some other information\n        '''\n        plt.plot(self.start.x, self.start.y, marker=\"s\", color=\"#ff0000\")\n        plt.plot(self.goal.x, self.goal.y, marker=\"s\", color=\"#1155cc\")\n\n        if isinstance(self.env, Grid):\n            obs_x = [x[0] for x in self.env.obstacles]\n            obs_y = [x[1] for x in self.env.obstacles]\n            plt.plot(obs_x, obs_y, \"sk\")\n\n        if isinstance(self.env, Map):\n            ax = self.fig.add_subplot()\n            # boundary\n            for (ox, oy, w, h) in self.env.boundary:\n                ax.add_patch(patches.Rectangle(\n                        (ox, oy), w, h,\n                        edgecolor='black',\n                        facecolor='black',\n                        fill=True\n                    )\n                )\n            # rectangle obstacles\n            for (ox, oy, w, h) in self.env.obs_rect:\n                ax.add_patch(patches.Rectangle(\n                        (ox, oy), w, h,\n                        edgecolor='black',\n                        facecolor='gray',\n                        fill=True\n                    )\n                )\n            # circle obstacles\n            for (ox, oy, r) in self.env.obs_circ:\n                ax.add_patch(patches.Circle(\n                        (ox, oy), r,\n                        edgecolor='black',\n                        facecolor='gray',\n                        fill=True\n                    )\n                )\n\n        plt.title(name)\n        plt.axis(\"equal\")\n\n    def plotExpand(self, expand: list) -&gt; None:\n        '''\n        Plot expanded grids using in graph searching.\n\n        Parameters\n        ----------\n        expand: Expanded grids during searching\n        '''\n        if self.start in expand:\n            expand.remove(self.start)\n        if self.goal in expand:\n            expand.remove(self.goal)\n\n        count = 0\n        if isinstance(self.env, Grid):\n            for x in expand:\n                count += 1\n                plt.plot(x.x, x.y, color=\"#dddddd\", marker='s')\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                            lambda event: [exit(0) if event.key == 'escape' else None])\n                if count &lt; len(expand) / 3:         length = 20\n                elif count &lt; len(expand) * 2 / 3:   length = 30\n                else:                               length = 40\n                if count % length == 0:             plt.pause(0.001)\n\n        if isinstance(self.env, Map):\n            for x in expand:\n                count += 1\n                if x.parent:\n                    plt.plot([x.parent[0], x.x], [x.parent[1], x.y], \n                        color=\"#dddddd\", linestyle=\"-\")\n                    plt.gcf().canvas.mpl_connect('key_release_event',\n                                                 lambda event:\n                                                 [exit(0) if event.key == 'escape' else None])\n                    if count % 10 == 0:\n                        plt.pause(0.001)\n\n        plt.pause(0.01)\n\n    def plotPath(self, path: list, path_color: str='#13ae00', path_style: str=\"-\") -&gt; None:\n        '''\n        Plot path in global planning.\n\n        Parameters\n        ----------\n        path: Path found in global planning\n        '''\n        path_x = [path[i][0] for i in range(len(path))]\n        path_y = [path[i][1] for i in range(len(path))]\n        plt.plot(path_x, path_y, path_style, linewidth='2', color=path_color)\n        plt.plot(self.start.x, self.start.y, marker=\"s\", color=\"#ff0000\")\n        plt.plot(self.goal.x, self.goal.y, marker=\"s\", color=\"#1155cc\")\n\n    def plotAgent(self, pose: tuple, radius: float=1) -&gt; None:\n        '''\n        Plot agent with specifical pose.\n\n        Parameters\n        ----------\n        pose: Pose of agent\n        radius: Radius of agent\n        '''\n        x, y, theta = pose\n        ref_vec = np.array([[radius / 2], [0]])\n        rot_mat = np.array([[np.cos(theta), -np.sin(theta)],\n                            [np.sin(theta),  np.cos(theta)]])\n        end_pt = rot_mat @ ref_vec + np.array([[x], [y]])\n\n        try:\n            self.ax.artists.pop()\n            for art in self.ax.get_children():\n                if isinstance(art, matplotlib.patches.FancyArrow):\n                    art.remove()\n        except:\n            pass\n\n        self.ax.arrow(x, y, float(end_pt[0]) - x, float(end_pt[1]) - y,\n                width=0.1, head_width=0.40, color=\"r\")\n        circle = plt.Circle((x, y), radius, color=\"r\", fill=False)\n        self.ax.add_artist(circle)\n\n    def plotHistoryPose(self, history_pose, predict_path=None, lookahead_pts=None) -&gt; None:\n        lookahead_handler = None\n        for i, pose in enumerate(history_pose):\n            if i &lt; len(history_pose) - 1:\n                plt.plot([history_pose[i][0], history_pose[i + 1][0]],\n                    [history_pose[i][1], history_pose[i + 1][1]], c=\"#13ae00\")\n                if predict_path is not None:\n                    plt.plot(predict_path[i][:, 0], predict_path[i][:, 1], c=\"#ddd\")\n            i += 1\n\n            # agent\n            self.plotAgent(pose)\n\n            # lookahead\n            if lookahead_handler is not None:\n                lookahead_handler.remove()\n            if lookahead_pts is not None:\n                try:\n                    lookahead_handler = self.ax.scatter(lookahead_pts[i][0], lookahead_pts[i][1], c=\"b\")\n                except:\n                    lookahead_handler = self.ax.scatter(lookahead_pts[-1][0], lookahead_pts[-1][1], c=\"b\")\n\n            plt.gcf().canvas.mpl_connect('key_release_event',\n                                        lambda event: [exit(0) if event.key == 'escape' else None])\n            if i % 5 == 0:             plt.pause(0.03)\n\n    def plotCostCurve(self, cost_list: list, name: str) -&gt; None:\n        '''\n        Plot cost curve with epochs using in evolutionary searching.\n\n        Parameters\n        ----------\n        cost_list: Cost with epochs\n        name: Algorithm name or some other information\n        '''\n        plt.plot(cost_list, color=\"b\")\n        plt.xlabel(\"epochs\")\n        plt.ylabel(\"cost value\")\n        plt.title(name)\n        plt.grid()\n\n    def plotEllipse(self, ellipse: np.ndarray, color: str = 'darkorange', linestyle: str = '--', linewidth: float = 2):\n        plt.plot(ellipse[0, :], ellipse[1, :], linestyle=linestyle, color=color, linewidth=linewidth)\n\n    def connect(self, name: str, func) -&gt; None:\n        self.fig.canvas.mpl_connect(name, func)\n\n    def clean(self):\n        plt.cla()\n\n    def update(self):\n        self.fig.canvas.draw_idle()\n\n    @staticmethod\n    def plotArrow(x, y, theta, length, color):\n        angle = np.deg2rad(30)\n        d = 0.5 * length\n        w = 2\n\n        x_start, y_start = x, y\n        x_end = x + length * np.cos(theta)\n        y_end = y + length * np.sin(theta)\n\n        theta_hat_L = theta + np.pi - angle\n        theta_hat_R = theta + np.pi + angle\n\n        x_hat_start = x_end\n        x_hat_end_L = x_hat_start + d * np.cos(theta_hat_L)\n        x_hat_end_R = x_hat_start + d * np.cos(theta_hat_R)\n\n        y_hat_start = y_end\n        y_hat_end_L = y_hat_start + d * np.sin(theta_hat_L)\n        y_hat_end_R = y_hat_start + d * np.sin(theta_hat_R)\n\n        plt.plot([x_start, x_end], [y_start, y_end], color=color, linewidth=w)\n        plt.plot([x_hat_start, x_hat_end_L], [y_hat_start, y_hat_end_L], color=color, linewidth=w)\n        plt.plot([x_hat_start, x_hat_end_R], [y_hat_start, y_hat_end_R], color=color, linewidth=w)\n\n    @staticmethod\n    def plotCar(x, y, theta, width, length, color):\n        theta_B = np.pi + theta\n\n        xB = x + length / 4 * np.cos(theta_B)\n        yB = y + length / 4 * np.sin(theta_B)\n\n        theta_BL = theta_B + np.pi / 2\n        theta_BR = theta_B - np.pi / 2\n\n        x_BL = xB + width / 2 * np.cos(theta_BL)        # Bottom-Left vertex\n        y_BL = yB + width / 2 * np.sin(theta_BL)\n        x_BR = xB + width / 2 * np.cos(theta_BR)        # Bottom-Right vertex\n        y_BR = yB + width / 2 * np.sin(theta_BR)\n\n        x_FL = x_BL + length * np.cos(theta)               # Front-Left vertex\n        y_FL = y_BL + length * np.sin(theta)\n        x_FR = x_BR + length * np.cos(theta)               # Front-Right vertex\n        y_FR = y_BR + length * np.sin(theta)\n\n        plt.plot([x_BL, x_BR, x_FR, x_FL, x_BL],\n                 [y_BL, y_BR, y_FR, y_FL, y_BL],\n                 linewidth=1, color=color)\n\n        Plot.plotArrow(x, y, theta, length / 2, color)\n</code></pre>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotAgent","title":"<code>plotAgent(pose, radius=1)</code>","text":"<p>Plot agent with specifical pose.</p>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotAgent--parameters","title":"Parameters","text":"<p>pose: Pose of agent radius: Radius of agent</p> Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>def plotAgent(self, pose: tuple, radius: float=1) -&gt; None:\n    '''\n    Plot agent with specifical pose.\n\n    Parameters\n    ----------\n    pose: Pose of agent\n    radius: Radius of agent\n    '''\n    x, y, theta = pose\n    ref_vec = np.array([[radius / 2], [0]])\n    rot_mat = np.array([[np.cos(theta), -np.sin(theta)],\n                        [np.sin(theta),  np.cos(theta)]])\n    end_pt = rot_mat @ ref_vec + np.array([[x], [y]])\n\n    try:\n        self.ax.artists.pop()\n        for art in self.ax.get_children():\n            if isinstance(art, matplotlib.patches.FancyArrow):\n                art.remove()\n    except:\n        pass\n\n    self.ax.arrow(x, y, float(end_pt[0]) - x, float(end_pt[1]) - y,\n            width=0.1, head_width=0.40, color=\"r\")\n    circle = plt.Circle((x, y), radius, color=\"r\", fill=False)\n    self.ax.add_artist(circle)\n</code></pre>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotCostCurve","title":"<code>plotCostCurve(cost_list, name)</code>","text":"<p>Plot cost curve with epochs using in evolutionary searching.</p>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotCostCurve--parameters","title":"Parameters","text":"<p>cost_list: Cost with epochs name: Algorithm name or some other information</p> Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>def plotCostCurve(self, cost_list: list, name: str) -&gt; None:\n    '''\n    Plot cost curve with epochs using in evolutionary searching.\n\n    Parameters\n    ----------\n    cost_list: Cost with epochs\n    name: Algorithm name or some other information\n    '''\n    plt.plot(cost_list, color=\"b\")\n    plt.xlabel(\"epochs\")\n    plt.ylabel(\"cost value\")\n    plt.title(name)\n    plt.grid()\n</code></pre>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotEnv","title":"<code>plotEnv(name)</code>","text":"<p>Plot environment with static obstacles.</p>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotEnv--parameters","title":"Parameters","text":"<p>name: Algorithm name or some other information</p> Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>def plotEnv(self, name: str) -&gt; None:\n    '''\n    Plot environment with static obstacles.\n\n    Parameters\n    ----------\n    name: Algorithm name or some other information\n    '''\n    plt.plot(self.start.x, self.start.y, marker=\"s\", color=\"#ff0000\")\n    plt.plot(self.goal.x, self.goal.y, marker=\"s\", color=\"#1155cc\")\n\n    if isinstance(self.env, Grid):\n        obs_x = [x[0] for x in self.env.obstacles]\n        obs_y = [x[1] for x in self.env.obstacles]\n        plt.plot(obs_x, obs_y, \"sk\")\n\n    if isinstance(self.env, Map):\n        ax = self.fig.add_subplot()\n        # boundary\n        for (ox, oy, w, h) in self.env.boundary:\n            ax.add_patch(patches.Rectangle(\n                    (ox, oy), w, h,\n                    edgecolor='black',\n                    facecolor='black',\n                    fill=True\n                )\n            )\n        # rectangle obstacles\n        for (ox, oy, w, h) in self.env.obs_rect:\n            ax.add_patch(patches.Rectangle(\n                    (ox, oy), w, h,\n                    edgecolor='black',\n                    facecolor='gray',\n                    fill=True\n                )\n            )\n        # circle obstacles\n        for (ox, oy, r) in self.env.obs_circ:\n            ax.add_patch(patches.Circle(\n                    (ox, oy), r,\n                    edgecolor='black',\n                    facecolor='gray',\n                    fill=True\n                )\n            )\n\n    plt.title(name)\n    plt.axis(\"equal\")\n</code></pre>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotExpand","title":"<code>plotExpand(expand)</code>","text":"<p>Plot expanded grids using in graph searching.</p>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotExpand--parameters","title":"Parameters","text":"<p>expand: Expanded grids during searching</p> Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>def plotExpand(self, expand: list) -&gt; None:\n    '''\n    Plot expanded grids using in graph searching.\n\n    Parameters\n    ----------\n    expand: Expanded grids during searching\n    '''\n    if self.start in expand:\n        expand.remove(self.start)\n    if self.goal in expand:\n        expand.remove(self.goal)\n\n    count = 0\n    if isinstance(self.env, Grid):\n        for x in expand:\n            count += 1\n            plt.plot(x.x, x.y, color=\"#dddddd\", marker='s')\n            plt.gcf().canvas.mpl_connect('key_release_event',\n                                        lambda event: [exit(0) if event.key == 'escape' else None])\n            if count &lt; len(expand) / 3:         length = 20\n            elif count &lt; len(expand) * 2 / 3:   length = 30\n            else:                               length = 40\n            if count % length == 0:             plt.pause(0.001)\n\n    if isinstance(self.env, Map):\n        for x in expand:\n            count += 1\n            if x.parent:\n                plt.plot([x.parent[0], x.x], [x.parent[1], x.y], \n                    color=\"#dddddd\", linestyle=\"-\")\n                plt.gcf().canvas.mpl_connect('key_release_event',\n                                             lambda event:\n                                             [exit(0) if event.key == 'escape' else None])\n                if count % 10 == 0:\n                    plt.pause(0.001)\n\n    plt.pause(0.01)\n</code></pre>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotPath","title":"<code>plotPath(path, path_color='#13ae00', path_style='-')</code>","text":"<p>Plot path in global planning.</p>"},{"location":"utils/plot/plot/Plot.html#src.python_motion_planning.utils.plot.plot.Plot.plotPath--parameters","title":"Parameters","text":"<p>path: Path found in global planning</p> Source code in <code>src\\python_motion_planning\\utils\\plot\\plot.py</code> Python<pre><code>def plotPath(self, path: list, path_color: str='#13ae00', path_style: str=\"-\") -&gt; None:\n    '''\n    Plot path in global planning.\n\n    Parameters\n    ----------\n    path: Path found in global planning\n    '''\n    path_x = [path[i][0] for i in range(len(path))]\n    path_y = [path[i][1] for i in range(len(path))]\n    plt.plot(path_x, path_y, path_style, linewidth='2', color=path_color)\n    plt.plot(self.start.x, self.start.y, marker=\"s\", color=\"#ff0000\")\n    plt.plot(self.goal.x, self.goal.y, marker=\"s\", color=\"#1155cc\")\n</code></pre>"}]}